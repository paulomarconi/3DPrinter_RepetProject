CCS PCH C Compiler, Version 4.140, 85               25-nov-14 20:33

               Filename:   C:\Users\Paulo\Documents\PAULO\CONTROL\ETN1040\3Dprinter\3DPrinterProject\firmware\Main3DPrinter.lst

               ROM used:   8304 bytes (25%)
                           Largest free fragment is 18316
               RAM used:   371 (18%) at main() level
                           406 (20%) worst case
               Stack:     14 worst case (5 in main + 9 for interrupts)

*
1800:  GOTO   371E
*
1808:  MOVWF  04
180A:  MOVFF  FD8,05
180E:  MOVFF  FE0,06
1812:  MOVLB  0
1814:  MOVFF  FE9,0C
1818:  MOVFF  FEA,07
181C:  MOVFF  FE1,08
1820:  MOVFF  FE2,09
1824:  MOVFF  FD9,0A
1828:  MOVFF  FDA,0B
182C:  MOVFF  FF3,12
1830:  MOVFF  FF4,13
1834:  MOVFF  FFA,14
1838:  MOVFF  FF5,15
183C:  MOVFF  FF6,16
1840:  MOVFF  FF7,17
1844:  MOVFF  00,0E
1848:  MOVFF  01,0F
184C:  MOVFF  02,10
1850:  MOVFF  03,11
1854:  BTFSS  FF2.5
1856:  GOTO   1860
185A:  BTFSC  FF2.2
185C:  GOTO   2410
1860:  BTFSS  FA0.5
1862:  GOTO   186C
1866:  BTFSC  FA1.5
1868:  GOTO   2310
186C:  MOVFF  0E,00
1870:  MOVFF  0F,01
1874:  MOVFF  10,02
1878:  MOVFF  11,03
187C:  MOVFF  0C,FE9
1880:  MOVFF  07,FEA
1884:  BSF    07.7
1886:  MOVFF  08,FE1
188A:  MOVFF  09,FE2
188E:  MOVFF  0A,FD9
1892:  MOVFF  0B,FDA
1896:  MOVFF  12,FF3
189A:  MOVFF  13,FF4
189E:  MOVFF  14,FFA
18A2:  MOVFF  15,FF5
18A6:  MOVFF  16,FF6
18AA:  MOVFF  17,FF7
18AE:  MOVF   04,W
18B0:  MOVFF  06,FE0
18B4:  MOVFF  05,FD8
18B8:  RETFIE 0
.................... //--- config: PIC ------------------------------------------------------------ 
.................... #include <18F4550.h> 
.................... //////// Standard Header file for the PIC18F4550 device //////////////// 
.................... #device PIC18F4550 
.................... #list 
....................  
.................... #device adc=10 
.................... #fuses HSPLL,MCLR,NOWDT,NOPROTECT,NOLVP,NODEBUG,USBDIV,PLL5,CPUDIV1,VREGEN  
.................... #use delay(crystal=20MHz, clock=48MHz)  
*
26F4:  CLRF   FEA
26F6:  MOVLW  CA
26F8:  MOVWF  FE9
26FA:  MOVF   FEF,W
26FC:  BZ    271A
26FE:  MOVLW  0F
2700:  MOVWF  01
2702:  CLRF   00
2704:  DECFSZ 00,F
2706:  BRA    2704
2708:  DECFSZ 01,F
270A:  BRA    2702
270C:  MOVLW  8F
270E:  MOVWF  00
2710:  DECFSZ 00,F
2712:  BRA    2710
2714:  NOP   
2716:  DECFSZ FEF,F
2718:  BRA    26FE
271A:  GOTO   2890 (RETURN)
....................  
.................... //cabecera necesaria para trabajar con el Bootloader "ex_usb_bootloader.c" 
.................... #include "usb_bootloader.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... ////                     USB_BOOTLOADER.H                              //// 
.................... ////                                                                   //// 
.................... ////  This include file must be included by any application loaded     //// 
.................... ////  by the example USB bootloader (ex_usb_bootloader                 //// 
.................... ////                                                                   //// 
.................... ////  The directives in this file relocate the reset and interrupt     //// 
.................... ////  vectors as well as reserving space for the bootloader.           //// 
.................... ////                                                                   //// 
.................... ////  For more documentation see ex_usb_bootloader.c                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// VERSION HISTORY                                                   //// 
.................... ////                                                                   //// 
.................... //// July 9th, 2012:                                                   //// 
.................... ////  Added support for PCD (see ex_usb_bootloader.c).                 //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #define LOADER_START       (0) 
.................... #define LOADER_SIZE        (0x1800) 
....................  
.................... #if defined(__USB_87J50__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-9) //configuration bits 
.................... #elif defined(__PCD__) 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-2) 
.................... #else 
....................  #define APPLICATION_END    (getenv("PROGRAM_MEMORY")-1) 
.................... #endif 
....................  
.................... #if defined(__PCM__) 
....................    #define LOADER_END      (LOADER_SIZE+0x40-1) 
.................... #elif defined(__PCH__) 
....................    #define FLASH_SIZE getenv("FLASH_ERASE_SIZE") 
....................    #if (((LOADER_SIZE) % FLASH_SIZE) == 0 )       //IF LOADER_SIZE is even flash boundary 
....................       #define LOADER_END   (LOADER_SIZE-1) 
....................    #else                                  //ELSE, goto next even boundary 
....................       #define LOADER_END   (((LOADER_SIZE)+FLASH_SIZE-((LOADER_SIZE)%FLASH_SIZE))-1) 
....................    #endif 
.................... #elif defined(__PCD__) 
....................    #define FLASH_SIZE getenv("FLASH_ERASE_SIZE")/2 
....................    #if (((LOADER_START+LOADER_SIZE) % FLASH_SIZE) == 0) 
....................       #define LOADER_END (LOADER_START+LOADER_SIZE-1) 
....................    #else 
....................       #define LOADER_END (LOADER_START+(LOADER_SIZE+FLASH_SIZE-((LOADER_SIZE)%FLASH_SIZE))-1) 
....................    #endif 
.................... #else 
....................  #error PCM, PCH, and PCD only supported 
.................... #endif 
....................  
.................... #define APPLICATION_START  (LOADER_END+1) 
....................  
.................... #if defined(__PCH__) 
....................  #define APPLICATION_ISR (APPLICATION_START+8) 
.................... #elif defined(__PCM__) 
....................  #define APPLICATION_ISR (APPLICATION_START+4) 
.................... #elif defined(__PCD__) 
....................  #define APPLICATION_ISR (APPLICATION_START+4) 
.................... #endif 
....................  
.................... //// --- end configuration --- //////////////////////////////////////////// 
....................  
.................... #ifdef _bootloader 
....................  // bootloader won't use interrupts, instead it will poll USB IF 
....................  #define USB_ISR_POLLING 
....................   
....................  /* 
....................   Provide an empty application, so if you load this .HEX file into the pic 
....................   without an application this will prevent the pic from executing unknown code. 
....................  */ 
....................  #org APPLICATION_START,APPLICATION_START+0xF 
....................  void BlankApplication(void)  
....................  { 
....................    while(TRUE); 
....................  } 
....................  
....................  //we need to prevent the loader from using application space 
....................  #if (APPLICATION_END > 0x10000) 
....................    #org APPLICATION_START+0x10, 0xFFFF {} 
....................    #if (APPLICATION_END > 0x20000) 
....................       #org 0x10000, 0x1FFFF {} 
....................       #org 0x20000, APPLICATION_END {} 
....................    #else 
....................       #org 0x10000, APPLICATION_END {} 
....................    #endif 
....................  #else 
....................    #org APPLICATION_START+0x10, APPLICATION_END {} 
....................  #endif 
....................  
....................    #define  USB_CONFIG_PID       0x0034 
....................  
....................    #define USB_STRINGS_OVERWRITTEN 
....................    char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
....................    // Here is where the "CCS" Manufacturer string and "SERIAL DEMO" are stored. 
....................    // Strings are saved as unicode. 
....................    // These strings are mostly only displayed during the add hardware wizard. 
....................    // Once the operating system drivers have been installed it will usually display 
....................    // the name from the drivers .INF. 
....................    char const USB_STRING_DESC[]={ 
....................       //string 0 
....................             4, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             0x09,0x04,   //Microsoft Defined for US-English 
....................       //string 1  - manufacturer 
....................             8, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'C',0, 
....................             'S',0, 
....................       //string 2 - product 
....................             30, //length of string index 
....................             0x03, //USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................             'C',0, 
....................             'D',0, 
....................             'C',0, 
....................             ' ',0, 
....................             'B',0, 
....................             'o',0, 
....................             'o',0, 
....................             't',0, 
....................             'l',0, 
....................             'o',0, 
....................             'a',0, 
....................             'd',0, 
....................             'e',0, 
....................             'r',0 
....................    }; 
.................... #endif   //_bootloader 
....................  
.................... #ifndef _bootloader 
....................  //in the application, this moves the reset and isr vector out of the bootload 
....................  //space.  it then reserves the loader space from being used by the application. 
....................  #build(reset=APPLICATION_START, interrupt=APPLICATION_ISR) 
....................   
....................  #org 0, LOADER_END {} 
....................  
.................... #endif 
....................  
....................  
.................... //--- config: USB bulkmode --------------------------------------------------- 
.................... #define USB_HID_DEVICE     FALSE 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_BULK  //turn on EP1(EndPoint1)  
....................                                             //for IN bulk/interrupt transfers 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_BULK  //turn on EP1(EndPoint1)  
....................                                             //for OUT bulk/interrupt transfers 
.................... #define USB_EP1_TX_SIZE    3   //size to allocate for the tx endpoint 1 buffer 
.................... #define USB_EP1_RX_SIZE    20  //size to allocate for the rx endpoint 1 buffer 
....................  
.................... #include <pic18_usb.h>        //Microchip PIC18Fxx5x Hardware layer  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   TRUE 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==FALSE 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
....................                               //for CCS's PIC USB driver 
.................... #include "usb_descriptor.h"   //Configuracion del USB y los descriptores  
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_desc_scope.h                          //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// the USB Bulk demo (see ex_usb_scope.c)                            //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////   Endpoint descriptor works if USB_EP1_TX_SIZE is 16bits          //// 
.................... ////   Endpoint descriptor works if USB_EP1_RX_SIZE is 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////   18fxx5x Initial release.                                        //// 
.................... ////                                                                   //// 
.................... //// March 21st, 2005:                                                 //// 
.................... ////   EP 0x01 and EP 0x81 now use USB_EP1_TX_SIZE and USB_EP1_RX_SIZE //// 
.................... ////      to define max packet size, to make it easier for dynamically //// 
.................... ////      changed code.                                                //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2002: Cleanup                                          //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed non-HID descriptors pointing to faulty       //// 
.................... ////                strings                                            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... ///////// config options, although it's best to leave alone for this demo ///// 
.................... #define  USB_CONFIG_PID       0x0011   //changing this value may make the driver incompatible 
.................... #define  USB_CONFIG_VID       0x04D8   //changing this value may make the driver incompatible 
.................... #define  USB_CONFIG_BUS_POWER 100   //100mA  (range is 0..500) 
.................... #define  USB_CONFIG_VERSION   0x0100      //01.00  //range is 00.00 to 99.99 
.................... //////// end config /////////////////////////////////////////////////////////// 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      32 //config+interface+class+endpoint 
....................  
....................    //configuration descriptor 
....................    char const USB_CONFIG_DESC[] = { 
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN,     //length of descriptor size 
....................          USB_DESC_CONFIG_TYPE,         //constant CONFIGURATION (0x02) 
....................          USB_TOTAL_CONFIG_LEN,0,  //size of all data returned for this config 
....................          1,      //number of interfaces this device supports 
....................          0x01,                //identifier for this configuration.  (IF we had more than one configurations) 
....................          0x00,                //index of string descriptor for this configuration 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==7 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA)   ==8 
....................  
....................    //interface descriptor 0 alt 0 
....................          USB_DESC_INTERFACE_LEN,  //length of descriptor 
....................          USB_DESC_INTERFACE_TYPE,      //constant INTERFACE (0x04) 
....................          0x00,                //number defining this interface (IF we had more than one interface) 
....................          0x00,                //alternate setting 
....................          2,       //number of endpoints, not counting endpoint 0. 
....................          0xFF,                //class code, FF = vendor defined 
....................          0xFF,                //subclass code, FF = vendor 
....................          0xFF,                //protocol code, FF = vendor 
....................          0x00,                //index of string descriptor for interface 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x81,              //endpoint number and direction (0x81 = EP1 IN) 
....................          USB_EP1_TX_ENABLE,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_TX_SIZE & 0xFF,USB_EP1_TX_SIZE >> 8,         //maximum packet size supported 
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor 
....................          USB_DESC_ENDPOINT_TYPE,     //constant ENDPOINT (0x05) 
....................          0x01,              //endpoint number and direction (0x01 = EP1 OUT) 
....................          USB_EP1_RX_ENABLE,              //transfer type supported (0 is control, 1 is iso, 2 is bulk, 3 is interrupt) 
....................          USB_EP1_RX_SIZE & 0xFF,USB_EP1_RX_SIZE >> 8,         //maximum packet size supported 
....................          0x01,              //polling interval in ms. (for interrupt transfers ONLY) 
....................   }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   0 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   1 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    //device descriptor 
....................    char const USB_DEVICE_DESC[] ={ 
....................          USB_DESC_DEVICE_LEN,          //the length of this report 
....................          0x01,                //constant DEVICE (0x01) 
....................          0x10,0x01,           //usb version in bcd 
....................          0x00,                //class code (if 0, interface defines class.  FF is vendor defined) 
....................          0x00,                //subclass code 
....................          0x00,                //protocol code 
....................          USB_MAX_EP0_PACKET_LENGTH,   //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01,                //index of string description of manufacturer. therefore we point to string_1 array (see below) 
....................          0x02,                //index of string descriptor of the product 
....................          0x00,                //index of string descriptor of serial number 
....................          USB_NUM_CONFIGURATIONS   //number of possible configurations 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... //the offset of the starting location of each string. 
.................... //offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... const char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... #define USB_STRING_DESC_COUNT sizeof(USB_STRING_DESC_OFFSET) 
....................  
.................... // Here is where the "CCS" Manufacturer string and "CCS Bulk Demo" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          24, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          '3',0, 
....................          'D',0, 
....................          ' ',0, 
....................          'R',0, 
....................          'E',0, 
....................          'P',0, 
....................          'E',0, 
....................          'T',0, 
....................          ' ',0, 
....................          'P',0, 
....................          'L',0 
.................... }; 
....................  
....................  
.................... #ENDIF 
....................  
....................                               //para este dispositivo 
.................... #include <usb.c>  //handles usb setup tokens and get descriptor reports 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16_USB_H__) 
....................  #include <pic_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF5C 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF5D 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF5E 
....................    #byte UCFG    =  0xF5F 
....................    #define  UEP0_LOC 0xF4C 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #locate g_UEP=UEP0_LOC 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
*
29A4:  CLRF   03
29A6:  MOVF   xCA,W
29A8:  ADDLW  70
29AA:  MOVWF  FE9
29AC:  MOVLW  0F
29AE:  ADDWFC 03,W
29B0:  MOVWF  FEA
29B2:  MOVF   FEF,F
29B4:  BZ    29D0
29B6:  MOVF   xCA,W
29B8:  MULLW  08
29BA:  MOVF   FF3,W
29BC:  CLRF   xCC
29BE:  MOVWF  xCB
29C0:  MOVWF  FE9
29C2:  MOVLW  04
29C4:  ADDWF  xCC,W
29C6:  MOVWF  FEA
29C8:  MOVFF  FEF,CD
29CC:  BTFSS  xCD.7
29CE:  BRA    29D4
29D0:  MOVLW  00
29D2:  BRA    29D6
29D4:  MOVLW  01
29D6:  MOVWF  01
.................... } 
29D8:  GOTO   2C1C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
20F4:  CLRF   03
20F6:  MOVF   xE6,W
20F8:  ADDLW  70
20FA:  MOVWF  FE9
20FC:  MOVLW  0F
20FE:  ADDWFC 03,W
2100:  MOVWF  FEA
2102:  MOVF   FEF,F
2104:  BZ    212A
2106:  MOVF   xE6,W
2108:  MULLW  08
210A:  MOVF   FF3,W
210C:  CLRF   xE8
210E:  MOVWF  xE7
2110:  MOVLW  04
2112:  ADDWF  xE7,F
2114:  MOVLW  00
2116:  ADDWFC xE8,F
2118:  MOVFF  E7,FE9
211C:  MOVLW  04
211E:  ADDWF  xE8,W
2120:  MOVWF  FEA
2122:  MOVFF  FEF,E9
2126:  BTFSS  xE9.7
2128:  BRA    212E
212A:  MOVLW  00
212C:  BRA    2130
212E:  MOVLW  01
2130:  MOVWF  01
.................... } 
2132:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
266C:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
266E:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
2670:  MOVLW  08
2672:  MOVWF  F6F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #else 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
2674:  MOVF   F94,W
2676:  IORLW  30
2678:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
267A:  CLRF   1F
267C:  CLRF   19
267E:  BTFSC  FF2.7
2680:  BSF    19.7
2682:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
2684:  CALL   1AD0
2688:  BTFSC  19.7
268A:  BSF    FF2.7
....................    //__usb_kbhit_status=0; 
.................... } 
268C:  GOTO   2692 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
.................... { 
*
2696:  CLRF   19
2698:  BTFSC  FF2.7
269A:  BSF    19.7
269C:  BCF    FF2.7
....................    usb_token_reset(); 
269E:  CALL   1AD0
26A2:  BTFSC  19.7
26A4:  BSF    FF2.7
....................    UCON = 0; 
26A6:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
26A8:  MOVLW  14
26AA:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
26AC:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
26AE:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
26B0:  MOVLW  01
26B2:  MOVWF  1F
.................... } 
26B4:  GOTO   26BE (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
2690:  BRA    266C
.................... } 
2692:  GOTO   26DC (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
26B8:  BTFSC  F6D.3
26BA:  BRA    26BE
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
26BC:  BRA    2696
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
26BE:  DECFSZ 1F,W
26C0:  BRA    26D8
26C2:  BTFSC  F6D.5
26C4:  BRA    26D8
....................    { 
....................       UIR=0; 
26C6:  CLRF   F68
....................       UIE=0; 
26C8:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
26CA:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
26CC:  MOVLW  C0
26CE:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
26D0:  MOVLW  11
26D2:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
26D4:  MOVLW  02
26D6:  MOVWF  1F
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
.................... } 
26D8:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
26DA:  BRA    2690
....................  
....................    do  
....................    { 
....................       usb_task(); 
26DC:  RCALL  26B8
....................    } while (usb_state != USB_STATE_POWERED); 
26DE:  MOVF   1F,W
26E0:  SUBLW  02
26E2:  BNZ   26DC
.................... } 
26E4:  GOTO   2886 (RETURN)
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
2134:  MOVFF  E1,E6
2138:  RCALL  20F4
213A:  MOVF   01,F
213C:  BZ    2200
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
213E:  MOVF   xE1,W
2140:  MULLW  08
2142:  MOVF   FF3,W
2144:  CLRF   xE7
2146:  MOVWF  xE6
2148:  MOVLW  04
214A:  ADDWF  xE6,F
214C:  MOVLW  00
214E:  ADDWFC xE7,F
2150:  MOVLW  01
2152:  ADDWF  xE6,W
2154:  MOVWF  01
2156:  MOVLW  00
2158:  ADDWFC xE7,W
215A:  MOVWF  03
215C:  MOVFF  01,FE9
2160:  MOVLW  04
2162:  ADDWF  03,W
2164:  MOVWF  FEA
2166:  MOVFF  E2,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
216A:  MOVF   xE4,W
216C:  SUBLW  02
216E:  BNZ   219E
....................       { 
....................          i = EP_BDxST_I(endpoint); 
2170:  MOVF   xE1,W
2172:  MULLW  08
2174:  MOVF   FF3,W
2176:  CLRF   xE7
2178:  MOVWF  xE6
217A:  MOVLW  04
217C:  ADDWF  xE6,F
217E:  MOVLW  00
2180:  ADDWFC xE7,F
2182:  MOVFF  E6,FE9
2186:  MOVLW  04
2188:  ADDWF  xE7,W
218A:  MOVWF  FEA
218C:  MOVFF  FEF,E5
....................          if (bit_test(i,6)) 
2190:  BTFSS  xE5.6
2192:  BRA    2198
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
2194:  CLRF   xE4
....................          else 
2196:  BRA    219C
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2198:  MOVLW  01
219A:  MOVWF  xE4
....................       } 
....................       else if (tgl == USB_DTS_USERX)  
219C:  BRA    21C4
219E:  MOVF   xE4,W
21A0:  SUBLW  04
21A2:  BNZ   21C4
....................       { 
....................          i = EP_BDxST_O(endpoint); 
21A4:  MOVF   xE1,W
21A6:  MULLW  08
21A8:  MOVF   FF3,W
21AA:  CLRF   xE7
21AC:  MOVWF  FE9
21AE:  MOVLW  04
21B0:  ADDWF  xE7,W
21B2:  MOVWF  FEA
21B4:  MOVFF  FEF,E5
....................          if (bit_test(i,6)) 
21B8:  BTFSS  xE5.6
21BA:  BRA    21C2
....................             tgl = USB_DTS_DATA1; 
21BC:  MOVLW  01
21BE:  MOVWF  xE4
....................          else 
21C0:  BRA    21C4
....................             tgl = USB_DTS_DATA0; 
21C2:  CLRF   xE4
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
21C4:  DECFSZ xE4,W
21C6:  BRA    21CE
....................          i=0xC8;  //DATA1, UOWN 
21C8:  MOVLW  C8
21CA:  MOVWF  xE5
....................       else //if (tgl == USB_DTS_DATA0)  
21CC:  BRA    21D2
....................          i=0x88; //DATA0, UOWN 
21CE:  MOVLW  88
21D0:  MOVWF  xE5
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
21D2:  BTFSC  xE3.0
21D4:  BSF    xE5.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
21D6:  BTFSC  xE3.1
21D8:  BSF    xE5.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
21DA:  MOVF   xE1,W
21DC:  MULLW  08
21DE:  MOVF   FF3,W
21E0:  CLRF   xE7
21E2:  MOVWF  xE6
21E4:  MOVLW  04
21E6:  ADDWF  xE6,F
21E8:  MOVLW  00
21EA:  ADDWFC xE7,F
21EC:  MOVFF  E6,FE9
21F0:  MOVLW  04
21F2:  ADDWF  xE7,W
21F4:  MOVWF  FEA
21F6:  MOVFF  E5,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
21FA:  MOVLW  01
21FC:  MOVWF  01
21FE:  BRA    2204
....................    } 
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
2200:  MOVLW  00
2202:  MOVWF  01
.................... } 
2204:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
.................... { 
*
2B14:  CLRF   19
2B16:  BTFSC  FF2.7
2B18:  BSF    19.7
2B1A:  BCF    FF2.7
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
2B1C:  MOVFF  CA,E6
2B20:  CALL   20F4
2B24:  BTFSC  19.7
2B26:  BSF    FF2.7
2B28:  MOVF   01,F
2B2A:  BZ    2BB2
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
2B2C:  MOVF   xCA,W
2B2E:  MULLW  08
2B30:  MOVF   FF3,W
2B32:  CLRF   xD3
2B34:  MOVWF  xD2
2B36:  MOVLW  04
2B38:  ADDWF  xD2,F
2B3A:  MOVLW  00
2B3C:  ADDWFC xD3,F
2B3E:  MOVLW  02
2B40:  ADDWF  xD2,W
2B42:  MOVWF  01
2B44:  MOVLW  00
2B46:  ADDWFC xD3,W
2B48:  MOVWF  03
2B4A:  MOVFF  01,FE9
2B4E:  MOVLW  04
2B50:  ADDWF  03,W
2B52:  MOVWF  FEA
2B54:  MOVFF  FEC,D1
2B58:  MOVF   FED,F
2B5A:  MOVFF  FEF,D0
....................       memcpy(buff_add, ptr, len);      
2B5E:  MOVFF  D1,FEA
2B62:  MOVFF  D0,FE9
2B66:  MOVFF  CC,FE2
2B6A:  MOVFF  CB,FE1
2B6E:  MOVFF  CE,02
2B72:  MOVFF  CD,01
2B76:  MOVF   01,F
2B78:  BZ    2B7E
2B7A:  INCF   02,F
2B7C:  BRA    2B82
2B7E:  MOVF   02,F
2B80:  BZ    2B8E
2B82:  MOVFF  FE6,FEE
2B86:  DECFSZ 01,F
2B88:  BRA    2B82
2B8A:  DECFSZ 02,F
2B8C:  BRA    2B82
2B8E:  CLRF   19
2B90:  BTFSC  FF2.7
2B92:  BSF    19.7
2B94:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
2B96:  MOVFF  CA,E1
2B9A:  MOVFF  CE,E3
2B9E:  MOVFF  CD,E2
2BA2:  MOVFF  CF,E4
2BA6:  CALL   2134
2BAA:  BTFSC  19.7
2BAC:  BSF    FF2.7
2BAE:  MOVF   01,W
2BB0:  BRA    2BB6
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
2BB2:  MOVLW  00
2BB4:  MOVWF  01
.................... } 
2BB6:  GOTO   2D74 (RETURN)
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
203E:  MOVF   xE1,W
2040:  MULLW  08
2042:  MOVF   FF3,W
2044:  CLRF   xE7
2046:  MOVWF  FE9
2048:  MOVLW  04
204A:  ADDWF  xE7,W
204C:  MOVWF  FEA
204E:  MOVFF  FEF,E3
....................    if (tgl == USB_DTS_TOGGLE)  
2052:  MOVF   xE2,W
2054:  SUBLW  02
2056:  BNZ   2064
....................    { 
....................       if (bit_test(i,6)) 
2058:  BTFSS  xE3.6
205A:  BRA    2060
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
205C:  CLRF   xE2
....................       else 
205E:  BRA    2064
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
2060:  MOVLW  01
2062:  MOVWF  xE2
....................    } 
....................    if (tgl == USB_DTS_STALL)  
2064:  MOVF   xE2,W
2066:  SUBLW  03
2068:  BNZ   2090
....................    { 
....................       i = 0x84; 
206A:  MOVLW  84
206C:  MOVWF  xE3
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
206E:  MOVF   xE1,W
2070:  MULLW  08
2072:  MOVF   FF3,W
2074:  CLRF   xE7
2076:  MOVWF  xE6
2078:  MOVLW  04
207A:  ADDWF  xE6,F
207C:  MOVLW  00
207E:  ADDWFC xE7,F
2080:  MOVFF  E6,FE9
2084:  MOVLW  04
2086:  ADDWF  xE7,W
2088:  MOVWF  FEA
208A:  MOVLW  84
208C:  MOVWF  FEF
....................    } 
....................    else if (tgl == USB_DTS_DATA1) 
208E:  BRA    209E
2090:  DECFSZ xE2,W
2092:  BRA    209A
....................       i = 0xC8;  //DATA1, UOWN 
2094:  MOVLW  C8
2096:  MOVWF  xE3
....................    else //if (tgl == USB_DTS_DATA0)  
2098:  BRA    209E
....................       i = 0x88; //DATA0, UOWN 
209A:  MOVLW  88
209C:  MOVWF  xE3
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
209E:  BCF    FD8.0
20A0:  RLCF   xE1,W
20A2:  CLRF   03
20A4:  RCALL  190A
20A6:  TBLRD*+
20A8:  MOVFF  FF5,03
20AC:  MOVWF  xE4
20AE:  MOVFF  03,E5
....................    EP_BDxCNT_O(endpoint) = len; 
20B2:  MOVF   xE1,W
20B4:  MULLW  08
20B6:  MOVF   FF3,W
20B8:  CLRF   xE7
20BA:  MOVWF  xE6
20BC:  MOVLW  01
20BE:  ADDWF  xE6,W
20C0:  MOVWF  01
20C2:  MOVLW  00
20C4:  ADDWFC xE7,W
20C6:  MOVWF  03
20C8:  MOVFF  01,FE9
20CC:  MOVLW  04
20CE:  ADDWF  03,W
20D0:  MOVWF  FEA
20D2:  MOVFF  E4,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
20D6:  BTFSC  xE5.0
20D8:  BSF    xE3.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
20DA:  BTFSC  xE5.1
20DC:  BSF    xE3.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
20DE:  MOVF   xE1,W
20E0:  MULLW  08
20E2:  MOVF   FF3,W
20E4:  CLRF   xE7
20E6:  MOVWF  FE9
20E8:  MOVLW  04
20EA:  ADDWF  xE7,W
20EC:  MOVWF  FEA
20EE:  MOVFF  E3,FEF
.................... } 
20F2:  RETURN 0
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
*
29DC:  MOVF   xCF,W
29DE:  MULLW  08
29E0:  MOVF   FF3,W
29E2:  CLRF   xDA
29E4:  MOVWF  xD9
29E6:  MOVLW  02
29E8:  ADDWF  xD9,W
29EA:  MOVWF  01
29EC:  MOVLW  00
29EE:  ADDWFC xDA,W
29F0:  MOVWF  03
29F2:  MOVFF  01,FE9
29F6:  MOVLW  04
29F8:  ADDWF  03,W
29FA:  MOVWF  FEA
29FC:  MOVFF  FEC,D5
2A00:  MOVF   FED,F
2A02:  MOVFF  FEF,D4
....................    i = EP_BDxCNT_O(endpoint); 
2A06:  MOVF   xCF,W
2A08:  MULLW  08
2A0A:  MOVF   FF3,W
2A0C:  CLRF   xDA
2A0E:  MOVWF  xD9
2A10:  MOVLW  01
2A12:  ADDWF  xD9,W
2A14:  MOVWF  01
2A16:  MOVLW  00
2A18:  ADDWFC xDA,W
2A1A:  MOVWF  03
2A1C:  MOVFF  01,FE9
2A20:  MOVLW  04
2A22:  ADDWF  03,W
2A24:  MOVWF  FEA
2A26:  CLRF   xD8
2A28:  MOVFF  FEF,D7
....................    st = EP_BDxST_O(endpoint); 
2A2C:  MOVF   xCF,W
2A2E:  MULLW  08
2A30:  MOVF   FF3,W
2A32:  CLRF   xDA
2A34:  MOVWF  FE9
2A36:  MOVLW  04
2A38:  ADDWF  xDA,W
2A3A:  MOVWF  FEA
2A3C:  MOVFF  FEF,D6
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
2A40:  BTFSC  xD6.0
2A42:  BSF    xD8.0
....................    if (bit_test(st,1)) {bit_set(i,9);} 
2A44:  BTFSC  xD6.1
2A46:  BSF    xD8.1
....................  
....................    if (i < max) {max = i;} 
2A48:  MOVF   xD8,W
2A4A:  SUBWF  xD3,W
2A4C:  BNC   2A5E
2A4E:  BNZ   2A56
2A50:  MOVF   xD2,W
2A52:  SUBWF  xD7,W
2A54:  BC    2A5E
2A56:  MOVFF  D8,D3
2A5A:  MOVFF  D7,D2
....................     
....................    memcpy(ptr, al ,max); 
2A5E:  MOVFF  D1,FEA
2A62:  MOVFF  D0,FE9
2A66:  MOVFF  D5,FE2
2A6A:  MOVFF  D4,FE1
2A6E:  MOVFF  D3,02
2A72:  MOVFF  D2,01
2A76:  MOVF   01,F
2A78:  BZ    2A7E
2A7A:  INCF   02,F
2A7C:  BRA    2A82
2A7E:  MOVF   02,F
2A80:  BZ    2A8E
2A82:  MOVFF  FE6,FEE
2A86:  DECFSZ 01,F
2A88:  BRA    2A82
2A8A:  DECFSZ 02,F
2A8C:  BRA    2A82
....................  
....................    return(max); 
2A8E:  MOVFF  D2,01
2A92:  MOVFF  D3,02
.................... } 
2A96:  GOTO   2AB0 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
2A9A:  MOVFF  CA,CF
2A9E:  MOVFF  CC,D1
2AA2:  MOVFF  CB,D0
2AA6:  MOVFF  CE,D3
2AAA:  MOVFF  CD,D2
2AAE:  BRA    29DC
2AB0:  MOVFF  02,CE
2AB4:  MOVFF  01,CD
2AB8:  CLRF   19
2ABA:  BTFSC  FF2.7
2ABC:  BSF    19.7
2ABE:  BCF    FF2.7
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
2AC0:  MOVFF  CA,E1
2AC4:  MOVLW  02
2AC6:  MOVWF  xE2
2AC8:  CALL   203E
2ACC:  BTFSC  19.7
2ACE:  BSF    FF2.7
....................  
....................    return(max); 
2AD0:  MOVFF  CD,01
2AD4:  MOVFF  CE,02
.................... } 
2AD8:  GOTO   2C34 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1F1A:  BCF    xE2.0
1F1C:  BTFSC  xE1.7
1F1E:  BSF    xE2.0
....................    endpoint &= 0x7F; 
1F20:  BCF    xE1.7
....................     
....................    if (direction)  
1F22:  BTFSS  xE2.0
1F24:  BRA    1F48
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
1F26:  MOVF   xE1,W
1F28:  MULLW  08
1F2A:  MOVF   FF3,W
1F2C:  CLRF   xE4
1F2E:  MOVWF  xE3
1F30:  MOVLW  04
1F32:  ADDWF  xE3,F
1F34:  MOVLW  00
1F36:  ADDWFC xE4,F
1F38:  MOVFF  E3,FE9
1F3C:  MOVLW  04
1F3E:  ADDWF  xE4,W
1F40:  MOVWF  FEA
1F42:  MOVLW  84
1F44:  MOVWF  FEF
....................    } 
....................    else  
1F46:  BRA    1F5C
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
1F48:  MOVF   xE1,W
1F4A:  MULLW  08
1F4C:  MOVF   FF3,W
1F4E:  CLRF   xE4
1F50:  MOVWF  FE9
1F52:  MOVLW  04
1F54:  ADDWF  xE4,W
1F56:  MOVWF  FEA
1F58:  MOVLW  84
1F5A:  MOVWF  FEF
....................    } 
.................... } 
1F5C:  GOTO   1FE6 (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1ED6:  BCF    xE2.0
1ED8:  BTFSC  xE1.7
1EDA:  BSF    xE2.0
....................    endpoint &= 0x7F; 
1EDC:  BCF    xE1.7
....................     
....................    if (direction)  
1EDE:  BTFSS  xE2.0
1EE0:  BRA    1F04
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
1EE2:  MOVF   xE1,W
1EE4:  MULLW  08
1EE6:  MOVF   FF3,W
1EE8:  CLRF   xE4
1EEA:  MOVWF  xE3
1EEC:  MOVLW  04
1EEE:  ADDWF  xE3,F
1EF0:  MOVLW  00
1EF2:  ADDWFC xE4,F
1EF4:  MOVFF  E3,FE9
1EF8:  MOVLW  04
1EFA:  ADDWF  xE4,W
1EFC:  MOVWF  FEA
1EFE:  MOVLW  88
1F00:  MOVWF  FEF
....................      #endif 
....................    } 
....................    else  
1F02:  BRA    1F16
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
1F04:  MOVF   xE1,W
1F06:  MULLW  08
1F08:  MOVF   FF3,W
1F0A:  CLRF   xE4
1F0C:  MOVWF  FE9
1F0E:  MOVLW  04
1F10:  ADDWF  xE4,W
1F12:  MOVWF  FEA
1F14:  CLRF   FEF
....................    } 
.................... } 
1F16:  GOTO   1FDA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1F60:  BCF    xE2.0
1F62:  BTFSC  xE1.7
1F64:  BSF    xE2.0
....................    endpoint &= 0x7F; 
1F66:  BCF    xE1.7
....................     
....................    if (direction)  
1F68:  BTFSS  xE2.0
1F6A:  BRA    1F8E
....................    { 
....................       st=EP_BDxST_I(endpoint); 
1F6C:  MOVF   xE1,W
1F6E:  MULLW  08
1F70:  MOVF   FF3,W
1F72:  CLRF   xE5
1F74:  MOVWF  xE4
1F76:  MOVLW  04
1F78:  ADDWF  xE4,F
1F7A:  MOVLW  00
1F7C:  ADDWFC xE5,F
1F7E:  MOVFF  E4,FE9
1F82:  MOVLW  04
1F84:  ADDWF  xE5,W
1F86:  MOVWF  FEA
1F88:  MOVFF  FEF,E3
....................    } 
....................    else  
1F8C:  BRA    1FA2
....................    { 
....................       st=EP_BDxST_O(endpoint); 
1F8E:  MOVF   xE1,W
1F90:  MULLW  08
1F92:  MOVF   FF3,W
1F94:  CLRF   xE5
1F96:  MOVWF  FE9
1F98:  MOVLW  04
1F9A:  ADDWF  xE5,W
1F9C:  MOVWF  FEA
1F9E:  MOVFF  FEF,E3
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
1FA2:  BTFSS  xE3.7
1FA4:  BRA    1FAA
1FA6:  BTFSC  xE3.2
1FA8:  BRA    1FAE
1FAA:  MOVLW  00
1FAC:  BRA    1FB0
1FAE:  MOVLW  01
1FB0:  MOVWF  01
.................... } 
1FB2:  GOTO   1FFA (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
220C:  MOVFF  E2,F6E
....................     
....................    if (address)  
2210:  MOVF   xE2,F
2212:  BZ    221A
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
2214:  MOVLW  04
2216:  MOVWF  1F
....................    } 
....................    else  
2218:  BRA    221E
....................    { 
....................       usb_state = USB_STATE_POWERED; 
221A:  MOVLW  02
221C:  MOVWF  1F
....................    } 
.................... } 
221E:  GOTO   222C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
1C34:  MOVF   xE1,F
1C36:  BNZ   1C40
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
1C38:  MOVLW  04
1C3A:  MOVWF  1F
....................       usb_disable_endpoints(); 
1C3C:  RCALL  1ABA
....................    } 
....................    else  
1C3E:  BRA    1DA2
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
1C40:  MOVLW  05
1C42:  MOVWF  1F
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
1C44:  MOVLW  04
1C46:  MOVWF  xE4
1C48:  MOVLW  90
1C4A:  MOVWF  xE3
....................       for (en=1; en<USB_NUM_UEP; en++)  
1C4C:  MOVLW  01
1C4E:  MOVWF  xE2
1C50:  MOVF   xE2,W
1C52:  SUBLW  0F
1C54:  BTFSS  FD8.0
1C56:  BRA    1DA2
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
1C58:  MOVFF  E2,EA
1C5C:  RCALL  1A6E
....................          new_uep = 0; 
1C5E:  CLRF   xE5
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
1C60:  CLRF   03
1C62:  MOVF   xE2,W
1C64:  RCALL  18BA
1C66:  SUBLW  FF
1C68:  BZ    1D04
....................          { 
....................             new_uep = 0x04; 
1C6A:  MOVLW  04
1C6C:  MOVWF  xE5
....................             len = usb_ep_rx_size[en]; 
1C6E:  BCF    FD8.0
1C70:  RLCF   xE2,W
1C72:  CLRF   03
1C74:  RCALL  190A
1C76:  TBLRD*+
1C78:  MOVFF  FF5,03
1C7C:  MOVWF  xE6
1C7E:  MOVFF  03,E7
....................             EP_BDxCNT_O(en) = len; 
1C82:  MOVF   xE2,W
1C84:  MULLW  08
1C86:  MOVF   FF3,W
1C88:  CLRF   xEA
1C8A:  MOVWF  xE9
1C8C:  MOVLW  01
1C8E:  ADDWF  xE9,W
1C90:  MOVWF  01
1C92:  MOVLW  00
1C94:  ADDWFC xEA,W
1C96:  MOVWF  03
1C98:  MOVFF  01,FE9
1C9C:  MOVLW  04
1C9E:  ADDWF  03,W
1CA0:  MOVWF  FEA
1CA2:  MOVFF  E6,FEF
....................             EP_BDxADR_O(en) = addy; 
1CA6:  MOVF   xE2,W
1CA8:  MULLW  08
1CAA:  MOVF   FF3,W
1CAC:  CLRF   xEA
1CAE:  MOVWF  xE9
1CB0:  MOVLW  02
1CB2:  ADDWF  xE9,W
1CB4:  MOVWF  01
1CB6:  MOVLW  00
1CB8:  ADDWFC xEA,W
1CBA:  MOVWF  03
1CBC:  MOVFF  01,FE9
1CC0:  MOVLW  04
1CC2:  ADDWF  03,W
1CC4:  MOVWF  FEA
1CC6:  MOVFF  E4,FEC
1CCA:  MOVF   FED,F
1CCC:  MOVFF  E3,FEF
....................             addy += usb_ep_rx_size[en]; 
1CD0:  BCF    FD8.0
1CD2:  RLCF   xE2,W
1CD4:  CLRF   03
1CD6:  RCALL  190A
1CD8:  TBLRD*+
1CDA:  MOVFF  FF5,03
1CDE:  ADDWF  xE3,F
1CE0:  MOVF   03,W
1CE2:  ADDWFC xE4,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
1CE4:  MOVLW  88
1CE6:  MOVWF  xE8
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
1CE8:  BTFSC  xE7.0
1CEA:  BSF    xE8.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
1CEC:  BTFSC  xE7.1
1CEE:  BSF    xE8.1
....................             EP_BDxST_O(en) = i; 
1CF0:  MOVF   xE2,W
1CF2:  MULLW  08
1CF4:  MOVF   FF3,W
1CF6:  CLRF   xEA
1CF8:  MOVWF  FE9
1CFA:  MOVLW  04
1CFC:  ADDWF  xEA,W
1CFE:  MOVWF  FEA
1D00:  MOVFF  E8,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
1D04:  CLRF   03
1D06:  MOVF   xE2,W
1D08:  RCALL  18BA
1D0A:  SUBLW  FF
1D0C:  BZ    1D76
....................          { 
....................             new_uep |= 0x02; 
1D0E:  BSF    xE5.1
....................             EP_BDxADR_I(en) = addy; 
1D10:  MOVF   xE2,W
1D12:  MULLW  08
1D14:  MOVF   FF3,W
1D16:  CLRF   xEA
1D18:  MOVWF  xE9
1D1A:  MOVLW  04
1D1C:  ADDWF  xE9,F
1D1E:  MOVLW  00
1D20:  ADDWFC xEA,F
1D22:  MOVLW  02
1D24:  ADDWF  xE9,W
1D26:  MOVWF  01
1D28:  MOVLW  00
1D2A:  ADDWFC xEA,W
1D2C:  MOVWF  03
1D2E:  MOVFF  01,FE9
1D32:  MOVLW  04
1D34:  ADDWF  03,W
1D36:  MOVWF  FEA
1D38:  MOVFF  E4,FEC
1D3C:  MOVF   FED,F
1D3E:  MOVFF  E3,FEF
....................             addy += usb_ep_tx_size[en]; 
1D42:  BCF    FD8.0
1D44:  RLCF   xE2,W
1D46:  CLRF   03
1D48:  RCALL  18DA
1D4A:  TBLRD*+
1D4C:  MOVFF  FF5,03
1D50:  ADDWF  xE3,F
1D52:  MOVF   03,W
1D54:  ADDWFC xE4,F
....................             EP_BDxST_I(en) = 0x40; 
1D56:  MOVF   xE2,W
1D58:  MULLW  08
1D5A:  MOVF   FF3,W
1D5C:  CLRF   xEA
1D5E:  MOVWF  xE9
1D60:  MOVLW  04
1D62:  ADDWF  xE9,F
1D64:  MOVLW  00
1D66:  ADDWFC xEA,F
1D68:  MOVFF  E9,FE9
1D6C:  MOVLW  04
1D6E:  ADDWF  xEA,W
1D70:  MOVWF  FEA
1D72:  MOVLW  40
1D74:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
1D76:  MOVF   xE5,W
1D78:  SUBLW  06
1D7A:  BNZ   1D80
1D7C:  MOVLW  0E
1D7E:  MOVWF  xE5
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
1D80:  CLRF   03
1D82:  MOVF   xE2,W
1D84:  RCALL  18BA
1D86:  SUBLW  01
1D88:  BTFSS  FD8.2
1D8A:  BSF    xE5.4
....................           
....................          UEP(en) = new_uep; 
1D8C:  CLRF   03
1D8E:  MOVF   xE2,W
1D90:  ADDLW  70
1D92:  MOVWF  FE9
1D94:  MOVLW  0F
1D96:  ADDWFC 03,W
1D98:  MOVWF  FEA
1D9A:  MOVFF  E5,FEF
....................       } 
1D9E:  INCF   xE2,F
1DA0:  BRA    1C50
....................    } 
.................... } 
1DA2:  GOTO   1E3C (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
1A6E:  CLRF   03
1A70:  MOVF   xEA,W
1A72:  ADDLW  70
1A74:  MOVWF  FE9
1A76:  MOVLW  0F
1A78:  ADDWFC 03,W
1A7A:  MOVWF  FEA
1A7C:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
1A7E:  MOVFF  EA,EB
1A82:  RCALL  1A2C
1A84:  MOVF   01,F
1A86:  BZ    1AB8
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
1A88:  MOVF   xEA,W
1A8A:  MULLW  08
1A8C:  MOVF   FF3,W
1A8E:  CLRF   xEC
1A90:  MOVWF  FE9
1A92:  MOVLW  04
1A94:  ADDWF  xEC,W
1A96:  MOVWF  FEA
1A98:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
1A9A:  MOVF   xEA,W
1A9C:  MULLW  08
1A9E:  MOVF   FF3,W
1AA0:  CLRF   xEC
1AA2:  MOVWF  xEB
1AA4:  MOVLW  04
1AA6:  ADDWF  xEB,F
1AA8:  MOVLW  00
1AAA:  ADDWFC xEC,F
1AAC:  MOVFF  EB,FE9
1AB0:  MOVLW  04
1AB2:  ADDWF  xEC,W
1AB4:  MOVWF  FEA
1AB6:  CLRF   FEF
....................    } 
.................... } 
1AB8:  RETURN 0
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
1ABA:  MOVLW  01
1ABC:  MOVWF  xE9
1ABE:  MOVF   xE9,W
1AC0:  SUBLW  0F
1AC2:  BNC   1ACE
....................       usb_disable_endpoint(i); 
1AC4:  MOVFF  E9,EA
1AC8:  RCALL  1A6E
1ACA:  INCF   xE9,F
1ACC:  BRA    1ABE
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
1ACE:  RETURN 0
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
1AF8:  BCF    F68.3
.................... } 
1AFA:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
2310:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
2312:  MOVF   1F,F
2314:  BNZ   2318
2316:  BRA    238A
....................    if (UIR)  
2318:  MOVF   F68,F
231A:  BZ    238A
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
231C:  BTFSS  F68.2
231E:  BRA    2328
2320:  BTFSS  F69.2
2322:  BRA    2328
2324:  GOTO   19E6
....................  
....................       if (UCON_SUSPND) return; 
2328:  BTFSS  F6D.1
232A:  BRA    232E
232C:  BRA    238A
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
232E:  BTFSS  F68.5
2330:  BRA    233A
2332:  BTFSS  F69.5
2334:  BRA    233A
2336:  GOTO   1A16
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
233A:  BTFSS  F68.1
233C:  BRA    2346
233E:  BTFSS  F69.1
2340:  BRA    2346
2342:  GOTO   1A24
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
2346:  BTFSS  F68.0
2348:  BRA    2352
234A:  BTFSS  F69.0
234C:  BRA    2352
234E:  GOTO   1AFC
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
2352:  BTFSS  F68.4
2354:  BRA    235E
2356:  BTFSS  F69.4
2358:  BRA    235E
235A:  GOTO   1B26
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
235E:  BTFSS  F68.6
2360:  BRA    236A
2362:  BTFSS  F69.6
2364:  BRA    236A
2366:  GOTO   1B30
....................  
....................       TRNAttempts = 0; 
236A:  CLRF   xDE
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
236C:  BTFSS  F68.3
236E:  BRA    2380
2370:  BTFSS  F69.3
2372:  BRA    2380
....................          { 
....................             USTATCopy = U1STAT; 
2374:  MOVFF  F6C,1E
....................             usb_clear_trn(); 
2378:  CALL   1AF8
....................             usb_isr_tok_dne(); 
237C:  BRA    2246
....................          } 
....................          else 
237E:  BRA    2382
....................             break; 
2380:  BRA    238A
....................       } while (TRNAttempts++ < 4); 
2382:  MOVF   xDE,W
2384:  INCF   xDE,F
2386:  SUBLW  03
2388:  BC    236C
....................    } 
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
238A:  GOTO   186C
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
1B30:  BCF    F68.6
.................... } 
1B32:  GOTO   236A (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
1AFC:  CLRF   F6A
....................    UIR = 0; 
1AFE:  CLRF   F68
....................    UEIE = 0x9F; 
1B00:  MOVLW  9F
1B02:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
1B04:  MOVLW  3D
1B06:  MOVWF  F69
....................  
....................    UADDR = 0; 
1B08:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
1B0A:  RCALL  1ABA
....................     
....................    usb_token_reset(); 
1B0C:  RCALL  1AD0
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
1B0E:  MOVLW  16
1B10:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
....................    { 
1B12:  BTFSS  F68.3
1B14:  BRA    1B1A
....................       usb_clear_trn(); 
1B16:  RCALL  1AF8
....................    } 
1B18:  BRA    1B12
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
1B1A:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
1B1C:  RCALL  19F6
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
1B1E:  MOVLW  03
1B20:  MOVWF  1F
.................... } 
1B22:  GOTO   2352 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
19F6:  MOVLW  40
19F8:  MOVLB  4
19FA:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
19FC:  MOVLW  04
19FE:  MOVWF  x03
1A00:  MOVLW  10
1A02:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
1A04:  MOVLW  88
1A06:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
1A08:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
1A0A:  MOVLW  04
1A0C:  MOVWF  x07
1A0E:  MOVLW  50
1A10:  MOVWF  x06
.................... } 
1A12:  MOVLB  0
1A14:  RETURN 0
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
1A24:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
1A26:  BCF    F68.1
.................... } 
1A28:  GOTO   2346 (RETURN)
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
1B26:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
1B28:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
1B2A:  BSF    F6D.1
.................... } 
1B2C:  GOTO   235E (RETURN)
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
19E6:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
19E8:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
....................    { 
19EA:  BTFSS  F68.2
19EC:  BRA    19F2
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
19EE:  BCF    F68.2
....................    } 
19F0:  BRA    19EA
.................... } 
19F2:  GOTO   2328 (RETURN)
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
1A16:  BTFSS  F70.0
1A18:  BRA    1A1E
....................    { 
....................       usb_init_ep0_setup(); 
1A1A:  RCALL  19F6
....................       bit_clear(UEP(0), 0); 
1A1C:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
1A1E:  BCF    F68.5
.................... } 
1A20:  GOTO   233A (RETURN)
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
1B36:  MOVFF  E4,20
1B3A:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
1B3C:  SETF   20
1B3E:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
2246:  RRCF   1E,W
2248:  MOVWF  xDF
224A:  RRCF   xDF,F
224C:  RRCF   xDF,F
224E:  MOVLW  1F
2250:  ANDWF  xDF,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
2252:  MOVF   1E,F
2254:  BNZ   22D8
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
2256:  MOVLB  4
2258:  MOVF   x00,W
225A:  ANDLW  3C
225C:  MOVLB  0
225E:  MOVWF  xE0
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
2260:  MOVLW  43
2262:  MOVLB  4
2264:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
2266:  MOVLB  0
2268:  MOVF   xE0,W
226A:  SUBLW  34
226C:  BNZ   22AA
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
226E:  MOVLB  4
2270:  MOVF   x04,W
2272:  ANDLW  80
2274:  BZ    2278
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
2276:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
2278:  MOVLB  0
227A:  BRA    2014
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
227C:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
227E:  INCFSZ 20,W
2280:  BRA    228C
....................             usb_flush_out(0, USB_DTS_STALL); 
2282:  CLRF   xE1
2284:  MOVLW  03
2286:  MOVWF  xE2
2288:  RCALL  203E
....................          else  
228A:  BRA    22A8
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
228C:  CLRF   xE1
228E:  MOVLW  02
2290:  MOVWF  xE2
2292:  RCALL  203E
....................             if (__setup_0_tx_size != 0xFE) 
2294:  MOVF   20,W
2296:  SUBLW  FE
2298:  BZ    22A8
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
229A:  CLRF   xE1
229C:  CLRF   xE3
229E:  MOVFF  20,E2
22A2:  MOVLW  04
22A4:  MOVWF  xE4
22A6:  RCALL  2134
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
....................       else if (pidKey == USB_PIC_PID_OUT)  
22A8:  BRA    22D6
22AA:  MOVF   xE0,W
22AC:  SUBLW  04
22AE:  BNZ   22D6
....................       { 
....................          usb_isr_tok_out_dne(0); 
22B0:  CLRF   xE1
22B2:  RCALL  2206
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
22B4:  CLRF   xE1
22B6:  MOVLW  02
22B8:  MOVWF  xE2
22BA:  RCALL  203E
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
22BC:  MOVF   20,W
22BE:  SUBLW  FE
22C0:  BZ    22D6
22C2:  INCFSZ 20,W
22C4:  BRA    22C8
22C6:  BRA    22D6
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
22C8:  CLRF   xE1
22CA:  CLRF   xE3
22CC:  MOVFF  20,E2
22D0:  MOVLW  01
22D2:  MOVWF  xE4
22D4:  RCALL  2134
....................          } 
....................       } 
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
....................    else if (USTATCopy == USTAT_IN_E0)  
22D6:  BRA    230C
22D8:  MOVF   1E,W
22DA:  SUBLW  04
22DC:  BNZ   22FA
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
22DE:  SETF   20
....................       usb_isr_tok_in_dne(0); 
22E0:  CLRF   xE1
22E2:  RCALL  2230
....................       if (__setup_0_tx_size!=0xFF) 
22E4:  INCFSZ 20,W
22E6:  BRA    22EA
22E8:  BRA    22F8
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
22EA:  CLRF   xE1
22EC:  CLRF   xE3
22EE:  MOVFF  20,E2
22F2:  MOVLW  02
22F4:  MOVWF  xE4
22F6:  RCALL  2134
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
....................    else  
22F8:  BRA    230C
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
22FA:  BTFSC  1E.2
22FC:  BRA    2306
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
22FE:  MOVFF  DF,E1
2302:  RCALL  2206
....................       } 
....................       else  
2304:  BRA    230C
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
2306:  MOVFF  DF,E1
230A:  RCALL  2230
....................       } 
....................    } 
.................... } 
230C:  GOTO   237E (RETURN)
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
299C:  MOVF   1B,W
299E:  MOVWF  01
.................... } 
29A0:  GOTO   2C10 (RETURN)
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
*
26E8:  MOVF   1B,F
26EA:  BNZ   26F0
26EC:  CLRWDT
26EE:  BRA    26E8
.................... } 
26F0:  GOTO   288A (RETURN)
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
1AD0:  CLRF   25
1AD2:  CLRF   24
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
1AD4:  CLRF   xDF
1AD6:  MOVF   xDF,F
1AD8:  BNZ   1AEE
....................       USB_Interface[i] = 0;   //reset each interface to default 
1ADA:  CLRF   03
1ADC:  MOVF   xDF,W
1ADE:  ADDLW  26
1AE0:  MOVWF  FE9
1AE2:  MOVLW  00
1AE4:  ADDWFC 03,W
1AE6:  MOVWF  FEA
1AE8:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
1AEA:  INCF   xDF,F
1AEC:  BRA    1AD6
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
1AEE:  CLRF   1B
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
1AF0:  MOVLW  01
1AF2:  MOVWF  1C
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
1AF4:  CLRF   1A
.................... } 
1AF6:  RETURN 0
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
1A2C:  BCF    xEC.0
1A2E:  BTFSC  xEB.7
1A30:  BSF    xEC.0
....................     
....................    endpoint &= 0x7F; 
1A32:  BCF    xEB.7
....................     
....................    if (endpoint > 16) 
1A34:  MOVF   xEB,W
1A36:  SUBLW  10
1A38:  BC    1A40
....................       return(FALSE); 
1A3A:  MOVLW  00
1A3C:  MOVWF  01
1A3E:  BRA    1A6C
....................     
....................    if (direction) { //IN 
1A40:  BTFSS  xEC.0
1A42:  BRA    1A5A
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
1A44:  CLRF   03
1A46:  MOVF   xEB,W
1A48:  RCALL  18BA
1A4A:  SUBLW  FF
1A4C:  BNZ   1A52
1A4E:  MOVLW  00
1A50:  BRA    1A54
1A52:  MOVLW  01
1A54:  MOVWF  01
1A56:  BRA    1A6C
....................    } 
....................    else {   //OUT 
1A58:  BRA    1A6C
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
1A5A:  CLRF   03
1A5C:  MOVF   xEB,W
1A5E:  RCALL  18BA
1A60:  SUBLW  FF
1A62:  BNZ   1A68
1A64:  MOVLW  00
1A66:  BRA    1A6A
1A68:  MOVLW  01
1A6A:  MOVWF  01
....................    } 
.................... } 
1A6C:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
2230:  MOVF   xE1,F
2232:  BNZ   2244
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
2234:  DECFSZ 1A,W
2236:  BRA    223C
2238:  RCALL  1B40
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
223A:  BRA    2244
223C:  MOVF   1A,W
223E:  SUBLW  02
2240:  BNZ   2244
2242:  BRA    2222
....................    } 
....................   #if USB_CDC_DEVICE 
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
2244:  RETURN 0
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
2206:  MOVF   xE1,F
2208:  BNZ   220A
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
220A:  RETURN 0
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
2014:  CLRF   1A
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
2016:  MOVLB  4
2018:  MOVF   x10,W
201A:  ANDLW  7F
201C:  XORLW  00
201E:  MOVLB  0
2020:  BZ    202C
2022:  XORLW  01
2024:  BZ    2030
2026:  XORLW  03
2028:  BZ    2034
202A:  BRA    2038
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
202C:  BRA    1DA6
....................          break; 
202E:  BRA    203A
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
2030:  BRA    1E4A
....................          break; 
2032:  BRA    203A
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
2034:  BRA    1FB6
....................          break; 
2036:  BRA    203A
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
....................         #else 
....................          usb_isr_tkn_cdc(); 
....................         #endif 
....................          break; 
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
2038:  RCALL  1B3C
....................          break; 
....................    } 
.................... } 
203A:  GOTO   227C (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
1DA6:  MOVLB  4
1DA8:  MOVF   x11,W
1DAA:  XORLW  00
1DAC:  MOVLB  0
1DAE:  BZ    1DCA
1DB0:  XORLW  01
1DB2:  BZ    1DDC
1DB4:  XORLW  02
1DB6:  BZ    1DF4
1DB8:  XORLW  06
1DBA:  BZ    1E0A
1DBC:  XORLW  03
1DBE:  BZ    1E18
1DC0:  XORLW  0E
1DC2:  BZ    1E1C
1DC4:  XORLW  01
1DC6:  BZ    1E28
1DC8:  BRA    1E44
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
1DCA:  MOVFF  1C,450
....................             usb_ep0_tx_buffer[1]=0; 
1DCE:  MOVLB  4
1DD0:  CLRF   x51
....................             usb_request_send_response(2); 
1DD2:  MOVLW  02
1DD4:  MOVLB  0
1DD6:  MOVWF  xE4
1DD8:  RCALL  1B36
....................             break; 
1DDA:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1DDC:  MOVLB  4
1DDE:  DECFSZ x12,W
1DE0:  BRA    1DEE
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
1DE2:  MOVLW  01
1DE4:  ANDWF  1C,F
....................                usb_put_0len_0(); 
1DE6:  MOVLB  0
1DE8:  CLRF   xE4
1DEA:  RCALL  1B36
....................             } 
....................             else 
1DEC:  BRA    1DF2
....................                usb_request_stall(); 
1DEE:  MOVLB  0
1DF0:  RCALL  1B3C
....................             break; 
1DF2:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
1DF4:  MOVLB  4
1DF6:  DECFSZ x12,W
1DF8:  BRA    1E04
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
1DFA:  BSF    1C.1
....................                usb_put_0len_0(); 
1DFC:  MOVLB  0
1DFE:  CLRF   xE4
1E00:  RCALL  1B36
....................             } 
....................             else 
1E02:  BRA    1E08
....................                usb_request_stall(); 
1E04:  MOVLB  0
1E06:  RCALL  1B3C
....................             break; 
1E08:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
1E0A:  MOVLW  02
1E0C:  MOVWF  1A
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
1E0E:  MOVFF  412,21
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
1E12:  CLRF   xE4
1E14:  RCALL  1B36
....................             break; 
1E16:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
1E18:  BRA    1BB8
....................             break; 
1E1A:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
1E1C:  MOVFF  1B,450
....................             usb_request_send_response(1); 
1E20:  MOVLW  01
1E22:  MOVWF  xE4
1E24:  RCALL  1B36
....................             break; 
1E26:  BRA    1E46
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
1E28:  MOVLB  4
1E2A:  MOVF   x12,W
1E2C:  SUBLW  01
1E2E:  BNC   1E40
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
1E30:  MOVFF  412,1B
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
1E34:  MOVFF  412,E1
1E38:  MOVLB  0
1E3A:  BRA    1C34
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
1E3C:  CLRF   xE4
1E3E:  RCALL  1B36
....................             } 
....................             break; 
1E40:  MOVLB  0
1E42:  BRA    1E46
....................  
....................       default: 
....................             usb_request_stall(); 
1E44:  RCALL  1B3C
....................             break; 
....................    } 
.................... } 
1E46:  GOTO   203A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
1E4A:  MOVFF  1B,E1
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
1E4E:  MOVLB  4
1E50:  MOVF   x11,W
1E52:  XORLW  00
1E54:  MOVLB  0
1E56:  BZ    1E62
1E58:  XORLW  0A
1E5A:  BZ    1E72
1E5C:  XORLW  01
1E5E:  BZ    1EAC
1E60:  BRA    1ED0
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
1E62:  MOVLB  4
1E64:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0; 
1E66:  CLRF   x51
....................             usb_request_send_response(2); 
1E68:  MOVLW  02
1E6A:  MOVLB  0
1E6C:  MOVWF  xE4
1E6E:  RCALL  1B36
....................             break; 
1E70:  BRA    1ED2
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
1E72:  MOVF   xE1,F
1E74:  BZ    1EA8
1E76:  MOVLW  01
1E78:  SUBWF  xE1,W
1E7A:  CLRF   03
1E7C:  RCALL  196A
1E7E:  MOVWF  01
1E80:  MOVLB  4
1E82:  SUBWF  x14,W
1E84:  BTFSS  FD8.0
1E86:  BRA    1E8C
1E88:  MOVLB  0
1E8A:  BRA    1EA8
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
1E8C:  CLRF   03
1E8E:  MOVF   x14,W
1E90:  ADDLW  26
1E92:  MOVWF  FE9
1E94:  MOVLW  00
1E96:  ADDWFC 03,W
1E98:  MOVWF  FEA
1E9A:  MOVFF  FEF,450
....................                usb_request_send_response(1);; //send byte back 
1E9E:  MOVLW  01
1EA0:  MOVLB  0
1EA2:  MOVWF  xE4
1EA4:  RCALL  1B36
....................             } 
....................             else 
1EA6:  BRA    1EAA
....................                usb_request_stall(); 
1EA8:  RCALL  1B3C
....................             break; 
1EAA:  BRA    1ED2
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
1EAC:  MOVF   xE1,F
1EAE:  BZ    1ECC
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
1EB0:  CLRF   03
1EB2:  MOVLB  4
1EB4:  MOVF   x14,W
1EB6:  ADDLW  26
1EB8:  MOVWF  FE9
1EBA:  MOVLW  00
1EBC:  ADDWFC 03,W
1EBE:  MOVWF  FEA
1EC0:  MOVFF  412,FEF
....................                usb_put_0len_0(); 
1EC4:  MOVLB  0
1EC6:  CLRF   xE4
1EC8:  RCALL  1B36
....................             } 
....................             else 
1ECA:  BRA    1ECE
....................                usb_request_stall(); 
1ECC:  RCALL  1B3C
....................             break; 
1ECE:  BRA    1ED2
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
....................             break; 
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
1ED0:  RCALL  1B3C
....................             break; 
....................    } 
.................... } 
1ED2:  GOTO   203A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
1FB6:  MOVFF  414,EB
1FBA:  RCALL  1A2C
1FBC:  MOVF   01,F
1FBE:  BZ    2010
....................       switch(usb_ep0_rx_buffer[1]) { 
1FC0:  MOVLB  4
1FC2:  MOVF   x11,W
1FC4:  XORLW  01
1FC6:  MOVLB  0
1FC8:  BZ    1FD4
1FCA:  XORLW  02
1FCC:  BZ    1FE0
1FCE:  XORLW  03
1FD0:  BZ    1FEC
1FD2:  BRA    200E
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
1FD4:  MOVFF  414,E1
1FD8:  BRA    1ED6
....................                usb_put_0len_0(); 
1FDA:  CLRF   xE4
1FDC:  RCALL  1B36
....................                break; 
1FDE:  BRA    2010
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
1FE0:  MOVFF  414,E1
1FE4:  BRA    1F1A
....................                      usb_put_0len_0(); 
1FE6:  CLRF   xE4
1FE8:  RCALL  1B36
....................                      break; 
1FEA:  BRA    2010
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
1FEC:  MOVLB  4
1FEE:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0; 
1FF0:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
1FF2:  MOVFF  414,E1
1FF6:  MOVLB  0
1FF8:  BRA    1F60
1FFA:  MOVF   01,F
1FFC:  BZ    2006
....................                   usb_ep0_tx_buffer[0]=1; 
1FFE:  MOVLW  01
2000:  MOVLB  4
2002:  MOVWF  x50
2004:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
2006:  MOVLW  02
2008:  MOVWF  xE4
200A:  RCALL  1B36
....................                break; 
200C:  BRA    2010
....................  
....................          default: 
....................             usb_request_stall(); 
200E:  RCALL  1B3C
....................             break; 
....................       } 
....................    } 
.................... } 
2010:  GOTO   203A (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
....................             break; 
....................    } 
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
1BB8:  CLRF   23
1BBA:  CLRF   22
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
1BBC:  CLRF   1D
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
1BBE:  MOVLB  4
1BC0:  MOVF   x13,W
1BC2:  XORLW  01
1BC4:  MOVLB  0
1BC6:  BZ    1BD2
1BC8:  XORLW  03
1BCA:  BZ    1BDE
1BCC:  XORLW  01
1BCE:  BZ    1BE6
1BD0:  BRA    1C0E
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
1BD2:  CLRF   25
1BD4:  MOVLW  12
1BD6:  MOVWF  24
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
1BD8:  MOVLW  03
1BDA:  MOVWF  1D
....................             break; 
1BDC:  BRA    1C12
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
1BDE:  CLRF   25
1BE0:  MOVLW  20
1BE2:  MOVWF  24
....................             break; 
1BE4:  BRA    1C12
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
1BE6:  MOVLW  02
1BE8:  MOVWF  1D
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
1BEA:  CLRF   03
1BEC:  MOVLB  4
1BEE:  MOVF   x12,W
1BF0:  MOVLB  0
1BF2:  RCALL  199E
1BF4:  CLRF   03
1BF6:  MOVWF  22
1BF8:  MOVFF  03,23
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
1BFC:  MOVFF  23,03
1C00:  MOVF   22,W
1C02:  RCALL  19B2
1C04:  CLRF   03
1C06:  MOVWF  24
1C08:  MOVFF  03,25
....................             break; 
1C0C:  BRA    1C12
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
....................             if (usb_getdesc_ptr!=0xFF) { 
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
....................             if (usb_getdesc_ptr !=0xFF) { 
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
....................                break; 
....................             } 
....................             else { 
....................                usb_request_stall(); 
....................                return; 
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
1C0E:  RCALL  1B3C
....................             return; 
1C10:  BRA    1C30
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
1C12:  MOVLB  4
1C14:  MOVF   x17,F
1C16:  BNZ   1C28
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
1C18:  MOVF   25,F
1C1A:  BNZ   1C22
1C1C:  MOVF   24,W
1C1E:  SUBWF  x16,W
1C20:  BC    1C28
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
1C22:  CLRF   25
1C24:  MOVFF  416,24
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
1C28:  MOVLW  01
1C2A:  MOVWF  1A
....................    usb_copy_desc_seg_to_ep(); 
1C2C:  MOVLB  0
1C2E:  RCALL  1B40
.................... } 
1C30:  GOTO   1E46 (RETURN)
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
2222:  CLRF   1B
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
2224:  CLRF   1A
....................    usb_set_address(USB_address_pending); 
2226:  MOVFF  21,E2
222A:  BRA    220C
....................    #endif 
.................... } 
222C:  GOTO   2244 (RETURN)
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
1B40:  CLRF   xE2
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
....................    { 
1B42:  MOVF   24,W
1B44:  IORWF  25,W
1B46:  BZ    1BA2
1B48:  MOVF   xE2,W
1B4A:  SUBLW  3F
1B4C:  BNC   1BA2
....................       switch(USB_stack_status.getdesc_type) { 
1B4E:  MOVF   1D,W
1B50:  BZ    1B5C
1B52:  XORLW  02
1B54:  BZ    1B68
1B56:  XORLW  01
1B58:  BZ    1B74
1B5A:  BRA    1B7E
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
1B5C:  MOVFF  23,03
1B60:  MOVF   22,W
1B62:  RCALL  193A
1B64:  MOVWF  xE3
....................             break; 
1B66:  BRA    1B7E
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
....................             break; 
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
1B68:  MOVFF  23,03
1B6C:  MOVF   22,W
1B6E:  RCALL  19B2
1B70:  MOVWF  xE3
....................             break; 
1B72:  BRA    1B7E
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
1B74:  MOVFF  23,03
1B78:  MOVF   22,W
1B7A:  RCALL  197C
1B7C:  MOVWF  xE3
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
....................       } 
....................       usb_getdesc_ptr++; 
1B7E:  INCF   22,F
1B80:  BTFSC  FD8.2
1B82:  INCF   23,F
....................       usb_getdesc_len--; 
1B84:  MOVF   24,W
1B86:  BTFSC  FD8.2
1B88:  DECF   25,F
1B8A:  DECF   24,F
....................       usb_ep0_tx_buffer[i++]=c; 
1B8C:  MOVF   xE2,W
1B8E:  INCF   xE2,F
1B90:  CLRF   03
1B92:  ADDLW  50
1B94:  MOVWF  FE9
1B96:  MOVLW  04
1B98:  ADDWFC 03,W
1B9A:  MOVWF  FEA
1B9C:  MOVFF  E3,FEF
....................    } 
1BA0:  BRA    1B42
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
1BA2:  MOVF   24,W
1BA4:  IORWF  25,W
1BA6:  BNZ   1BB0
1BA8:  MOVF   xE2,W
1BAA:  SUBLW  40
1BAC:  BZ    1BB0
....................          USB_stack_status.dev_req = NONE; 
1BAE:  CLRF   1A
....................    } 
....................  
....................    usb_request_send_response(i); 
1BB0:  MOVFF  E2,E4
1BB4:  RCALL  1B36
.................... } 
1BB6:  RETURN 0
....................  
.................... #ENDIF 
....................  
....................  
.................... #include <osa.h>  //OSA RTOS 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa.h 
....................  * 
....................  *  Compilers:      HT-PICC STD 
....................  *                  HT-PICC PRO 
....................  *                  HT-PICC18 STD 
....................  *                  Mplab C18 
....................  *                  Mplab C30 
....................  *                  MikroC PRO 
....................  *                  CCS 
....................  *                  WinAVR 
....................  *                  IAR 
....................  *                  Cosmic 
....................  *                  Raisonance 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    This file contains all prototypes of functions and variables, 
....................  *                  data types definitions, system constants. 
....................  *                  This file must be included in all modules that use OSA services. 
....................  * 
....................  *  History:        10.00.2010 -    Removed all modification marks 
....................  *  History:        10.07.2010 -    Added ports for STM8: IAR and Raisonance 
....................  *  
....................  *                  25.10.2010  -   Bug fixed: OS_Qtimer_Break did not deleted timer from the list 
....................  *                              -   Bug fixed: interrupt became disables after calling OS_Qtimer_Run for timer already 
....................  *                                  presented in queue 
....................  *                              -   (osa_qtimer.c) 
....................  *                              -   (osa_pic16_htpicc.c) 
....................  *                              -   Definition of OS_Ttimer_Delay fixed (osa_ttimer.h) 
....................  *  
....................  *                  30.10.2010  -   Another bug in qtimers fixed (osa_qtimer.c, osa_pic16_htpicc.c) 
....................  *  
....................  *                  22.11.2010  -   IAR for AVR port bugs fixed (osa_avr_iar.h) 
....................  *  
....................  *                  08.12.2010  -   osa_pic18_htpicc.h 
....................  *  
....................  *                  26.12.2010  -   Bug fixed for PIC18: _OS_RETURN_NO_SAVE 
....................  *  
....................  *                  06.03.2011  -   osa_avr_winavr.c 
....................  *                                  osa_avr_winavr.h 
....................  *                                  osa_pic18_mikroc.c  
....................  * 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... #ifndef __OSA__ 
.................... #define __OSA__ 
....................  
....................  
....................  
.................... #define __OSA_VERSION__         110306          /* 6 mar, 2011    */ 
....................  
....................  
....................  
....................  
.................... #define __OSAVERSION__          __OSA_VERSION__ /*old*/ 
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Setting compiler constant. This constant used in "osa.c" to make most                       * 
....................  *  efficient code for used compiler.                                                           * 
....................  *                                                                                              * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if   defined(__PICC18__)           /* HT-PICC18        */ 
....................  
....................     #define __OSA_PIC18_HTPICC__ 
....................     #define __OSA_PIC18__ 
....................     #define __OSA_HTPICC__ 
....................  
....................     #define __OSAPICC18__   /*old*/ 
....................     #define __OSAPICC__     /*old*/ 
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__18CXX)              /* Microchip C18    */ 
....................  
....................     #if __EXTENDED18__ == 1 
....................         #define __OSA_PIC18_MPLABC_EXT__      
....................         #define __OSAMCC18EXT__             /*old*/  
....................     #else 
....................         #define __OSA_PIC18_MPLABC__ 
....................         #define __OSAMCC18__                /*old*/ 
....................     #endif 
....................  
....................     #define __OSA_PIC18__ 
....................     #define __OSA_MPLABC__ 
....................  
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__C30__)              /* Microchip C30    */ 
....................  
....................     #define __OSA_PIC24_MPLABC__ 
....................     #define __OSA_DSPIC_MPLABC__ 
....................  
....................     #define __OSA_MPLABC__ 
....................     // See osa_pic24_mplabc.h for processor definition 
....................  
....................     #define __OSAMCC30__    /*old*/ 
....................     #define __OSA30__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__PCH__)              /* CCS for PIC18  */ 
....................  
....................     #define __OSA_PIC18_CCS__ 
....................     #define __OSA_PIC18__ 
....................     #define __OSA_CCS__ 
....................  
....................     #define __OSACCS18__    /*old*/ 
....................     #define __OSACCS__      /*old*/ 
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__PCM__)              /* CCS for PIC16  */ 
....................  
....................     #define __OSA_PIC16_CCS__ 
....................     #define __OSA_PIC16__ 
....................     #define __OSA_CCS__ 
....................  
....................     #define __OSACCS16__    /*old*/ 
....................     #define __OSACCS__      /*old*/ 
....................     #define __OSA16__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(_PIC12)               /* HT-PICC with baserange family  */ 
....................  
....................     #define __OSA_PIC12_HTPICC__ 
....................     #define __OSA_PIC12__ 
....................     #define __OSA_HTPICC__ 
....................  
....................     #define __OSAPICC12__   /*old*/ 
....................     #define __OSAPICC__     /*old*/ 
....................     #define __OSA12__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__MIKROC_PRO_FOR_PIC__) 
....................  
....................     #if   defined(P16)              /* mikroC for PIC16 */ 
....................         #define __OSA_PIC16_MIKROC__ 
....................         #define __OSA_PIC16__ 
....................         #define __OSA_MIKROC__ 
....................  
....................         #define __OSAMIKROC16__         /*old*/ 
....................         #define __OSAMIKROC__           /*old*/ 
....................         #define __OSA16__               /*old*/ 
....................     #elif defined(P18)              /* mikroC for PIC18 */ 
....................         #define __OSA_PIC18_MIKROC__ 
....................         #define __OSA_PIC18__ 
....................         #define __OSA_MIKROC__ 
....................  
....................         #define __OSAMIKROC18__         /*old*/ 
....................         #define __OSAMIKROC__           /*old*/ 
....................         #define __OSA18__               /*old*/ 
....................     #endif 
....................  
....................     #define __OSAPIC__                  /*old*/ 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__AVR__) 
....................  
....................     #define __OSA_AVR_WINAVR__ 
....................     #define __OSA_WINAVR__ 
....................     #define __OSA_AVR__ 
....................  
....................     #define __OSAWINAVR__       /*old*/ 
....................     #define __OSAAVR__          /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__ICCAVR__) 
....................  
....................     #define __OSA_AVR_IAR__ 
....................     #define __OSA_IAR__ 
....................     #define __OSA_AVR__ 
....................  
....................     #define __OSAIARAVR__       /*old*/ 
....................     #define __OSAAVR__          /*old*/ 
....................     #define __OSAICCAVR__       /*old*/ 
....................   
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__CODEVISIONAVR__) 
....................  
....................     #define __OSA_AVR__ 
....................     #define __OSA_AVR_CODEVISION__ 
....................     #define __OSA_CODEVISION__ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__ICCSTM8__) 
....................  
....................     #define __OSA_STM8_IAR__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_IAR__ 
....................  
....................     #define __OSAIARSTM8__      /*old*/ 
....................     #define __OSASTM8__         /*old*/ 
....................     #define __OSAICCSTM8__      /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__CSMC__) 
....................  
....................     #define __OSA_STM8_COSMIC__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_COSMIC__ 
....................  
....................     #define __OSACOSMICSTM8__   /*old*/ 
....................     #define __OSASTM8__         /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__RCST7__)            /* Raisonance*/ 
....................  
....................     #define __OSA_STM8_RAISONANCE__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_RAISONANCE__ 
....................     #define __OSA_RCST7__ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else                               /* HT-PICC with midrange family */ 
....................  
....................     #if _HTC_VER_MAJOR_ >= 9 && _HTC_VER_MINOR_ > 60 
....................         #ifdef _PIC14E 
....................             #define __OSA_PIC16E_HTPICC_PRO__ 
....................             #define __OSA_PIC16E__ 
....................             #define __OSA_HTPICC_PRO__ 
....................  
....................             #define __OSAPICC16E__              /*old*/ 
....................             #define __OSA16E__                  /*old*/ 
....................         #else 
....................             #define __OSA_PIC16_HTPICC__ 
....................             #define __OSA_PIC16__ 
....................             #define __OSA_HTPICC__ 
....................  
....................             #define __OSAPICC16__               /*old*/ 
....................             #define __OSA16__                   /*old*/ 
....................         #endif 
....................         #define __OSAPICC__         /*old*/ 
....................         #define __OSAPICCPRO__      /*old*/ 
....................         #define __OSAPIC__          /*old*/ 
....................     #else 
....................         #define __OSA_PIC16_HTPICC__ 
....................         #define __OSA_PIC16__ 
....................         #define __OSA_HTPICC__ 
....................  
....................         #define __OSAPICC16__       /*old*/ 
....................         #define __OSAPICC__         /*old*/ 
....................         #define __OSA16__           /*old*/ 
....................         #define __OSAPIC__          /*old*/ 
....................     #endif 
....................  
....................  
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #include "OSAcfg.h"         /* This file contains project configuration         */ 
.................... /******************************************************************************/ 
.................... // 
.................... // This file was generated by OSAcfg_Tool utility. 
.................... // Do not modify it to prevent data loss on next editing. 
.................... // 
.................... // PROJECT NAME: Main3DPrinter 
.................... // 
.................... // PLATFORM:     CCS for PIC18 
.................... // 
.................... /******************************************************************************/ 
....................  
....................  
.................... #ifndef _OSACFG_H 
.................... #define _OSACFG_H 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // SYSTEM 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_TASKS                7   // Number of tasks that can be active at one time 
.................... #define OS_DISABLE_PRIORITY         // old style constant 
.................... #define OS_PRIORITY_LEVEL  OS_PRIORITY_DISABLED  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // ENABLE CONSTANTS 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_ENABLE_TTIMERS           // Enable task timers (OS_Delay and OS_xxx_Wait_TO) 
....................  
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... #if defined(__OSACCS__) || defined(__OSAMIKROC__) || defined(__OSA_AVR_WINAVR__) 
....................  
....................     #define OSM_BEGIN 
....................     #define OSM_END 
....................  
.................... #else 
....................  
....................     #define OSM_BEGIN   do 
....................     #define OSM_END     while (0) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  * OSA CONFIGURATION                                                                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  PRIORITY MODE 
.................... //****************************************************************************** 
....................  
.................... #define OS_PRIORITY_NORMAL      0 
.................... #define OS_PRIORITY_DISABLED    1 
.................... #define OS_PRIORITY_EXTENDED    2 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef OS_PRIORITY_LEVEL 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #if     defined(OS_DISABLE_PRIORITY) 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_DISABLED 
....................     #elif   defined(OS_EXTENDED_PRIORITY) 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_EXTENDED 
....................     #else 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_NORMAL 
....................     #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  
.................... //  CHECK FOR SET OF SERVICES 
.................... //  
.................... //****************************************************************************** 
....................  
....................  
.................... #if defined(OS_ENABLE_ALL) 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // undef all config constants 
....................  
....................     #ifdef OS_ENABLE_TIMER 
....................     #undef OS_ENABLE_TIMER 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_CSEM 
....................     #undef OS_ENABLE_CSEM 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QUEUE 
....................     #undef OS_ENABLE_QUEUE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_SQUEUE 
....................     #undef OS_ENABLE_SQUEUE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_CRITICAL_SECTION 
....................     #undef OS_ENABLE_CRITICAL_SECTION 
....................     #endif 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // undef all old style config constants 
....................  
....................     #ifdef OS_TIMER_ENABLE 
....................     #undef OS_TIMER_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_CSEM_ENABLE 
....................     #undef OS_CSEM_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_QMSG_ENABLE 
....................     #undef OS_QMSG_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_QSMSG_ENABLE 
....................     #undef OS_QSMSG_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_DTIMERS_ENABLE 
....................     #undef OS_DTIMERS_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QMSG 
....................     #undef OS_ENABLE_QMSG 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QSMSG 
....................     #undef OS_ENABLE_QSMSG 
....................     #endif 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // define all config constants 
....................  
....................     #define OS_ENABLE_CSEM 
....................     #define OS_ENABLE_QUEUE 
....................     #define OS_ENABLE_SQUEUE 
....................     #define OS_ENABLE_TTIMERS 
....................     #define OS_ENABLE_CRITICAL_SECTION 
....................  
.................... #endif 
....................  
.................... #if defined(OS_ENABLE_QTIMER) && defined(__OSA_PIC12_HTPICC__)  
.................... #error "OSA error #22: Qtimers are not supported under 12-bit controllers (PIC10 and PIC12)" 
.................... #endif 
....................  
....................  
.................... /*------------------------------------------*/ 
.................... /*                                          */ 
.................... /* (OSA configuration)                      */ 
.................... /* Redefining old style constants           */ 
.................... /*                                          */ 
.................... /*------------------------------------------*/ 
....................  
.................... #ifdef OS_TIMER_ENABLE 
.................... #define OS_ENABLE_TIMER     /* Defined when using timers in tasks (OS_Delay     */ 
....................                             /* and wait events with timeout)                    */ 
.................... #endif 
....................  
.................... #ifdef OS_CSEM_ENABLE 
.................... #define OS_ENABLE_CSEM      /* Defined when using counting semaphores           */ 
.................... #endif 
....................  
.................... #ifdef OS_QMSG_ENABLE       //^ 
.................... #define OS_ENABLE_QUEUE      /* Defined when using queue of pointer to messages  */ 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_QMSG       //^ 
.................... #define OS_ENABLE_QUEUE      /* Defined when using queue of pointer to messages  */ 
.................... #endif 
....................  
.................... #ifdef OS_QSMSG_ENABLE      //^ 
.................... #define OS_ENABLE_SQUEUE     /* Defined when using queue of simple messages      */ 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_QSMSG      //^ 
.................... #define OS_ENABLE_SQUEUE     /* Defined when using queue of simple messages      */ 
.................... #endif 
....................  
.................... #ifdef OS_DTIMERS_ENABLE 
.................... #define OS_ENABLE_DTIMERS   /* Defined when using dynamic timers                */ 
.................... #endif 
....................  
....................  
.................... #ifdef OS_QUEUES_IDENTICAL   //^ 
.................... #define OS_QUEUE_SQUEUE_IDENTICAL  // Defined to reduce code size when both types 
....................                                    // of queues are used 
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // (OSA configuration) 
.................... // Set constants for interrupt usage 
....................  
.................... #ifdef  OS_ENABLE_INT_SERVICE       // Redefining old style constant 
.................... #define OS_ENABLE_INT_ALL 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_INT_ALL 
....................  
....................     #define OS_ENABLE_INT_BSEM      /* Enables interrupt services for binary    */ 
....................                                     /* semaphores                               */ 
....................  
....................     #define OS_ENABLE_INT_CSEM      /* Enables interrupt services for counting  */ 
....................                                     /* semaphores                               */ 
....................  
....................     #define OS_ENABLE_INT_MSG       /* Enables interrupt services for pointers  */ 
....................                                     /* to messages                              */ 
....................  
....................     #define OS_ENABLE_INT_SMSG      /* Enables interrupt services for simple    */ 
....................                                     /* messages                                 */ 
....................  
....................     #define OS_ENABLE_INT_QUEUE     /* Enables interrupt services for queues of */ 
....................                                     /* pointers to messages and simple messages */ 
....................  
....................     #define OS_ENABLE_INT_FLAG      /* Enables interrupt services for flags     */ 
....................                                      
.................... #endif 
....................  
....................  
.................... #if defined(OS_ENABLE_INT_CSEM)  ||                     \ 
....................     defined(OS_ENABLE_INT_BSEM)  ||                     \ 
....................     defined(OS_ENABLE_INT_MSG)   ||                     \ 
....................     defined(OS_ENABLE_INT_SMSG)  ||                     \ 
....................     defined(OS_ENABLE_INT_QUEUE) ||                     \ 
....................     defined(OS_ENABLE_INT_FLAG)  ||                     \ 
....................     defined(OS_PROTECT_MEMORY_ACCESS) 
....................  
....................  
....................     #define OS_ENABLE_INT 
....................  
.................... #endif 
....................  
.................... /* 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  * (OSA configuration)                                                          * 
....................  * Set system constants for timers                                              * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  */ 
....................  
.................... #if defined(OS_ENABLE_TIMER) 
.................... #define OS_ENABLE_TTIMERS       /* Enables task timers                          */ 
.................... #endif 
....................  
....................  
.................... #ifdef OS_ENABLE_PTIMERS        /* Redefining old name (ptimer) to new (dtimer) */ 
....................     #define OS_ENABLE_DTIMERS  
.................... #endif 
....................  
.................... #if !defined(OS_STIMERS) 
....................     #define OS_STIMERS  0       /* Number of STimers                            */ 
.................... #endif 
....................  
....................  
.................... /*--------------------------------------------------*/ 
.................... /*                                                  */ 
.................... /* Counting number of old style static timers       */ 
.................... /*                                                  */ 
.................... /* note:    it is not recommended to use this       */ 
.................... /*          type of timers. Use STimers instead.    */ 
.................... /*                                                  */ 
.................... /*--------------------------------------------------*/ 
....................  
.................... #ifndef OS_TIMERS8                  /* not recommended to use       */ 
....................     #define OS_TIMERS8 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS16                 /* not recommended to use       */ 
....................     #define OS_TIMERS16 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS24                 /* not recommended to use       */ 
....................     #define OS_TIMERS24 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS32                 /* not recommended to use       */ 
....................     #define OS_TIMERS32 0 
.................... #endif 
....................  
....................  
.................... #define _OS_TIMER8_POS      (0) 
.................... #define _OS_TIMER16_POS     (_OS_TIMER8_POS  + OS_TIMERS8) 
.................... #define _OS_TIMER24_POS     (_OS_TIMER16_POS + OS_TIMERS16) 
.................... #define _OS_TIMER32_POS     (_OS_TIMER24_POS + OS_TIMERS24) 
....................  
....................  
.................... #define OS_TIMERS           (OS_TIMERS8 + OS_TIMERS16 + OS_TIMERS24 + OS_TIMERS32) 
....................  
.................... #if OS_STIMERS > 0 
....................     #define OS_ENABLE_STIMERS   1 
.................... #endif 
....................  
....................  
....................  
.................... /*--------------------------------------------------*/ 
.................... /* Enable system timer if any type of timers used   */ 
.................... /*--------------------------------------------------*/ 
....................  
.................... #if defined(OS_ENABLE_DTIMERS)  ||              \ 
....................     defined(OS_ENABLE_TTIMERS)  ||              \ 
....................     defined(OS_ENABLE_STIMERS)  ||              \ 
....................     defined(OS_ENABLE_QTIMERS)  ||              \ 
....................     (OS_TIMERS > 0) 
....................  
....................     #define OS_ENABLE_OS_TIMER 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  DEFINE BANKS TO ALLOCATE DATA                                                               * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... /*------------------------------------------*/ 
.................... /* Check for old style defitions            */ 
.................... /*------------------------------------------*/ 
.................... #if     defined(OS_BANK)            ||      \ 
....................         defined(OS_TASKS_BANK)      ||      \ 
....................         defined(OS_TIMERS_BANK)     ||      \ 
....................         defined(OS_TIMERS8_BANK)    ||      \ 
....................         defined(OS_TIMERS16_BANK)   ||      \ 
....................         defined(OS_TIMERS24_BANK)   ||      \ 
....................         defined(OS_TIMERS32_BANK)   ||      \ 
....................         defined(OS_TIMEOUTS_BANK)   ||      \ 
....................         defined(OS_BSEM_BANK) 
....................  
.................... #error "OSA error #2: Constants OS_xxx_BANK are not allowed now (use OS_BANK_xxx instead)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /*------------------------------------------*/ 
.................... /*                                          */ 
.................... /* Set RAM bank constants                   */ 
.................... /*                                          */ 
.................... /*------------------------------------------*/ 
....................  
.................... #ifndef OS_BANK_OS 
.................... #define OS_BANK_OS      0               /* RAM bank for OSA internal variables  */ 
.................... #endif 
....................  
....................  
.................... #if defined(OS_BANK_TASK) && !defined(OS_BANK_TASKS) 
.................... #define OS_BANK_TASKS   OS_BANK_TASK 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #if defined(OS_ADDRESS_TASKS) && defined(__OSA_PIC16_MIKROC__)   // For direct allocation of 
....................     #define OS_ALLOCATION_TASKS absolute OS_ADDRESS_TASKS   // task descriptors in 
....................                                                             // mikroC PRO for PIC16 
.................... #else 
....................     #define OS_ALLOCATION_TASKS                             // Empty for others 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #ifndef OS_BANK_TASKS 
.................... #define OS_BANK_TASKS       OS_BANK_OS  /* RAM bank for task descriptors        */ 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS 
.................... #define OS_BANK_TIMERS      OS_BANK_OS  /* RAM bank for old style static timers */ 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS8 
.................... #define OS_BANK_TIMERS8     OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS16 
.................... #define OS_BANK_TIMERS16    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS24 
.................... #define OS_BANK_TIMERS24    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS32 
.................... #define OS_BANK_TIMERS32    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMEOUTS 
.................... #define OS_BANK_TIMEOUTS    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_STIMERS 
.................... #define OS_BANK_STIMERS     OS_BANK_TIMERS  /* RAM bank for static timers       */ 
.................... #endif 
....................  
.................... #if defined(OS_BANK_BSEMS) && !defined(OS_BANK_BSEM) 
.................... #define OS_BANK_BSEM   OS_BANK_BSEMS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_BSEM 
.................... #define OS_BANK_BSEM      OS_BANK_OS /* RAM bank for array of binary semaphores */ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  Checking validness of bank settings for each type of OSA data 
.................... //  
.................... //****************************************************************************** 
....................  
....................  
.................... #if     OS_BANK_OS == 0 
.................... #define OS_BANK         OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_OS == 1 
.................... #define OS_BANK         OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_OS == 2 
.................... #define OS_BANK         OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_OS == 3 
.................... #define OS_BANK         OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #3: Incorrect OS_BANK_OS value (should be 0, 1, 2 or 3)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TASKS == 0 
.................... #define OS_TASKS_BANK       OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TASKS == 1 
.................... #define OS_TASKS_BANK       OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TASKS == 2 
.................... #define OS_TASKS_BANK       OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TASKS == 3 
.................... #define OS_TASKS_BANK       OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #4: Incorrect OS_BANK_TASKS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS == 0 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS == 1 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS == 2 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS == 3 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #5: Incorrect OS_BANK_TIMERS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_STIMERS == 0 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_STIMERS == 1 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_STIMERS == 2 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_STIMERS == 3 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #6: Incorrect OS_BANK_STIMERS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS8 == 0 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS8 == 1 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS8 == 2 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS8 == 3 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #7: Incorrect OS_BANK_TIMERS8 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS16 == 0 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS16 == 1 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS16 == 2 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS16 == 3 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #8: Incorrect OS_BANK_TIMERS16 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS24 == 0 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS24 == 1 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS24 == 2 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS24 == 3 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #9: Incorrect OS_BANK_TIMERS24 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS32 == 0 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS32 == 1 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS32 == 2 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS32 == 3 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #10: Incorrect OS_BANK_TIMERS32 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMEOUTS == 0 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 1 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 2 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 3 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #11: Incorrect OS_BANK_TIMEOUTS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_BSEM == 0 
.................... #define OS_BSEM_BANK        OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_BSEM == 1 
.................... #define OS_BSEM_BANK        OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_BSEM == 2 
.................... #define OS_BSEM_BANK        OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_BSEM == 3 
.................... #define OS_BSEM_BANK        OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #12: Incorrect OS_BANK_BSEM value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Definition of data sizes for each type of OSA data                                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Number of task descriptors (maximum active tasks at one time 
.................... //****************************************************************************** 
....................  
.................... #if defined (OS_TASKS) && (OS_TASKS == 0) 
.................... #undef OS_TASKS 
.................... #endif 
....................  
....................  
.................... #ifndef OS_TASKS 
.................... #define OS_TASKS    1       // We need at least 1 task 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Types of timers 
.................... //****************************************************************************** 
....................  
.................... #if defined(OST_TIMER) 
.................... #error "OSA error #13: OST_TlMER is not supported! Use OS_TIMER_SIZE instead (see manual)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... #if !defined(OS_TIMER_SIZE) 
....................     #define OS_TIMER_SIZE   2           /* Default timer size   */ 
.................... #endif 
....................  
.................... #if     OS_TIMER_SIZE == 1 
.................... #define OS_TIMER_TYPE       OST_UINT8 
....................  
.................... #elif   OS_TIMER_SIZE == 2 
.................... #define OS_TIMER_TYPE       OST_UINT16 
....................  
.................... #elif   OS_TIMER_SIZE == 4 
.................... #define OS_TIMER_TYPE       OST_UINT32 
....................  
.................... #else 
....................     #error "OSA error #17: Bad TIMER size (must be 1, 2 or 4)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of static timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_STIMER_SIZE) 
.................... #define OS_STIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_STIMER_SIZE == 1 
.................... #define OS_STIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_STIMER_SIZE == 2 
.................... #define OS_STIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_STIMER_SIZE == 4 
.................... #define OS_STIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #18: Bad STIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of dynamic timer's counter 
.................... //****************************************************************************** 
....................  
.................... #ifdef OS_PTIMER_SIZE        // Redefine old name (ptimer) to new (dtimer) 
.................... #define OS_DTIMER_SIZE OS_PTIMER_SIZE 
.................... #endif 
....................  
.................... #if !defined(OS_DTIMER_SIZE) 
.................... #define OS_DTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_DTIMER_SIZE == 1 
.................... #define OS_DTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_DTIMER_SIZE == 2 
.................... #define OS_DTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_DTIMER_SIZE == 4 
.................... #define OS_DTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #19: Bad DTIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of fast timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_QTIMER_SIZE) 
.................... #define OS_QTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_QTIMER_SIZE == 1 
.................... #define OS_QTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_QTIMER_SIZE == 2 
.................... #define OS_QTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_QTIMER_SIZE == 4 
.................... #define OS_QTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #21: Bad QTIMER size (must be 1, 2 or 4)"  
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of task timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_TTIMER_SIZE) 
.................... #define OS_TTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_TTIMER_SIZE == 1 
.................... #define OS_TTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_TTIMER_SIZE == 2 
.................... #define OS_TTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_TTIMER_SIZE == 4 
.................... #define OS_TTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #20: Bad TTIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  S Y S T E M   D A T A   T Y P E S                                                           * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Simple byte message 
.................... // (this type should be defined BEFORE including port\osa_xxx.h) 
.................... //****************************************************************************** 
....................  
.................... #ifdef  OST_SMSG 
.................... #error "OSA error #14: Can't redefine name OST SMSG in 'OSAcfg.h'. Use OST_SMSG instead." 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... #if !defined(OS_SMSG_TYPE) 
.................... #define     OS_SMSG_TYPE    unsigned char 
.................... #endif 
....................  
.................... typedef OS_SMSG_TYPE    _OST_SMSG;      //  See port\pic16\osa_pic16_htpicc.h for example 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     INCLUDE PROCESSOR SPECIFIC DEFINITIONS                                                   * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #include "port\osa_include.h" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_include.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Include proc specific file 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        19.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSA_PIC18_HTPICC__)               // HT-PICC18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_htpicc.h> 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MPLABC__)             // MPLAB C18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mplabc.h>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MPLABC_EXT__)         // MPLAB C18 for extended mode  
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mplabc_ext.h>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC24_MPLABC__)             // MPLAB C30 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic24\osa_pic24_mplabc.h>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_CCS__)                // CCS-PICC (for PIC16 only) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_ccs.h>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_CCS__)                // CCS-PICC (for PIC18 only) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_ccs.h>           
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_pic18_ccs.h 
....................  * 
....................  *  Compilers:      CCS 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    CCS for PIC18 specific definition 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        13.09.2010 -    File updated 
....................  * 
....................  *                  26.12.2010 -    OS_RETURN_NOSAVE corrected (NOP added after call to _OS_ReturnNoSave) 
....................  *  
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... #ifndef __OSACCS18_H__ 
.................... #define __OSACCS18_H__ 
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Integer types definitions                                                                * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #define OST_UINT8     unsigned int8 
.................... #define OST_UINT16    unsigned int16 
.................... #define OST_UINT32    unsigned int32 
.................... #define OST_BOOL      unsigned int8 
....................  
.................... #define OST_UINT   OST_UINT8 
.................... #define _OST_INT_MASK    7 
.................... #define _OST_INT_SHIFT   3 
.................... #define _OST_INT_SIZE    8 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Location keywords                                                                        * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #define OS_RAM_NEAR 
.................... #define OS_RAM_BANK0 
.................... #define OS_RAM_BANK1 
.................... #define OS_RAM_BANK2 
.................... #define OS_RAM_BANK3 
....................  
....................  
.................... #define _OS_CUR_FLAGS_IN_OS_STATE   // Work with tasks state througth _OS_State variable 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Processor specified definitions for system flags                                         * 
....................  *     (see OST_SYSTEM_FLAGS and OST_TCB definition in file "OSA.h")                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #define _OS_SYSTEM_FLAGS_PROC_SPEC()                                                       \ 
....................                                                                                            \ 
....................         /*5*/   OST_UINT   bTimeout    : 1; /* Event waiting timeout                */     \ 
....................         /*6*/   OST_UINT   bGIE_CTemp  : 1; /* Saved GIEH while in critical section */     \ 
....................         /*7*/   OST_UINT   bGIEL_CTemp : 1; /* Saved GIEL while in critical section */     \ 
....................  
.................... #define _OS_TCB_PROC_SPEC()      // Empty macro for this processor 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Registers definitions                                                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #word _fsr      = 0xFE9 
.................... #byte _fsrl     = 0xFE9 
.................... #byte _fsrh     = 0xFEA 
.................... #byte _indf     = 0xFEF 
.................... #byte _postinc  = 0xFEE 
.................... #byte _postdec  = 0xFED 
.................... #byte _preinc   = 0xFEC 
....................  
.................... #byte _fsr1l    = 0xFE1 
....................  
.................... #byte _pcl      = 0xFF9 
.................... #byte _pclath   = 0xFFA 
.................... #byte _pclatu   = 0xFFB 
.................... #byte _status   = 0xFD8 
.................... #byte _tosl     = 0xFFD 
.................... #byte _tosh     = 0xFFE 
.................... #byte _tosu     = 0xFFF 
.................... #byte _bsr      = 0xFE0 
.................... #byte _wreg     = 0xFE8 
.................... #byte _intcon   = 0xFF2 
.................... #byte _rcon     = 0xFD0 
.................... #byte _stkptr   = 0xFFC 
....................  
....................  
.................... #bit  _gie      = _intcon.7 
.................... #bit  _gieh     = _intcon.7 
.................... #bit  _giel     = _intcon.6 
.................... #bit  _ipen     = _rcon.7 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Constants and types                                                                      * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #ifndef OS_SMSG_SIZE 
.................... #define OS_SMSG_SIZE    0 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_FSR_TYPE            OST_UINT16 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __SMALL__ 
....................  
.................... #if defined(__SMALL__) 
....................     #define OST_CODE_POINTER    OST_UINT16 
....................     #define OS_CODE_POINTER_SIZE    2 
.................... #else 
....................     #define OST_CODE_POINTER    OST_UINT32 
....................     #define OS_CODE_POINTER_SIZE    4 
.................... #endif 
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Platform specific macros                                                                 * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... #define _OS_PIC18_ERRATA_NOP()  #asm nop #endasm 
.................... #define _OS_POP()         #asm pop #endasm 
....................  
.................... #define OS_CLRWDT()   #asm  clrwdt  #endasm 
.................... #define OS_SLEEP()    #asm  sleep   #endasm 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Internal macro for work with state flags                                                 * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //#define _OS_bTaskReady              ((OST_TASK_STATE)_indf).bReady 
.................... //#define _OS_bTaskCanContinue        ((OST_TASK_STATE)_indf).bCanContinue 
.................... //#define _OS_bTaskDelay              ((OST_TASK_STATE)_indf).bDelay 
.................... //#define _OS_bTaskTimeout            (!(((OST_TASK_STATE)_indf).bDelay)) 
.................... //#define _OS_bTaskEnable             ((OST_TASK_STATE)_indf).bEnable 
.................... //#define _OS_cTaskPriority           ((OST_TASK_STATE)_indf).cPriority 
.................... //#define _OS_bTaskPaused             ((OST_TASK_STATE)_indf).bPaused 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Context switching macros                                                                 * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #define _OS_TASK_POINTER_OFFSET         1 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Save/restore PC macros 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_CODE_POINTER_SIZE == 2 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #define _OS_SET_PC()                    \ 
....................         #asm                                \ 
....................             movff      _postinc, _wreg      \ 
....................             movff      _postinc, _pclath    \ 
....................             movwf     _pcl                  \ 
....................         #endasm 
....................  
....................  
....................     #define _OS_SAVE_PC()                   \ 
....................         _postdec = _tosh;                   \ 
....................         _postdec = _tosl; 
....................  
....................  
....................     #define _OS_SET_INDF_WORD(value)                                    \ 
....................         _postinc = (((OST_CODE_POINTER)value)) & 0xFF;                  \ 
....................         _postinc = (((OST_CODE_POINTER)value) >> 8) & 0xFF; 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #define _OS_SET_PC()                    \ 
....................         #asm                                \ 
....................             movff      _postinc, _wreg      \ 
....................             movff      _postinc, _pclath    \ 
....................             movff      _postinc, _pclatu    \ 
....................             movwf     _pcl                  \ 
....................         #endasm 
....................  
....................     #define _OS_SAVE_PC()                   \ 
....................         _postdec = 0;                       \ 
....................         _postdec = _tosu;                   \ 
....................         _postdec = _tosh;                   \ 
....................         _postdec = _tosl; 
....................  
....................  
....................     #define _OS_SET_INDF_WORD(value)                                \ 
....................         _postinc = (((OST_CODE_POINTER)value)) & 0xFF;              \ 
....................         _postinc = (((OST_CODE_POINTER)value) >> 8) & 0xFF;         \ 
....................         _postinc = (((OST_CODE_POINTER)value) >> 16) & 0xFF;        \ 
....................         _postinc = 0; 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************ 
....................  * 
....................  *  All context switches are based one five macros: 
....................  * 
....................  *  _OS_RETURN_SAVE()         - save context and return to scheduler 
....................  * 
....................  *  _OS_RETURN_NO_SAVE()      - returning to scheduler without saving context 
....................  * 
....................  *  _OS_ENTER_WAIT_MODE()     - switch the task to wait mode 
....................  * 
....................  *  _OS_ENTER_WAIT_MODE_TO()  - switch the task to wait mode with exit on timeout 
....................  * 
....................  *  _OS_CHECK_EVENT()         - check for event is true. Continue task execution if 
....................  *                              then event is true, or switch context otherwise 
....................  * 
....................  ************************************************************************************/ 
....................  
....................  
....................  
.................... #separate void _OS_JumpToTask (void); 
.................... #separate void _OS_ReturnSave (void); 
.................... #separate void _OS_ReturnNoSave (void); 
.................... #separate void _OS_EnterWaitMode (void); 
.................... #separate void _OS_EnterWaitModeTO (void); 
.................... #separate void _OS_CheckEvent (OST_UINT); 
....................  
....................  
.................... #define _OS_JUMP_TO_TASK()      _OS_JumpToTask() 
....................  
....................  
.................... #define _OS_BACK_TO_SCEDULER()                                                          \ 
....................         _OS_SET_FSR_CUR_TASK();                                                         \ 
....................         _indf &= ~(OS_TASK_READY_MASK | OS_TASK_CANCONTINUE_MASK);                      \ 
....................         _indf |= ((char)_OS_State) & (OS_TASK_READY_MASK | OS_TASK_CANCONTINUE_MASK);   \ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_RETURN_SAVE()                       \ 
....................     {                                           \ 
....................         _OS_ReturnSave();                       \ 
....................         _OS_PIC18_ERRATA_NOP();                 \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_ENTER_WAIT_MODE()                   \ 
....................     {                                           \ 
....................         _OS_EnterWaitMode();                    \ 
....................         _OS_PIC18_ERRATA_NOP();                 \ 
....................     } 
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_ENTER_WAIT_MODE_TO()                \ 
....................     {                                           \ 
....................         _OS_EnterWaitModeTO();                  \ 
....................         _OS_PIC18_ERRATA_NOP();                 \ 
....................     } 
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_RETURN_NO_SAVE()                    \ 
....................     {                                           \ 
....................         _OS_ReturnNoSave();                     \ 
....................         _OS_PIC18_ERRATA_NOP();   /*101226*/    \ 
....................     }                                           \ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_CHECK_EVENT(event)      _OS_CheckEvent(event) 
....................  
....................  
.................... #define _OS_SET_FSR_CUR_TASK()      _fsr = (OS_FSR_TYPE)&_OS_CurTask->State 
.................... #define _OS_SET_FSR_CUR_TASK_W(w)   _fsr = ((OS_FSR_TYPE)&_OS_CurTask->State) + w 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     Create, replace, reserve task specific services                                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Replace current task with new (current task will be deleted)         */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Task_Replace(priority, TaskName)                                         \ 
....................     {                                                                               \ 
....................         _OS_SET_FSR_CUR_TASK();                                                     \ 
....................         _indf = priority | 0x48; /* bEnable  bReady */                             \ 
....................         _OS_CurTask->pTaskPointer = ((OST_CODE_POINTER)TaskName);                   \ 
....................         _OS_RETURN_NO_SAVE();                                                       \ 
....................     } 
....................  
.................... #define OS_Task_Replace_P(p,t)   OS_Task_Replace(p,t) 
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Create task                                                          */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Task_Create(priority, TaskName)                          \ 
....................     {                                                               \ 
....................         _OS_Task_Create(priority, (OST_CODE_POINTER)TaskName);      \ 
....................     } 
....................  
.................... #define OS_Task_Create_M(priority, TaskName)                        \ 
....................     {                                                               \ 
....................         OS_Task_Reserve(TaskName);                                  \ 
....................         _OS_Task_Create(priority, (OST_CODE_POINTER)TaskName);      \ 
....................      } 
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Create task by indirrect address                                     */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Task_Reserve(TaskName)                                   \ 
....................         if (_pcl & 1) TaskName();                                   \ 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                     I N T E R R U P T S                                      * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... char    OS_DI (void); 
.................... void    OS_RI (char); 
.................... #define OS_EI()         { _gie = 1; if (_ipen) _giel = 1;} 
.................... #define OS_EIH()        { _gie = 1; } 
.................... #define OS_EIL()        { _giel = 1; } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT) 
.................... //------------------------------------------------------------------------------ 
....................     extern void _OS_DI_INT (void); 
....................     extern void _OS_RI_INT (void); 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //____________________________________________________________________________________________________________ 
.................... //************************************************************************************************************ 
.................... // 
.................... //                    S P E C I F I C      M A C R O S       O V E R L O A D 
.................... // 
.................... //                    (used ro increasing the speed and reducing the code size) 
.................... // 
.................... //************************************************************************************************************ 
....................  
....................  
....................  
.................... /****************************************************************************************** 
....................  * 
....................  * T I M E R S    M A C R O S    D E F I N I T I O N S 
....................  * 
....................  ******************************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................     #if OS_TTIMER_SIZE == 2 
....................  
....................         // CCS18 has and error when working with ++(int*). 
....................  
....................         #define __OS_TtimersWorkSize()                                                      \ 
....................         {                                                                                   \ 
....................             OST_UINT _os_i;                                                                 \ 
....................             ASM_OST_TCB_SIZE_CONST;                                                         \ 
....................             ASM_SET_BANK;                                                                   \ 
....................             for (_os_i = 0; _os_i < OS_TASKS; _os_i++)                                      \ 
....................             {                                                                               \ 
....................                 if (_OS_Tasks[_os_i].State.bDelay){                                         \ 
....................                     _OS_Tasks[_os_i].Timer++;                                               \ 
....................                     if (!_OS_Tasks[_os_i].Timer) _OS_Tasks[_os_i].State.bDelay = 0;         \ 
....................                 }                                                                           \ 
....................             }                                                                               \ 
....................         } 
....................  
....................     #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /****************************************************************************************** 
....................  * 
....................  *  WORK WITH DYNAMIC TIMERS 
....................  * 
....................  ******************************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define _OS_DtimersWork_DEFINED 
....................  
.................... #define _OS_IndfTimerTimeout       ((OS_RAM_NEAR OST_DTIMER_FLAGS)(_indf)).bTimeout 
.................... #define _OS_IndfTimerActive        ((OS_RAM_NEAR OST_DTIMER_FLAGS)(_indf)).bActive 
.................... #define _OS_IndfTimerRun           ((OS_RAM_NEAR OST_DTIMER_FLAGS)(_indf)).bRun 
.................... #define _OS_IndfTimerNextEnable    ((OS_RAM_NEAR OST_DTIMER_FLAGS)(_indf)).bNextEnable 
.................... #define _OS_PostincTimerNextEnable ((OS_RAM_NEAR OST_DTIMER_FLAGS)(_postinc)).bNextEnable 
....................  
....................  
....................  
....................  
....................  
.................... #if   OS_DTIMER_SIZE == 1 
....................     #define _OS_INC_DTIMER()                                                            \ 
....................         {                                                                               \ 
....................             #asm                                                                        \ 
....................                 movlw   3                                                               \ 
....................                 addwf   _fsr, f                                                         \ 
....................                 incf    _postdec, f     /*      FSR0L */    \ 
....................                 movf    _postdec, f                                                     \ 
....................                 movf    _postdec, f                                                     \ 
....................             #endasm                                                                     \ 
....................             if (_status & 0x01) _OS_IndfTimerTimeout = 1;                               \ 
....................         } 
....................  
....................  
.................... #elif OS_DTIMER_SIZE == 2 
....................     #define _OS_INC_DTIMER()                                                            \ 
....................         {                                                                               \ 
....................             _OS_DTimers.Flags.bTimeout = 0;                                             \ 
....................             #asm                                                                        \ 
....................                 movlw   3                                                               \ 
....................                 addwf   _fsr, f                                                         \ 
....................                 movlw   0                                                               \ 
....................                 incf    _postinc, f                                                     \ 
....................                 addwfc  _postdec, f                                                     \ 
....................             #endasm                                                                     \ 
....................             if (_status & 0x01) _OS_DTimers.Flags.bTimeout = 1;                         \ 
....................             #asm                                                                        \ 
....................                 movlw   3                                                               \ 
....................                 subwf   _fsr, f                                                         \ 
....................             #endasm                                                                     \ 
....................             if (_OS_DTimers.Flags.bTimeout)                                             \ 
....................                 _OS_IndfTimerTimeout = 1;                                               \ 
....................         } 
....................  
....................  
.................... #elif OS_DTIMER_SIZE == 4 
....................     #define _OS_INC_DTIMER()                                                            \ 
....................         {                                                                               \ 
....................             _OS_DTimers.Flags.bTimeout = 0;                                             \ 
....................             #asm                                                                        \ 
....................                 movlw   3                                                               \ 
....................                 addwf   _fsr, f                                                         \ 
....................                 movlw   0                                                               \ 
....................                 incf    _postinc, f                                                     \ 
....................                 addwfc  _postinc, f                                                     \ 
....................                 addwfc  _postinc, f                                                     \ 
....................                 addwfc  _postdec, f                                                     \ 
....................             #endasm                                                                     \ 
....................             if (_status & 0x01) _OS_DTimers.Flags.bTimeout = 1;                         \ 
....................             #asm                                                                        \ 
....................                 movlw   5                                                               \ 
....................                 subwf   _fsr, f                                                         \ 
....................             #endasm                                                                     \ 
....................             if (_OS_DTimers.Flags.bTimeout)                                             \ 
....................                 _OS_IndfTimerTimeout = 1;                                               \ 
....................         } 
....................  
.................... #endif 
....................  
....................  
.................... #define __OS_DtimersWork()                              \ 
....................     {                                                   \ 
....................         _fsr = (OS_FSR_TYPE) &_OS_DTimers.Flags;        \ 
....................     REPEAT:                                             \ 
....................         if (_OS_PostincTimerNextEnable)                 \ 
....................         {                                               \ 
....................             /*  FSR  .  */     \ 
....................             #asm                                        \ 
....................                 movf    _postinc, w                     \ 
....................                 movff   _postdec, _fsrh                 \ 
....................                 movwf   _fsrl                           \ 
....................             #endasm                                     \ 
....................             if (!_OS_IndfTimerRun) goto REPEAT;         \ 
....................             _OS_INC_DTIMER();                           \ 
....................             goto REPEAT;                                \ 
....................         }                                               \ 
....................     } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_DTIMER 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_pic18_ccs.h 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC12_HTPICC__)             // HT_PICC for 12-bit PICs 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic12\osa_pic12_htpicc.h>          
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_HTPICC__)             // HT_PICC 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_htpicc.h>          
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16E_HTPICC_PRO__)        // HT_PICC_PRO for pic16f1xxx 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16e_htpicc_pro.h>      
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_MIKROC__)             // mikroC for PIC16 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_mikroc.h>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MIKROC__)             // mikroC for PIC18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mikroc.h>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_WINAVR__)               // WinAVR for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_winavr.h>         
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_IAR__)                  // IAR for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_iar.h>         
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_CODEVISION__)           // CodeVision for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_codevision.h>         
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_IAR__)                 // IAR for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_iar.h>       
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__)              // Cosmic for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_cosmic.h>       
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_RAISONANCE__)          // Raisonance for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_raisonance.h>       
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #error "OSA error #1: Unknown compiler!" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_include.h 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #define OST_WORD        OST_UINT 
.................... #define _OST_INT_TYPE   OST_WORD        // Old types redefining (don't use it) 
.................... #define __osa_word      OST_WORD        // Old types redefining (don't use it) 
.................... #define __osa_uint8     OST_UINT8       // Old types redefining (don't use it) 
.................... #define __osa_uint16    OST_UINT16      // Old types redefining (don't use it) 
.................... #define __osa_uint32    OST_UINT32      // Old types redefining (don't use it) 
....................  
....................  
.................... typedef OS_SMSG_TYPE    OST_SMSG; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to message 
.................... //****************************************************************************** 
....................  
.................... #ifdef  OST_MSG 
.................... #error "OSA error #15: Can't redefine name OST MSG in 'OSAcfg.h'. Use OST_MSG instead." 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... #if !defined(OS_MSG_TYPE) 
.................... #define OS_MSG_TYPE     void * 
.................... #endif 
....................  
....................  
.................... typedef OS_MSG_TYPE     OST_MSG; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to message descriptor 
.................... //****************************************************************************** 
....................  
.................... typedef  
.................... #ifndef __OSA_AVR_CODEVISION__ 
....................         volatile  
.................... #endif 
....................                     struct _OST_MSG_CB 
.................... { 
....................     OST_UINT        status;     // State (=1 - busy / =0 - free) 
....................     OST_MSG         msg;        // Pointer to message body 
....................  
.................... } OST_MSG_CB; 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Message's queues 
.................... //****************************************************************************** 
....................  
.................... /*--- Queue's control block                         ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_UINT   cSize;      // Queue size 
....................     OST_UINT   cFilled;    // Number of filled elements 
....................     OST_UINT   cBegin;     // First element in buffer 
....................                            //  
.................... } OST_QUEUE_CONTROL; 
....................  
....................  
.................... /*--- Descriptor of queue of pointers to messages   ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_QUEUE_CONTROL Q; 
....................     OST_MSG *pMsg;              // Pointer to queue buffer 
....................  
.................... } OST_QUEUE; 
....................  
....................  
.................... /*--- Descriptor of queue of simple messages        ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_QUEUE_CONTROL Q; 
....................     OST_SMSG *pSMsg;            // Pointer to queue buffer 
....................  
.................... } OST_SQUEUE; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Flags 
.................... //****************************************************************************** 
....................  
.................... #define OST_FLAG    OST_UINT8 
.................... #define OST_FLAG8   OST_UINT8 
.................... #define OST_FLAG16  OST_UINT16 
.................... #define OST_FLAG32  OST_UINT32 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  System state flags 
.................... //  
.................... //  (!!!Do not change positions of theese bits. For MCC30 bits 
.................... //  cIPL_Temp must occupy 5, 6 and 7 positions) 
.................... //****************************************************************************** 
....................  
.................... typedef struct 
.................... { 
....................     /*0*/   OST_UINT   bEventError        : 1; // Event error 
....................     /*1*/   OST_UINT   bError             : 1; // Task create error 
....................                                                // Stimer Create error 
....................     /*2*/   OST_UINT   bInCriticalSection : 1; // One of task is in critical 
....................                                                // section 
....................     /*3*/   OST_UINT   bCheckingTasks     : 1; // OS_Sched: 
....................                                                //   =1 - best task searching 
....................                                                //   =0 - best task executed 
....................     /*4*/   OST_UINT   bBestTaskFound     : 1; // OS_Sched: Best task found 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Processor specified bits 
....................     //------------------------------------------------------------------------------ 
....................             _OS_SYSTEM_FLAGS_PROC_SPEC()       // see definition in h-files for 
....................                                                // each processor type in "port" folder 
....................  
....................             #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................             OST_UINT   bEventOK           : 1; // Goes "1" when task was run after OS_Wait 
....................                                                // See OS_Sched definition 
....................                                                //  
....................                                                // Have #15 for PIC24 and dsPIC !!!! 
....................                                                //  
....................             #endif 
....................  
....................  
.................... } OST_SYSTEM_FLAGS; 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  Task state flags 
.................... //  
.................... //  !Do not change placement of theese bits 
.................... //****************************************************************************** 
....................  
....................  
.................... #ifndef OSA_TASK_STATE_PROC_SPEC 
.................... #define OSA_TASK_STATE_PROC_SPEC() 
.................... #endif 
....................  
.................... typedef          struct 
.................... { 
....................     /*0..2*/OST_UINT   cPriority   : 3;     // Task priority (0..7) 
....................     /*3*/   OST_UINT   bReady      : 1;     // Ready to execute 
....................     /*4*/   OST_UINT   bDelay      : 1;     // Timer active: OS_Delay (bCanContinue=0) 
....................                                             // or event waiting with timeout (bCanContinue=1) 
....................  
....................     /*5*/   OST_UINT   bCanContinue: 1;     // Can continue, while bDelay flag is set 
....................     /*6*/   OST_UINT   bEnable     : 1;     // Descriptor is busy by task 
....................     /*7*/   OST_UINT   bPaused     : 1;     // Task paused (it is still active, but can 
....................                                             // became ready only from extenal task) 
....................  
....................             OSA_TASK_STATE_PROC_SPEC()      // see definition in h-files for 
....................                                             // each processor type in "port" folder 
....................  
.................... } OST_TASK_STATE; 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_TASK_PRIORITY_MASK       0x07 
.................... #define OS_TASK_READY_MASK          0x08 
.................... #define OS_TASK_DELAY_MASK          0x10 
.................... #define OS_TASK_CANCONTINUE_MASK    0x20 
.................... #define OS_TASK_ENABLE_MASK         0x40 
.................... #define OS_TASK_PAUSED_MASK         0x80 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Task control block (descriptor) 
.................... //****************************************************************************** 
....................  
.................... typedef struct 
.................... { 
....................     OST_TASK_STATE      State;              // Current task state 
....................     OST_CODE_POINTER    pTaskPointer;       // ROM pointer 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Processor specified bits 
....................     //------------------------------------------------------------------------------ 
....................     _OS_TCB_PROC_SPEC()                     // see definition in h-files for 
....................                                             // each processor type in "port" folder 
....................  
....................     #ifdef OS_ENABLE_TTIMERS 
....................     OS_TTIMER_TYPE     Timer;               // Timer counter for delays 
....................     #endif 
....................  
.................... } OST_TCB;   // Task Control Block 
....................  
....................  
.................... #ifndef OST_TASK_POINTER 
.................... typedef OS_TASKS_BANK OST_TCB *     OST_TASK_POINTER; 
.................... #endif 
....................  
....................  
.................... #define OS_WORST_PRIORITY       7       // Lowest priority 
.................... #define OS_BEST_PRIORITY        0       // Highest priority 
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  T I M E R S   D A T A   T Y P E S                                                           * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Dynamic timers 
.................... //****************************************************************************** 
....................  
.................... //--------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Dynamic timer's state flags             * 
....................      *                                          * 
....................      *  !Do not change placement of variables   * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef  
....................     #ifndef __OSA_AVR_CODEVISION__ 
....................             volatile  
....................     #endif 
....................                         struct 
....................     { 
....................         OST_UINT   bTimeout    : 1;    // Overflow occured 
....................         OST_UINT   bActive     : 1;    // Timer is active (was created by OS_Dtimer_Create) 
....................                                        // (For system variable _OS_DTimers.Flags allways = 1) 
....................  
....................         OST_UINT   bRun        : 1;    // = 1 - Timer is counnting 
....................                                        // = 0 - Timer is stopped 
....................  
....................         OST_UINT   bNextEnable : 1;    // = 0 - last timer in list, 
....................                                        // = 1 - there is next timer 
....................     } OST_DTIMER_FLAGS; 
....................  
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Dynamic timer's descriptor              * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct S_OST_DTIMER 
....................     { 
....................         OST_DTIMER_FLAGS        Flags;       // Timer's state flags 
....................         struct S_OST_DTIMER    *Next;        // Pointer to next timer in list 
....................         OS_DTIMER_TYPE          Timer;       // Counter 
....................                                              //  
....................     } OST_DTIMER; 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Header of list of dynamic timers        * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct 
....................     { 
....................         OST_DTIMER_FLAGS        Flags; 
....................         struct S_OST_DTIMER    *Next;          // Pointer to first timer in list 
....................  
....................     } OST_DTIMER_CB; 
....................  
.................... //--------------------------------------------------------------- 
.................... #endif  // OS_ENABLE_DTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Queue of timers 
.................... //****************************************************************************** 
....................  
.................... //--------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_QTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Fast timer's state flags                * 
....................      *                                          * 
....................      *  !Do not change placement of variables   * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef  
....................     #ifndef __OSA_AVR_CODEVISION__ 
....................             volatile  
....................     #endif 
....................                         struct 
....................     { 
....................         OST_UINT   bTimeout      : 1;  // Overflow occured 
....................         OST_UINT   bActive       : 1;  // Timer is active (was created by OS_Dtimer_Create) 
....................                                        // (For system variable _OS_DTimers.Flags allways = 1) 
....................  
....................         OST_UINT   bRun          : 1;  // = 1 - Timer is counnting 
....................                                        // = 0 - Timer is stopped 
....................  
....................         OST_UINT   bNextEnable   : 1;  // = 0 - last timer in list, 
....................                                        // = 1 - there is next timer 
....................  
....................        //------------------------------// Functions for OS_Qtimer_List: 
....................                                        // 
....................         OST_UINT   bListFunction : 1;  // = 00 - add timer into the list 
....................                                        // = 01 - delete timer from the list 
....................         OST_UINT   bListGetTime  : 1;  // = 1x - get remaining time 
....................  
....................         //-----------------------------// Internal OS_Qtimer_List bits: 
....................         OST_UINT   bAddAfterDelete:1;  // = 1 - when adding already existing timer it 
....................                                        //       has to be deleted first 
....................  
....................  
....................     } OST_QTIMER_FLAGS; 
....................  
....................     #define OS_QTIMER_LIST_FUNCTION_ADD     0 
....................     #define OS_QTIMER_LIST_FUNCTION_DELETE  1 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Fast timer's control block              * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct S_OST_QTIMER 
....................     { 
....................         OST_QTIMER_FLAGS        Flags;         // Timer's state flags 
....................         struct S_OST_QTIMER    *Next;          // Pointer to next timer in list 
....................         OS_QTIMER_TYPE          Timer;         // Counter 
....................                                                //  
....................     } OST_QTIMER; 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Header of list of fast timers           * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct 
....................     { 
....................         OST_QTIMER_FLAGS        Flags; 
....................         struct S_OST_QTIMER    *Next;          // Pointer to first timer in list 
....................     } OST_QTIMER_CB; 
....................  
.................... //--------------------------------------------------------------- 
.................... #endif  // OS_ENABLE_QTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Counting semaphores 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_CSEM_SIZE) 
.................... #define OS_CSEM_SIZE    1 
.................... #endif 
....................  
.................... #if     OS_CSEM_SIZE == 1 
.................... typedef OST_UINT8   OST_CSEM; 
.................... #elif   OS_CSEM_SIZE == 2 
.................... typedef OST_UINT16  OST_CSEM; 
.................... #elif   OS_CSEM_SIZE == 4 
.................... typedef OST_UINT32  OST_CSEM; 
.................... #else 
....................     #error "OSA error #16: Incorrect OS_CSEM_SIZE value (m.b. only 1, 2 or 4)! (see OSAcfg.h)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  OSA system variables prototypes                                                             * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... extern  volatile OS_RAM_NEAR    OST_SYSTEM_FLAGS    _OS_Flags; 
.................... extern           OS_RAM_NEAR    OST_UINT            _OS_Temp; 
....................  
.................... #ifndef __OSA12__ 
.................... extern  volatile OS_RAM_NEAR    OST_UINT            _OS_TempH; 
.................... #endif 
....................  
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
.................... extern  volatile OS_RAM_NEAR    OST_TASK_STATE      _OS_State; 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to current task 
.................... //****************************************************************************** 
....................  
.................... #ifdef __OSA_CCS__ 
.................... // The CCS compiler do not allows to declare a volatile pointers 
.................... extern OST_TASK_POINTER OS_RAM_NEAR             _OS_CurTask; 
.................... #else 
.................... extern OST_TASK_POINTER OS_RAM_NEAR volatile    _OS_CurTask; 
.................... #endif 
....................  
....................  
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL 
....................  
....................     extern  OS_BANK          OST_UINT               _OS_Best_Priority; 
....................      
....................     #if defined(__OSA_CCS__) || defined(__OSA_IAR__) 
....................     // The CCS compiler do not allows to declare a volatile pointers 
....................     extern OST_TASK_POINTER OS_BANK                 _OS_BestTask; 
....................     extern OST_TASK_POINTER OS_BANK                 _OS_LastTask; 
....................     #else 
....................     extern OST_TASK_POINTER OS_BANK     volatile    _OS_BestTask; 
....................     extern OST_TASK_POINTER OS_BANK     volatile    _OS_LastTask; 
....................     #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................  
.................... /*  
....................     typedef union 
....................     {    
....................         struct  
....................         { 
....................             OST_UINT8   cPriority; 
....................             OST_UINT8   cTaskPos; 
....................         } Bytes; 
....................  
....................         OST_UINT16  Word; 
....................  
....................     } OST_TASK_QUEUE; 
.................... */ 
....................  
....................     extern  OS_BANK OST_UINT    _OS_Best_Priority; 
....................     extern  OS_BANK OST_UINT    _OS_Worst_Priority; 
....................     extern  OS_BANK OST_UINT    _OS_Best_n; 
....................     extern  OS_BANK OST_UINT    _OS_Cur_Pos; 
....................     extern  OS_BANK OST_UINT    _OS_n; 
....................     extern  OS_BANK OST_UINT8   _OS_TaskQueue[OS_TASKS];    // Queue of lesting in scheduler 
....................     extern  OS_BANK OST_UINT8   _OS_TaskLevel[OS_TASKS];    // Current priority levels 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Internal macro for work with state flags                                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
.................... */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(OS_CUR_FLAGS_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................  
....................     #define _OS_bTaskReady              _OS_State.bReady 
....................     #define _OS_bTaskCanContinue        _OS_State.bCanContinue 
....................     #define _OS_bTaskDelay              _OS_State.bDelay 
....................     #define _OS_bTaskTimeout            (!_OS_State.bDelay) 
....................     #define _OS_bTaskEnable             _OS_State.bEnable 
....................     #define _OS_cTaskPriority           _OS_State.cPriority 
....................     #define _OS_bTaskPaused             _OS_State.bPaused 
....................  
.................... #endif 
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_FSR) 
....................  
....................     #define _OS_bTaskReady              ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bReady 
....................     #define _OS_bTaskCanContinue        ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bCanContinue 
....................     #define _OS_bTaskDelay              ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bDelay 
....................     #define _OS_bTaskTimeout            (!((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bDelay) 
....................     #define _OS_bTaskEnable             ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bEnable 
....................     #define _OS_cTaskPriority           ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->cPriority 
....................     #define _OS_bTaskPaused             ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bPaused 
....................  
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_CUR_FLAGS_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Include definitions of services:                                                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... #include "kernel\osa_oldnames.h"            // Table of alternate names 
.................... /* 
....................  *********************************************************************************************** 
....................  *                                                                                               
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  *                                                                                               
....................  *  OSA is distributed under BSD license (see license.txt)                                       
....................  *                                                                                               
....................  *  URL:        http://wiki.pic24.ru/doku.php/en/osa/ref/intro                                   
....................  *              http://picosa.narod.ru                                                           
....................  *                                                                                               
....................  *---------------------------------------------------------------------------------------------- 
....................  *                                                                                               
....................  *  File:           osa_oldnames.h                                                               
....................  *                                                                                               
....................  *  Programmer:     Timofeev Victor                                                              
....................  *                  osa@pic24.ru, testerplus@mail.ru                                             
....................  *                                                                                               
....................  *  Definition:     This file contains old style names of OSA services. This file included       
....................  *                  automatically in OSA.h. This file is produced for compability with all       
....................  *                  programs written with old names.                                             
....................  *                                                                                               
....................  *  History:        26.02.2009  Added OS_ReserveTask and OS_TaskCreateP definitions              
....................  *                  22.07.2009  Added OS_Task_Define                                             
....................  *                  04.11.2009  All OS_SMsg_xxx renamed to OS_Smsg_xxx                           
....................  *                                                                                               
....................  *********************************************************************************************** 
....................  */ 
....................  
....................  
.................... #ifndef __OSA_NAMES_H 
.................... #define __OSA_NAMES_H 
....................  
....................  
.................... #define OST_PMSG                    OST_MSG_CB 
.................... #define OST_QMSG                    OST_QUEUE 
.................... #define OST_QSMSG                   OST_SQUEUE 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               System services                                                                */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
.................... //#define OS_Sched                    OS_Sched                    //   
.................... //#define OS_Run                      OS_Run                      //   
.................... //#define OS_Init                     OS_Init                     //   
.................... //#define OS_Timer                    OS_Timer                    //   
....................  
....................         /* Waiting */ 
....................  
.................... //#define OS_Yield                    OS_Yield                    //   
.................... //#define OS_Delay                    OS_Delay                    //  delaytime 
....................  
.................... #define OS_Cond_Wait(condition)                 OS_Wait(condition) 
.................... #define OS_Cond_Wait_TO(condition, timeout)     OS_Wait_TO(condition, timeout) 
....................  
.................... #define OS_WaitCondition            OS_Cond_Wait                //  condition 
.................... #define OS_WaitConditionTimeout     OS_Cond_Wait_TO             //  condition, timeout 
....................  
....................         /* Checking */ 
....................  
.................... //#define OS_IsTimeout                OS_IsTimeout                //   
.................... //#define OS_IsError                  OS_IsError                  //   
.................... //#define OS_IsEventError             OS_IsEventError             //   
.................... //#define OS_IsInCriticalSection      OS_IsInCriticalSection      //   
....................  
....................         /* Interrupts */ 
....................  
.................... //#define OS_EnterInt                 OS_EnterInt                 //   
.................... //#define OS_LeaveInt                 OS_LeaveInt                 //   
.................... //#define OS_DI                       OS_DI                       //   
.................... //#define OS_EI                       OS_EI                       //   
.................... //#define OS_RI                       OS_RI                       //  char 
.................... //#define OS_EnterCriticalSection     OS_EnterCriticalSection     //   
.................... //#define OS_LeaveCriticalSection     OS_LeaveCriticalSection     //   
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Task control services                                                          */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create, delete, pause */ 
....................  
.................... #define OS_CreateTask               OS_Task_Create              //  priority, TaskName 
.................... #define OS_ReplaceTask              OS_Task_Replace             //  priority, TaskName 
.................... #define OS_StopTask                 OS_Task_Stop                //   
.................... #define OS_DeleteTask               OS_Task_Delete              //  tp 
.................... #define OS_PauseTask                OS_Task_Pause               //  tp 
.................... #define OS_ContinueTask             OS_Task_Continue            //  tp 
.................... #define OS_ReserveTask              OS_Task_Reserve             //  tp 
.................... #define OS_CreateTaskP              OS_Task_CreateP             //  tp 
.................... #define OS_Task_Define              OS_Task_Reserve             //  TaskName       
....................  
....................         /* Priority control */ 
....................  
.................... #define OS_GetTaskPriority          OS_Task_GetPriority         //  tp 
.................... #define OS_SetTaskPriority          OS_Task_SetPriority         //  tp, priority 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_IsTaskPaused             OS_Task_IsPaused            //  tp 
.................... #define OS_IsTaskEnable             OS_Task_IsEnable            //  tp 
....................  
.................... //#define OS_GetCurTask               OS_GetCurTask               //   
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Binary semaphores                                                              */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Setting/resetting/checking */ 
....................  
.................... #define OS_SetBSem                  OS_Bsem_Set                 //  bsem 
.................... #define OS_SignalBSem               OS_Bsem_Signal              //  bsem 
.................... #define OS_ResetBSem                OS_Bsem_Reset               //  bsem 
.................... #define OS_SwitchBSem               OS_Bsem_Switch              //  bsem 
.................... #define OS_CheckBSem                OS_Bsem_Check               //  bsem 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitBSem                 OS_Bsem_Wait                //  bsem 
.................... #define OS_WaitBSemTimeout          OS_Bsem_Wait_TO             //  bsem, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Counting semaphores                                                            */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Creating */ 
....................  
.................... #define OS_CreateCSem               OS_Csem_Create              //  csem 
....................  
....................         /* Setting */ 
....................  
.................... #define OS_SignalCSem               OS_Csem_Signal              //  csem 
.................... #define OS_AcceptCSem               OS_Csem_Accept              //  csem 
.................... #define OS_SetCSem                  OS_Csem_Set                 //  csem 
.................... #define OS_SetCSemValue             OS_Csem_SetValue            //  csem, value 
.................... #define OS_ResetCSem                OS_Csem_Reset               //  csem 
....................  
....................         /* Interrupt */ 
....................  
.................... #define OS_IntSignalCSem            OS_Csem_Signal_I            //  csem 
.................... #define OS_IntAcceptCSem            OS_Csem_Accept_I            //  csem 
.................... #define OS_IntSetCSem               OS_Csem_Set_I               //  csem 
.................... #define OS_IntSetCSemValue          OS_Csem_SetValue_I          //  csem, value 
.................... #define OS_IntResetCSem             OS_Csem_Reset_I             //  csem 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckCSem                OS_Csem_Check               //  csem 
.................... #define OS_IntCheckCSem             OS_Csem_Check_I             //  csem 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitCSem                 OS_Csem_Wait                //  csem 
.................... #define OS_WaitCSemTimeout          OS_Csem_Wait_TO             //  csem, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Pointers to messages                                                           */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create */ 
....................  
.................... #define OS_CreateMsg                OS_Msg_Create               //  pmsg 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckMsg                 OS_Msg_Check                //  pmsg 
....................  
....................         /* Accepting */ 
....................  
.................... #define OS_AcceptMsg                OS_Msg_Accept               //  pmsg, os_msg_type_var 
....................  
....................         /* Posting */ 
....................  
.................... #define OS_SendMsg                  OS_Msg_Send                 //  pmsg, message 
.................... #define OS_SendMsgTimeout           OS_Msg_Send_TO              //  pmsg, message, timeout 
.................... #define OS_SendMsgNoWait            OS_Msg_Send_Now             //  pmsg, message 
.................... #define OS_IntSendMsgNoWait         OS_Msg_Send_I               //  pmsg, message 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitMsg                  OS_Msg_Wait                 //  pmsg, os_msg_type_var 
.................... #define OS_WaitMsgTimeout           OS_Msg_Wait_TO              //  pmsg, os_msg_type_var, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Simple messages                                                                */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Creating */ 
....................  
.................... #define OS_CreateSMsg               OS_Smsg_Create              //  smsg 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckSMsg                OS_Smsg_Check               //  smsg 
....................  
....................         /* Accepting */ 
....................  
.................... #define OS_AcceptSMsg               OS_Smsg_Accept              //  smsg, os_smsg_type_var 
....................  
....................         /* Posting */ 
....................  
.................... #define OS_SendSMsg                 OS_Smsg_Send                //  smsg, smessage 
.................... #define OS_SendSMsgTimeout          OS_Smsg_Send_TO             //  smsg, smessage, timeout 
.................... #define OS_SendSMsgNoWait           OS_Smsg_Send_Now            //  smsg, smessage 
.................... #define OS_IntSendSMsgNoWait        OS_Smsg_Send_I              //  smsg, smessage 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitSMsg                 OS_Smsg_Wait                //  smsg, os_smsg_type_var 
.................... #define OS_WaitSMsgTimeout          OS_Smsg_Wait_TO             //  smsg, os_smsg_type_var, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Queues of pointers to messages                                                 */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create */ 
....................  
.................... #define OS_CreateQMsg               OS_Queue_Create             //  qmsg, buffer, size 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckQMsg                OS_Queue_Check              //  qmsg 
.................... #define OS_IsQMsgFull               OS_Queue_IsFull             //  qmsg 
.................... #define OS_IsQMsgFree               OS_Queue_IsFree             //  qsmsg 
....................  
....................         /* Posting */ 
....................  
.................... #define OS_SendQMsg                 OS_Queue_Send               //  qmsg, message 
.................... #define OS_SendQMsgTimeout          OS_Queue_Send_TO            //  qmsg, message, timeout 
.................... #define OS_SendQMsgNoWait           OS_Queue_Send_Now           //  qmsg, message 
.................... #define OS_IntSendQMsgNoWait        OS_Queue_Send_I             //  qmsg, message 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitQMsg                 OS_Queue_Wait               //  qmsg, os_msg_type_var 
.................... #define OS_WaitQMsgTimeout          OS_Queue_Wait_TO            //  qmsg, os_msg_type_var, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Queues of simple messages                                                      */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create */ 
....................  
.................... #define OS_CreateQSMsg              OS_SQueue_Create            //  qsmsg, buffer, size 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckQSMsg               OS_SQueue_Check             //  qsmsg 
.................... #define OS_IsQSMsgFull              OS_SQueue_IsFull            //  qsmsg 
.................... #define OS_IsQSMsgFree              OS_SQueue_IsFree            //  qsmsg 
....................  
....................         /* Posting */ 
....................  
.................... #define OS_SendQSMsg                OS_SQueue_Send              //  qsmsg, smessage 
.................... #define OS_SendQSMsgTimeout         OS_SQueue_Send_TO           //  qsmsg, smessage, timeout 
.................... #define OS_SendQSMsgNoWait          OS_SQueue_Send_Now          //  qsmsg, smessage 
.................... #define OS_IntSendQSMsgNoWait       OS_SQueue_Send_I            //  qsmsg, smessage 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitQSMsg                OS_SQueue_Wait              //  qsmsg, os_smsg_type_var 
.................... #define OS_WaitQSMsgTimeout         OS_SQueue_Wait_TO           //  qsmsg, os_smsg_type_var, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Flags                                                                          */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create */ 
....................  
.................... #define OS_CreateFlag               OS_Flag_Create              //  flags 
....................  
....................         /* Setting */ 
....................  
.................... #define OS_InitFlag                 OS_Flag_Init                //  flags, value 
.................... #define OS_SetFlag                  OS_Flag_Set_1               //  flags, mask 
.................... #define OS_ClearFlag                OS_Flag_Set_0               //  flags, mask 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckAllFlag             OS_Flag_Check_11            //  flags, mask 
.................... #define OS_CheckAnyFlag             OS_Flag_Check_1x            //  flags, mask 
.................... #define OS_CheckAllFlagClear        OS_Flag_Check_00            //  flags, mask 
.................... #define OS_CheckAnyFlagClear        OS_Flag_Check_0x            //  flags, mask 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitAllFlag              OS_Flag_Wait_11             //  flags, mask 
.................... #define OS_WaitAnyFlag              OS_Flag_Wait_1x             //  flags, mask 
.................... #define OS_WaitAllFlagClear         OS_Flag_Wait_00             //  flags, mask 
.................... #define OS_WaitAnyFlagClear         OS_Flag_Wait_0x             //  flags, mask 
.................... #define OS_WaitAllFlagTimeout       OS_Flag_Wait_11_TO          //  flags, mask, timeout 
.................... #define OS_WaitAnyFlagTimeout       OS_Flag_Wait_1x_TO          //  flags, mask, timeout 
.................... #define OS_WaitAllFlagClearTimeout  OS_Flag_Wait_00_TO          //  flags, mask, timeout 
.................... #define OS_WaitAnyFlagClearTimeout  OS_Flag_Wait_0x_TO          //  flags, mask, timeout 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Dynamic timers                                                                 */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Create/Delete */ 
....................  
.................... #define OS_CreateDTimer             OS_Dtimer_Create            //  ptimer 
.................... #define OS_DeleteDTimer             OS_Dtimer_Delete            //  ptimer 
....................  
....................         /* Run/stop/pause */ 
....................  
.................... #define OS_RunDTimer                OS_Dtimer_Run               //  ptimer, newtime 
.................... #define OS_StopDTimer               OS_Dtimer_Stop              //  ptimer 
.................... #define OS_PauseDTimer              OS_Dtimer_Pause             //  ptimer 
.................... #define OS_ContinueDTimer           OS_Dtimer_Continue          //  ptimer 
.................... #define OS_BreakDTimer              OS_Dtimer_Break             //  ptimer 
....................  
....................         /* Updating */ 
....................  
.................... #define OS_UpdateDTimer             OS_Dtimer_Update            //  ptimer, time 
.................... #define OS_AddDTimer                OS_Dtimer_Add               //  ptimer, addtime 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_GetDTimer                OS_Dtimer_Get               //  ptimer 
.................... #define OS_CheckDTimer              OS_Dtimer_Check             //  ptimer 
.................... #define OS_IsDTimerActive           OS_Dtimer_IsActive          //  ptimer 
.................... #define OS_IsDTimerStopped          OS_Dtimer_IsStopped         //  ptimer 
.................... #define OS_IsDTimerRun              OS_Dtimer_IsRun             //  ptimer 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitDTimer               OS_Dtimer_Wait              //  ptimer 
.................... #define OS_DelayDTimer              OS_Dtimer_Delay             //  ptimer, delay 
....................  
....................  
....................  
....................  
.................... #define OS_CheckPTimer      OS_Dtimer_Check 
.................... #define OS_IsPTimerActive   OS_Dtimer_IsActive 
.................... #define OS_IsPTimerStopped  OS_Dtimer_IsStopped 
.................... #define OS_IsPTimerRun      OS_Dtimer_IsRun 
.................... #define OS_GetPTimer        OS_Dtimer_Get 
.................... #define OS_StopPTimer       OS_Dtimer_Stop 
.................... #define OS_PausePTimer      OS_Dtimer_Pause 
.................... #define OS_ContinuePTimer   OS_Dtimer_Continue 
.................... #define OS_BreakPTimer      OS_Dtimer_Break 
.................... #define OS_RunPTimer        OS_Dtimer_Run 
.................... #define OS_UpdatePTimer     OS_Dtimer_Update 
.................... #define OS_AddPTimer        OS_Dtimer_Add 
.................... #define OS_WaitPTimer       OS_Dtimer_Wait 
.................... #define OS_DelayPTimer      OS_Dtimer_Delay 
.................... #define OS_CreatePTimer     OS_Dtimer_Create 
.................... #define OS_DeletePTimer     OS_Dtimer_Delete 
.................... #define OST_PTIMER          OST_DTIMER 
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Static timers                                                                  */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Run/stop/pause */ 
....................  
.................... #define OS_RunSTimer                OS_Stimer_Run               //  stimer_id, time 
.................... #define OS_StopSTimer               OS_Stimer_Stop              //  stimer_id 
.................... #define OS_PauseSTimer              OS_Stimer_Pause             //  stimer_id 
.................... #define OS_ContinueSTimer           OS_Stimer_Continue          //  stimer_id 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_GetSTimer                OS_Stimer_Get               //  stimer_id 
.................... #define OS_CheckSTimer              OS_Stimer_Check             //  stimer_id 
.................... #define OS_IsSTimerRun              OS_Stimer_IsRun             //  stimer_id 
....................  
....................         /* Waiting  */ 
....................  
.................... #define OS_WaitSTimer               OS_Stimer_Wait              //  stimer_id 
.................... #define OS_DelaySTimer              OS_Stimer_Delay             //  stimer_id, delay 
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*               Old style static timers                                                        */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
....................         /* Run */ 
....................  
.................... #define OS_RunTimer8                OS_Oldtimer_Run8            //  timer8_id, time 
.................... #define OS_RunTimer16               OS_Oldtimer_Run16           //  timer16_id, time 
.................... #define OS_RunTimer24               OS_Oldtimer_Run24           //  timer24_id, time 
.................... #define OS_RunTimer32               OS_Oldtimer_Run32           //  timer32_id, time 
....................  
....................         /* Stop */ 
....................  
.................... #define OS_StopTimer                OS_Oldtimer_Pause           //  timer_id 
....................  
....................         /* Checking */ 
....................  
.................... #define OS_CheckTimer               OS_Oldtimer_Check           //  timer_id 
....................  
....................         /* Waiting */ 
....................  
.................... #define OS_WaitTimer                OS_Oldtimer_Wait            //  timer_id 
....................  
....................  
....................  
.................... #endif 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_oldnames.h 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #include "kernel\system\osa_system.h"       // System services 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_system.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Kernel definitions and services 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Function prototypes 
.................... //****************************************************************************** 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // System variables initialization 
.................... extern void  OS_Init (void); 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Critical sections 
.................... extern void OS_EnterCriticalSection (void); 
.................... extern void OS_LeaveCriticalSection (void); 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Macro definitions 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                      S H C E D U L E R                                       * 
....................  *                                                                                              * 
....................  *                      !!!(Sheduler for MCC30 is in "port\osa_mcc30.h")!!!                     * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef OS_Sched 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... #define _OS_SCHED_LABEL_SCHED_CONTINUE      _OS_SCHED_CONTINUE:; 
....................  
.................... #define _OS_IF_NOT_TASK_ENABLE_CONTINUE()   if (!_OS_bTaskEnable || _OS_bTaskPaused) goto _OS_SCHED_CONTINUE; 
....................  
.................... #define _OS_IF_NOT_TASK_READY()             if (!_OS_bTaskReady) 
....................  
.................... #define _OS_IF_TASK_READY()                 if (_OS_bTaskReady) 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_TTIMERS 
....................  
....................     #define _OS_SCHED_IF_DELAIED_GOTO_CONTINUE()   if (_OS_bTaskDelay && !_OS_bTaskCanContinue) goto _OS_SCHED_CONTINUE; 
.................... #else 
....................  
....................     #define _OS_SCHED_IF_DELAIED_GOTO_CONTINUE() 
....................  
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef _OS_SET_STATE   /*see osa_stm8_iar.h for details one this definition */ 
.................... //------------------------------------------------------------------------------ 
....................     #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................     //------------------------------------------------------------------------------ 
....................      
....................         #define _OS_SET_STATE()     _OS_State = _OS_CurTask->State 
....................         #define _OS_RESTORE_STATE() 
....................      
....................     //------------------------------------------------------------------------------ 
....................     #else 
....................     //------------------------------------------------------------------------------ 
....................      
....................         #define _OS_SET_STATE()     _OS_SET_FSR_CUR_TASK() 
....................         #define _OS_RESTORE_STATE() _OS_SET_FSR_CUR_TASK() 
....................      
....................     //------------------------------------------------------------------------------ 
....................     #endif 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if (OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     /******************************************************************************************** 
....................      *                                                                                          * 
....................      *     N O R M A L     P R I O R I T Y     M O D E     S C H E D U L E R                    *  
....................      *                                                                                          * 
....................      ********************************************************************************************/ 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     #ifdef OS_ENABLE_CRITICAL_SECTION 
....................      
....................         #define _OS_SCHED_SKIP_IF_CRITICAL_SECTION() if (OS_IsInCriticalSection()) goto _OS_SCHED_CHECK_READY; 
....................         #define _OS_SCHED_LABEL_CHECK_READY          _OS_SCHED_CHECK_READY: 
....................         #define _OS_NOT_IN_CRITICAL_SECTION()        !OS_IsInCriticalSection() 
....................      
....................     #else 
....................      
....................         #define _OS_SCHED_SKIP_IF_CRITICAL_SECTION() 
....................         #define _OS_SCHED_LABEL_CHECK_READY 
....................         #define _OS_NOT_IN_CRITICAL_SECTION()           1 
....................      
....................     #endif 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_IsIdle()     (!OS_IsInCriticalSection() && !_OS_Flags.bBestTaskFound) 
....................  
....................     #define OS_Sched()                                                                          \ 
....................     {                                                                                           \ 
....................                                                                                                 \ 
....................         /* First we suppose that there is no ready task*/                                       \ 
....................         _OS_Flags.bBestTaskFound = 0;                                                           \ 
....................         /* MODE: Search of best task                  */                                        \ 
....................         _OS_Flags.bCheckingTasks = 1;                                                           \ 
....................         /* Worst of lowest priority                   */                                        \ 
....................         _OS_Best_Priority = OS_WORST_PRIORITY + 1;                                              \ 
....................         _OS_SCHED_SKIP_IF_CRITICAL_SECTION();                                                   \ 
....................         /* List all tasks starting from last executed   */                                      \ 
....................         _OS_CurTask = _OS_LastTask;                                                             \ 
....................         do                                                                                      \ 
....................         {                                                                                       \ 
....................             if (_OS_CurTask >= (OST_TASK_POINTER)_OS_Tasks + (OS_TASKS-1))                      \ 
....................                 _OS_CurTask = (OST_TASK_POINTER)_OS_Tasks;                                      \ 
....................             else                                                                                \ 
....................                 _OS_CurTask++;                                                                  \ 
....................                                                                                                 \ 
....................     _OS_SCHED_LABEL_CHECK_READY                                                                 \ 
....................                                                                                                 \ 
....................             _OS_SET_STATE();                                                                    \ 
....................             _OS_IF_NOT_TASK_ENABLE_CONTINUE();                       /* Skip empty descriptor */\ 
....................             if (_OS_Best_Priority <= (_OS_Temp = _OS_cTaskPriority)) goto _OS_SCHED_CONTINUE;   \ 
....................             _OS_IF_NOT_TASK_READY()                                                             \ 
....................             {                                                                                   \ 
....................                 /* Task is not ready yet. Check for it has became ready    */                   \ 
....................     _OS_SCHED_RUN:;                                                                             \ 
....................                 _OS_JUMP_TO_TASK();                                                             \ 
....................                 _OS_BACK_TO_SCEDULER();                                                         \ 
....................                 if (!_OS_Flags.bCheckingTasks) goto SCHED_END;                                  \ 
....................                 _OS_RESTORE_STATE();                                                            \ 
....................             }                                                                                   \ 
....................             /* Skip if task is delayed              */                                          \ 
....................             _OS_SCHED_IF_DELAIED_GOTO_CONTINUE();                                               \ 
....................             /* Compare priority for all ready tasks      */                                     \ 
....................             _OS_IF_TASK_READY()                                                                 \ 
....................             {                                                                                   \ 
....................                 _OS_Flags.bBestTaskFound = 1;                                                   \ 
....................                 _OS_BestTask = _OS_CurTask;                                                     \ 
....................                 _OS_Best_Priority = _OS_cTaskPriority;                                          \ 
....................                                                                                                 \ 
....................                 /* If this task has highest priority then stop searching */                     \ 
....................                 if (_OS_Best_Priority == OS_BEST_PRIORITY) break;                               \ 
....................             }                                                                                   \ 
....................                                                                                                 \ 
....................     _OS_SCHED_LABEL_SCHED_CONTINUE                                                              \ 
....................                                                                                                 \ 
....................         } while (_OS_NOT_IN_CRITICAL_SECTION() && _OS_CurTask != _OS_LastTask);                 \ 
....................                                                                                                 \ 
....................         /* If there is at least one ready task, then execute it */                              \ 
....................                                                                                                 \ 
....................         if (_OS_Flags.bBestTaskFound)                                                           \ 
....................         {                                                                                       \ 
....................             _OS_Flags.bCheckingTasks = 0; /* MODE: executing best task    */                    \ 
....................             _OS_LastTask = _OS_CurTask = _OS_BestTask;                                          \ 
....................             _OS_SET_STATE();                                                                    \ 
....................             if (_OS_bTaskEnable && !_OS_bTaskPaused) goto _OS_SCHED_RUN;                        \ 
....................         }                                                                                       \ 
....................                                                                                                 \ 
....................     SCHED_END:;                                                                                 \ 
....................                                                                                                 \ 
....................     }                                                                                           \ 
....................  
....................     //------------------------------------------------------------------------------------------- 
....................     // Explaining of some moments: 
....................     // 
....................     // 1.  OS_Temp used here to reduce used RAM by 1 byte. Compiler while comparing 
....................     //     _OS_Best_Priority with (indf&7) generates one temporary variable. We set it manualy, 
....................     //     so compiler will not use local variable. 
....................     // 
....................     //------------------------------------------------------------------------------------------- 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_PRIORITY_NORMAL 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if (OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................      
....................     #ifndef _OS_UPDATE_TASK_QUEUE 
....................     #define _OS_UPDATE_TASK_QUEUE()                                                         \ 
....................                 _OS_n = _OS_Best_n;                                                         \ 
....................                 while (_OS_n)                                                               \ 
....................                 {                                                                           \ 
....................                     _OS_TaskQueue[_OS_n] = _OS_TaskQueue[_OS_n-1];                          \ 
....................                     _OS_n--;                                                                \ 
....................                 }                                                                           \ 
....................                 _OS_TaskQueue[0] = _OS_Cur_Pos; 
....................     #endif 
....................  
....................     //------------------------------------------------------------------------------ 
....................  
....................     #ifndef _OS_INC_PRIORITY 
....................     #define _OS_INC_PRIORITY()                                                              \ 
....................                 if (!(_OS_Temp & 0x80))                                                     \ 
....................                 {                                                                           \ 
....................                     _OS_Temp += 8;                                                          \ 
....................                     _OS_Temp -= _OS_CurTask->State.cPriority;                               \ 
....................                     _OS_TaskLevel[_OS_Cur_Pos] = _OS_Temp;                                  \ 
....................                 }                                                                           \ 
....................  
....................     #endif 
....................  
....................     //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................     /******************************************************************************************** 
....................      *                                                                                          * 
....................      *     E X T E N D E D    P R I O R I T Y    M O D E    S C H E D U L E R                   *  
....................      *                                                                                          * 
....................      ********************************************************************************************/ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #ifdef OS_ENABLE_CRITICAL_SECTION 
....................      
....................         #define _OS_SCHED_SKIP_IF_CRITICAL_SECTION()    if (OS_IsInCriticalSection()) goto _OS_SCHED_CHECK_READY; 
....................         #define _OS_SCHED_LABEL_CHECK_READY             _OS_SCHED_CHECK_READY: 
....................         #define _OS_NOT_IN_CRITICAL_SECTION()           !OS_IsInCriticalSection() 
....................      
....................     #else 
....................      
....................         #define _OS_SCHED_SKIP_IF_CRITICAL_SECTION() 
....................         #define _OS_SCHED_LABEL_CHECK_READY 
....................         #define _OS_NOT_IN_CRITICAL_SECTION()           1 
....................      
....................     #endif 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_IsIdle()     (!OS_IsInCriticalSection() && !_OS_Flags.bBestTaskFound) 
....................  
....................     #define OS_Sched()                                                                          \ 
....................     {                                                                                           \ 
....................                                                                                                 \ 
....................         /* First we suppose that there is no ready task*/                                       \ 
....................         _OS_Flags.bBestTaskFound = 0;                                                           \ 
....................         /* MODE: Search of best task                  */                                        \ 
....................         _OS_Flags.bCheckingTasks = 1;                                                           \ 
....................         /* Worst of lowest priority                   */                                        \ 
....................         _OS_Best_Priority = 0;                                                                  \ 
....................         _OS_Worst_Priority = 0;                                                                 \ 
....................                                                                                                 \ 
....................         _OS_SCHED_SKIP_IF_CRITICAL_SECTION();                                                   \ 
....................                                                                                                 \ 
....................         _OS_n = OS_TASKS;                                                                       \ 
....................         do                                                                                      \ 
....................         {                                                                                       \ 
....................             _OS_Cur_Pos = _OS_TaskQueue[_OS_n-1];                                               \ 
....................                                                                                                 \ 
....................     _OS_SCHED_LABEL_CHECK_READY                                                                 \ 
....................             _OS_CurTask = &_OS_Tasks[_OS_Cur_Pos];                                              \ 
....................                                                                                                 \ 
....................             _OS_SET_STATE();                                                                    \ 
....................             _OS_IF_NOT_TASK_ENABLE_CONTINUE();                       /* Skip empty descriptor */\ 
....................             _OS_IF_NOT_TASK_READY()                                                             \ 
....................             {                                                                                   \ 
....................                 /* Task is not ready yet. Check for it has became ready    */                   \ 
....................     _OS_SCHED_RUN:;                                                                             \ 
....................                 _OS_JUMP_TO_TASK();                                                             \ 
....................                 _OS_BACK_TO_SCEDULER();                                                         \ 
....................                 _OS_RESTORE_STATE();                                                            \ 
....................                                                                                                 \ 
....................                 if (!_OS_Flags.bCheckingTasks)                                                  \ 
....................                 {                                                                               \ 
....................                     if (_OS_bTaskReady || _OS_Flags.bEventOK)                                   \ 
....................                     {                                                                           \ 
....................                         _OS_TaskLevel[_OS_Cur_Pos] -= _OS_Worst_Priority;                       \ 
....................                         _OS_UPDATE_TASK_QUEUE();                                                \ 
....................                     }                                                                           \ 
....................                     goto SCHED_END;                                                             \ 
....................                 }                                                                               \ 
....................             }                                                                                   \ 
....................                                                                                                 \ 
....................             /* Skip if task is delayed              */                                          \ 
....................             _OS_SCHED_IF_DELAIED_GOTO_CONTINUE();                                               \ 
....................                                                                                                 \ 
....................             /* Compare priority for all ready tasks      */                                     \ 
....................             _OS_IF_TASK_READY()                                                                 \ 
....................             {                                                                                   \ 
....................                 _OS_Temp = _OS_TaskLevel[_OS_Cur_Pos];                                          \ 
....................                 _OS_INC_PRIORITY();                                                             \ 
....................                 if (_OS_Temp > _OS_Best_Priority)                                               \ 
....................                 {                                                                               \ 
....................                     _OS_Worst_Priority = _OS_Best_Priority;                                     \ 
....................                     _OS_Best_Priority = _OS_Temp;                                               \ 
....................                     _OS_Best_n = _OS_n-1;                                                       \ 
....................                     _OS_Flags.bBestTaskFound = 1;                                               \ 
....................                 }                                                                               \ 
....................                 else if (_OS_Temp > _OS_Worst_Priority)                                         \ 
....................                 {                                                                               \ 
....................                     _OS_Worst_Priority = _OS_Temp;                                              \ 
....................                 }                                                                               \ 
....................             }                                                                                   \ 
....................                                                                                                 \ 
....................     _OS_SCHED_LABEL_SCHED_CONTINUE                                                              \ 
....................                                                                                                 \ 
....................         } while (_OS_NOT_IN_CRITICAL_SECTION() && --_OS_n);                                     \ 
....................                                                                                                 \ 
....................         /* If there is at least one ready task, then execute it */                              \ 
....................                                                                                                 \ 
....................         if (_OS_Flags.bBestTaskFound)                                                           \ 
....................         {                                                                                       \ 
....................             _OS_Flags.bCheckingTasks = 0; /* MODE: executing best task    */                    \ 
....................             _OS_Flags.bEventOK = 0;                                                             \ 
....................             _OS_Cur_Pos = _OS_TaskQueue[_OS_Best_n];                                            \ 
....................             _OS_CurTask = &_OS_Tasks[_OS_Cur_Pos];                                              \ 
....................             _OS_SET_STATE();                                                                    \ 
....................             if (_OS_bTaskEnable && !_OS_bTaskPaused) goto _OS_SCHED_RUN;                        \ 
....................         }                                                                                       \ 
....................                                                                                                 \ 
....................     SCHED_END:;                                                                                 \ 
....................                                                                                                 \ 
....................     }                                                                                           \ 
....................  
....................     //------------------------------------------------------------------------------------------- 
....................     // Explaining of some moments: 
....................     // 
....................     // 1.  OS_Temp used here to reduce used RAM by 1 byte. Compiler while comparing 
....................     //     _OS_Best_Priority with (indf&7) generates one temporary variable. We set it manualy, 
....................     //     so compiler will not use local variable. 
....................     // 
....................     //------------------------------------------------------------------------------------------- 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_PRIORITY_EXTENDED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED 
.................... //------------------------------------------------------------------------------ 
....................  
....................     /******************************************************************************************** 
....................      *                                                                                          * 
....................      *     N O N   P R I O R I T Y   M O D E   S C H E D U L E R                                * 
....................      *                                                                                          * 
....................      ********************************************************************************************/ 
....................  
....................     #define OS_IsIdle()     0 
....................  
....................     //------------------------------------------------------------------------------------------- 
....................     // 
....................     // Non priority mode can be used when there is no need to give more preference to 
....................     // some tasks. (For example there are no time rcitical code). This mode allows to reduce ROM 
....................     // and RAM usage and also increases speed of // scheduler work in OS_TASKS times 
....................     // 
....................     //------------------------------------------------------------------------------------------- 
....................  
....................  
....................     #ifdef OS_ENABLE_CRITICAL_SECTION 
....................         #define _OS_IF_NOT_IN_CRITICAL_SECTION()        if (!OS_IsInCriticalSection()) 
....................     #else 
....................         #define _OS_IF_NOT_IN_CRITICAL_SECTION() 
....................     #endif 
....................  
....................     #define OS_Sched()                                                                          \ 
....................     {                                                                                           \ 
....................         _OS_Temp = 0;                                                                           \ 
....................                                                                                                 \ 
....................         _OS_IF_NOT_IN_CRITICAL_SECTION()                                                        \ 
....................         {                                                                                       \ 
....................             if (_OS_CurTask >= (OST_TASK_POINTER)_OS_Tasks + (OS_TASKS-1))                      \ 
....................                 _OS_CurTask = (OST_TASK_POINTER)_OS_Tasks;                                      \ 
....................             else                                                                                \ 
....................                 _OS_CurTask++;                                                                  \ 
....................         }                                                                                       \ 
....................                                                                                                 \ 
....................         _OS_SET_STATE();                                                                        \ 
....................                                                                                                 \ 
....................         /* Skip empty descriptor              */                                                \ 
....................         if (!_OS_bTaskEnable || _OS_bTaskPaused) goto _OS_SCHED_CONTINUE;                       \ 
....................                                                                                                 \ 
....................         _OS_SCHED_IF_DELAIED_GOTO_CONTINUE();                                                   \ 
....................                                                                                                 \ 
....................         _OS_JUMP_TO_TASK();                                                                     \ 
....................         _OS_BACK_TO_SCEDULER();                                                                 \ 
....................                                                                                                 \ 
....................     _OS_SCHED_CONTINUE:;                                                                        \ 
....................                                                                                                 \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif     //   OS_PRIORITY_DISABLED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // ifndef OS_Shed 
.................... //------------------------------------------------------------------------------ 
....................  
.................... /************************************************************************************************/ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     C O M M O N   S Y S T E M   S E R V I C E S                                              * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... #define OS_Run()    for(;;) OS_Sched() 
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Check for timeout expired in last service                            */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_IsTimeout()              _OS_Flags.bTimeout 
....................  
.................... /************************************************************************/ 
.................... /* Check for one of task is in critical section                         */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_IsInCriticalSection()    _OS_Flags.bInCriticalSection 
....................  
....................  
.................... /************************************************************************/ 
.................... // Check for object creation error (task, stimers) 
.................... /************************************************************************/ 
....................  
.................... #define OS_IsError()                _OS_Flags.bError 
....................  
.................... /************************************************************************/ 
.................... // Check for event error 
.................... /************************************************************************/ 
....................  
.................... #define OS_IsEventError()           _OS_Flags.bEventError 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                    I N T E R R U P T S                                       * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Enable/disable/restore interrupts are in h-files for each processor 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSA_PIC16_HTPICC__) || defined(__OSA_PIC18_HTPICC__)     
.................... //------------------------------------------------------------------------------ 
....................  
....................     /************************************************************************/ 
....................     /*                                                                      */ 
....................     /* This service must be called in the begin of ISR                      */ 
....................     /*                                                                      */ 
....................     /************************************************************************/ 
....................  
....................     #define OS_EnterInt()                                   \ 
....................         static OS_FSR_TYPE   _OS_FSR_Temp;                  \ 
....................         _OS_FSR_Temp = _fsr;                                \ 
....................  
....................     /************************************************************************/ 
....................     /*                                                                      */ 
....................     /* This service must be called at the end of ISR                        */ 
....................     /*                                                                      */ 
....................     /************************************************************************/ 
....................  
....................     #define OS_LeaveInt()   _fsr = _OS_FSR_Temp 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #define OS_EnterInt() 
....................     #define OS_LeaveInt() 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                      C O N T E X T    S W I T C H I N G                                      *  
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
....................  
.................... /************************************************************************************ 
....................  * 
....................  *  All context switches are based one five macros: 
....................  *  
....................  *  _OS_RETURN_SAVE()         - save context and return to scheduler 
....................  *  
....................  *  _OS_RETURN_NO_SAVE()      - returning to scheduler without saving context 
....................  *  
....................  *  _OS_ENTER_WAIT_MODE()     - switch the task to wait mode 
....................  *  
....................  *  _OS_ENTER_WAIT_MODE_TO()  - switch the task to wait mode with exit on timeout 
....................  *  
....................  *  _OS_CHECK_EVENT()         - check for event is true. Continue task execution if 
....................  *                              then event is true, or switch context otherwise 
....................  *  
....................  *  See definitions of these macros for each compiler in specific .h-files (in the 
....................  *  "port" folder) 
....................  * 
....................  ************************************************************************************/ 
....................  
....................  
.................... #define OS_Yield()                          _OS_RETURN_SAVE() 
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *   Put task in wait mode till "event" will not became true                    * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #define OS_Wait(event)                              \ 
.................... {                                                   \ 
....................     _OS_ENTER_WAIT_MODE();                          \ 
....................     _OS_CHECK_EVENT((event) != 0);                  \ 
.................... } 
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *   Put task in wait mode till "event" will not became true or timeout will not* 
....................  *   expired                                                                    * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #define OS_Wait_TO(event, timeout)                  \ 
.................... {                                                   \ 
....................     _OS_InitDelay(timeout);                         \ 
....................     _OS_ENTER_WAIT_MODE_TO();                       \ 
....................     _OS_CHECK_EVENT((event) != 0);                  \ 
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_system.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\system\osa_tasks.h"        // Tasks 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_tasks.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for work with tasks  
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                   T A S K S                                                  * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... extern OS_TASKS_BANK    OST_TCB  _OS_Tasks[OS_TASKS]; 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
.................... void _OS_Task_Create(OST_UINT priority, OST_CODE_POINTER TaskAddr); 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Macro definitions 
.................... //****************************************************************************** 
....................  
.................... #if defined(OS_PROTECT_MEMORY_ACCESS) 
....................     #define __OS_TASK_DI_A()  _OS_DI_INT() 
....................     #define __OS_TASK_RI_A()  _OS_RI_INT() 
.................... #else 
....................     #define __OS_TASK_DI_A() 
....................     #define __OS_TASK_RI_A() 
.................... #endif 
....................  
....................  
.................... #define _OS_TASK_ATOMIC_WRITE_A(expr)       \ 
....................     OSM_BEGIN {                             \ 
....................         __OS_TASK_DI_A();                   \ 
....................         expr;                               \ 
....................         __OS_TASK_RI_A();                   \ 
....................     } OSM_END 
....................  
.................... #define _OS_TASK_ATOMIC_READ_A(expr)                                            \ 
....................     (__OS_TASK_DI_A(), _OS_Temp = (expr), __OS_TASK_RI_A(), _OS_Temp)           \ 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef _OS_CUR_FLAGS_IN_OS_STATE             
.................... //------------------------------------------------------------------------------ 
....................  
....................     // for cases when working with State through _OS_State 
....................  
....................     #define __OS_CLEAR_STATE_ENABLE()               _OS_TASK_ATOMIC_WRITE_A(_OS_State.bEnable = 0) 
....................     #define __OS_SET_STATE_PAUSE()                  _OS_TASK_ATOMIC_WRITE_A(_OS_State.bPaused = 1) 
....................     #define __OS_SET_STATE_PRIORITY(new_priority)   _OS_TASK_ATOMIC_WRITE_A(_OS_State.cPriority = new_priority) 
....................  
.................... #else    
....................      
....................     // for cases when working with State through INDF 
....................  
....................     #define __OS_CLEAR_STATE_ENABLE() 
....................     #define __OS_SET_STATE_PAUSE() 
....................     #define __OS_SET_STATE_PRIORITY(new_priority) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
.................... #define this_task   _OS_CurTask 
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Stop current task                                                    */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Task_Stop()   OS_Task_Delete(this_task) 
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Delete task                                                          */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSACCS__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Delete(pTask)                                           \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A(pTask->State.bEnable = 0);              \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_CLEAR_STATE_ENABLE();                                  \ 
....................                 _OS_RETURN_NO_SAVE();                                       \ 
....................             }                                                               \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Delete(pTask)                                           \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A((pTask)->State.bEnable &= ~1);          \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_CLEAR_STATE_ENABLE();                                  \ 
....................                 _OS_RETURN_NO_SAVE();                                       \ 
....................             }                                                               \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Delete(pTask)                                           \ 
....................         {                                                                   \ 
....................             _OS_SET_IRP_CUR_TASK();   /* for mikroC for PIC16 only */       \ 
....................             _OS_TASK_ATOMIC_WRITE_A((pTask)->State.bEnable = 0);            \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_CLEAR_STATE_ENABLE();                                  \ 
....................                 _OS_CLR_IRP();                  /* for mikroC PIC16 only */ \ 
....................                 _OS_RETURN_NO_SAVE();                                       \ 
....................             }                                                               \ 
....................             _OS_CLR_IRP();       /* for mikroC PIC16 only */                \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Pause task                                                           */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSACCS__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Pause(pTask)                                            \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A(pTask->State.bPaused = 1);              \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_SET_STATE_PAUSE();                                     \ 
....................                 OS_Yield();                                                 \ 
....................             }                                                               \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Pause(pTask)                                            \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A((pTask)->State.bPaused != 1);           \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_SET_STATE_PAUSE();                                     \ 
....................                 OS_Yield();                                                 \ 
....................             }                                                               \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Pause(pTask)                                            \ 
....................         {                                                                   \ 
....................             _OS_SET_IRP_CUR_TASK(); /* for mikroC for PIC16 only */         \ 
....................             _OS_TASK_ATOMIC_WRITE_A((pTask)->State.bPaused = 1);            \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................             {                                                               \ 
....................                 __OS_SET_STATE_PAUSE();                                     \ 
....................                 OS_Yield();                                                 \ 
....................             }                                                               \ 
....................             _OS_CLR_IRP();          /* for mikroC for PIC16 only */         \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Continue paused task                                                 */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSACCS__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Continue(pTask)                                         \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A(pTask->State.bPaused = 0);              \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Continue(pTask)                                         \ 
....................         {                                                                   \ 
....................             _OS_TASK_ATOMIC_WRITE_A(pTask->State.bPaused &= ~1);            \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_Continue(pTask)                                         \ 
....................         {                                                                   \ 
....................             _OS_SET_IRP_CUR_TASK();   /* for mikroC for PIC16 only */       \ 
....................             _OS_TASK_ATOMIC_WRITE_A((pTask)->State.bPaused = 0);            \ 
....................             _OS_CLR_IRP();            /* for mikroC for PIC16 only */       \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Replace current task with new (current task will be deleted)         */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... // See proc.spec. h-file in "port" folder. 
....................  
....................  
....................  
.................... /****************************************************************************/ 
.................... /*                                                                          */ 
.................... /* Create task                                                              */ 
.................... /*                                                                          */ 
.................... /****************************************************************************/ 
....................  
.................... // See proc.spec. h-file in "port" folder. 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Create task by indirrect address                                     */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Task_CreateP(priority, TaskAddr)      _OS_Task_Create(priority, TaskAddr) 
.................... #define OS_Task_Create_P(priority, TaskAddr)     _OS_Task_Create(priority, TaskAddr) 
....................  
.................... // If task created indirrectly then it is nessesary to insert in 
.................... // the main() service OS_ReserveTasks: 
.................... // see proc.spec. h-file in "port" folder. 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Get/set current task priority                                        */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #if defined(__OSA_PIC16_MIKROC__) 
....................     #define OS_Task_GetPriority(pTask)      _OS_Task_GetPriority(pTask) 
.................... #elif defined (__OSACCS__) 
....................     #define OS_Task_GetPriority(pTask)      pTask->State.cPriority 
.................... #else 
....................     #define OS_Task_GetPriority(pTask)      (pTask)->State.cPriority 
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSACCS__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_SetPriority(pTask, new_priority)                        \ 
....................         {                                                                   \ 
....................             pTask->State.cPriority = new_priority;                          \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................                 __OS_SET_STATE_PRIORITY(new_priority);                      \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__) 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_SetPriority(pTask, new_priority)                        \ 
....................         {                                                                   \ 
....................             (pTask)->State.cPriority &= ~7;                                 \ 
....................             (pTask)->State.cPriority |= new_priority;                       \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................                 __OS_SET_STATE_PRIORITY(new_priority);                      \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................     #define OS_Task_SetPriority(pTask, new_priority)                        \ 
....................         {                                                                   \ 
....................             _OS_SET_IRP_CUR_TASK();       /* for mikroC for PIC16 only */   \ 
....................             (pTask)->State.cPriority = new_priority;                        \ 
....................             if ((pTask) == (_OS_CurTask))                                   \ 
....................                 __OS_SET_STATE_PRIORITY(new_priority);                      \ 
....................             _OS_CLR_IRP();               /* for mikroC for PIC16 only */    \ 
....................         } 
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Get current task's descriptor address                                */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_GetCurTask()                 this_task 
.................... #define OS_Task_GetCur()                this_task 
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Check for task is paused                                             */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... #if defined(__OSA_PIC16_MIKROC__) 
....................  
....................     #define OS_Task_IsPaused(pTask)         _OS_Task_IsPaused(pTask) 
....................     #define OS_Task_IsEnable(pTasK)         _OS_Task_IsEnable(pTask) 
....................  
.................... #elif defined(__OSACCS16__) 
....................  
....................     #define OS_Task_IsPaused(pTask)         pTask->State.bPaused 
....................     #define OS_Task_IsEnable(pTask)         pTask->State.bEnable 
....................  
.................... #else 
....................  
....................     #define OS_Task_IsPaused(pTask)         (pTask)->State.bPaused 
....................     #define OS_Task_IsEnable(pTask)         (pTask)->State.bEnable 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... // Pause timer 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Pause()           _OS_TASK_ATOMIC_WRITE_A(_OS_CurTask->State.bDelay = 0) 
....................  
.................... /************************************************************************/ 
.................... // Continue paused timer 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Continue()        _OS_TASK_ATOMIC_WRITE_A(_OS_CurTask->State.bDelay = 1) 
....................  
.................... /************************************************************************/ 
.................... // Create task inside main() (don't requires OS_Task_Reserve usage) 
.................... /************************************************************************/ 
....................  
.................... #ifndef OS_Task_Create_M 
.................... #define OS_Task_Create_M(p, t)      OS_Task_Create(p, t) 
.................... #endif 
....................  
....................  
.................... #define OS_Task_GetCreated()        &_OS_Tasks[_OS_Temp]   
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_tasks.h 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #include "kernel\events\osa_bsem.h"         // Binary semaphores 
.................... /* 
....................  *********************************************************************************************** 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:        http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  *              http://picosa.narod.ru 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:       osa_bsem.h 
....................  * 
....................  *  Programmer: Timofeev Victor 
....................  *              osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Definition: Services for work with binary semaphores 
....................  * 
....................  *  History:    21.01.2009 
....................  *  
....................  *              10.12.2009      1. Services for interrupt were corrected. 
....................  *                                  Modified: 
....................  *                                      OS_Bsem_Wait 
....................  *                                      OS_Bsem_Wait_TO 
....................  *                                  Added: 
....................  *                                      OS_Bsem_Check_I 
....................  *                                      OS_Bsem_Reset_I 
....................  *                                      OS_Bsem_Set_I 
....................  *                                      OS_Bsem_Switch_I 
....................  *                                      OS_Bsem_Signal_I 
....................  *  
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                          B I N A R Y    S E M A P H O R E S                                  * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #ifndef OS_BSEMS 
....................     #define OS_BSEMS    0 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_BSEMS > 0 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
.................... extern  volatile OS_BSEM_BANK OST_UINT  _OS_Bsems[(OS_BSEMS+_OST_INT_SIZE-1)/_OST_INT_SIZE]; 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #if defined(OS_ENABLE_INT_BSEM) 
....................  
....................     #define __OS_BSEM_DI()          _OS_DI_INT() 
....................     #define __OS_BSEM_RI()          _OS_RI_INT() 
....................  
....................     #if defined(OS_PROTECT_MEMORY_ACCESS)            
....................         #define __OS_BSEM_DI_A()    _OS_DI_INT() 
....................         #define __OS_BSEM_RI_A()    _OS_RI_INT() 
....................     #else 
....................         #define __OS_BSEM_DI_A() 
....................         #define __OS_BSEM_RI_A() 
....................     #endif 
....................  
.................... #else 
....................  
....................     #define __OS_BSEM_DI() 
....................     #define __OS_BSEM_RI() 
....................     #define __OS_BSEM_DI_A()                         
....................     #define __OS_BSEM_RI_A() 
....................  
.................... #endif 
....................  
....................  
.................... #define OS_BSEM_ATOMIC_WRITE_A(expr)    \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_BSEM_DI_A();               \ 
....................         expr;                           \ 
....................         __OS_BSEM_RI_A();               \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_BSEM_ATOMIC_READ_A(expr)                                     \ 
....................     (__OS_BSEM_DI_A(), _OS_Temp = (expr), __OS_BSEM_RI_A(), _OS_Temp)   \ 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #define _OS_BSEM_POS(binsem)        ((binsem) >> _OST_INT_SHIFT) 
.................... #define _OS_BSEM_MASK(binsem)       (1 << ((binsem) & _OST_INT_MASK)) 
....................  
....................  
....................  
.................... #define __OS_Bsem_Set(binsem)       _OS_Bsems[_OS_BSEM_POS(binsem)] |=  _OS_BSEM_MASK(binsem)  
.................... #define __OS_Bsem_Reset(binsem)     _OS_Bsems[_OS_BSEM_POS(binsem)] &= ~_OS_BSEM_MASK(binsem)  
.................... #define __OS_Bsem_Switch(binsem)    _OS_Bsems[_OS_BSEM_POS(binsem)] ^=  _OS_BSEM_MASK(binsem)  
.................... #define __OS_Bsem_Check(binsem)    (_OS_Bsems[_OS_BSEM_POS(binsem)] &   _OS_BSEM_MASK(binsem)) 
....................  
....................  
.................... // Set/reset/switch  binary semaphore 
....................  
.................... #define OS_Bsem_Set(binsem)           OS_BSEM_ATOMIC_WRITE_A(__OS_Bsem_Set(binsem))        
.................... #define OS_Bsem_Reset(binsem)         OS_BSEM_ATOMIC_WRITE_A(__OS_Bsem_Reset(binsem))      
.................... #define OS_Bsem_Signal(binsem)        OS_BSEM_ATOMIC_WRITE_A(__OS_Bsem_Set(binsem))        
.................... #define OS_Bsem_Switch(binsem)        OS_BSEM_ATOMIC_WRITE_A(__OS_Bsem_Switch(binsem))     
....................  
.................... // Check for binary semaphore is set 
....................  
.................... #define OS_Bsem_Check(binsem)   __OS_Bsem_Check(binsem) 
....................  
....................  
.................... // Inverce semaphore's value 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_BSEM) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     // Wait binary semaphore 
....................  
....................     #define OS_Bsem_Wait(binsem)                                            \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait(OS_Bsem_Check(binsem));                      \ 
....................                 __OS_BSEM_DI();                                             \ 
....................                 if (OS_Bsem_Check(binsem)) break;                           \ 
....................                 __OS_BSEM_DI();                                             \ 
....................             }                                                               \ 
....................             __OS_Bsem_Reset(binsem);                                        \ 
....................             __OS_BSEM_RI();                                                 \ 
....................         } OSM_END 
....................  
....................  
....................  
....................     // Wait binary semaphore. Exit if timeout expired 
....................  
....................     #define OS_Bsem_Wait_TO(binsem, timeout)                                \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait_TO(OS_Bsem_Check(binsem), timeout);     \ 
....................                 __OS_BSEM_DI();                                             \ 
....................                 if (OS_Bsem_Check(binsem) || OS_IsTimeout()) break;         \ 
....................                 __OS_BSEM_RI();                                             \ 
....................             }                                                               \ 
....................             __OS_Bsem_Reset(binsem);                                        \ 
....................             __OS_BSEM_RI();                                                 \ 
....................         } OSM_END 
....................  
....................  
....................     #define OS_Bsem_Set_I(binsem)           __OS_Bsem_Set(binsem)        
....................     #define OS_Bsem_Reset_I(binsem)         __OS_Bsem_Reset(binsem)      
....................     #define OS_Bsem_Signal_I(binsem)        __OS_Bsem_Set(binsem)        
....................     #define OS_Bsem_Switch_I(binsem)        __OS_Bsem_Switch(binsem)     
....................     #define OS_Bsem_Check_I(binsem)         __OS_Bsem_Check(binsem)      
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   // OS_ENABLE_INT_BSEM 
.................... //------------------------------------------------------------------------------ 
....................  
....................     // Wait binary semaphore 
....................  
....................     #define OS_Bsem_Wait(binsem)                                            \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait(OS_Bsem_Check(binsem));                                 \ 
....................             __OS_Bsem_Reset(binsem);                                        \ 
....................         } OSM_END 
....................  
....................  
....................  
....................     // Wait binary semaphore. Exit if timeout expired 
....................  
....................     #define OS_Bsem_Wait_TO(binsem, timeout)                                \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait_TO(OS_Bsem_Check(binsem), timeout);                     \ 
....................             __OS_Bsem_Reset(binsem);                                        \ 
....................         } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_INT_BSEM 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif          // OS_BSEMS > 0 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_bsem.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_csem.h"         // Counting semaphores 
.................... /* 
....................  *********************************************************************************************** 
....................  *                                                                                               
....................  *  OSA cooperative RTOS for Microchip PIC-controllers: PIC10/12/16/18/24/dsPIC                  
....................  *                                                                                               
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  *                                                                                               
....................  *  URL:        http://wiki.pic24.ru/doku.php/en/osa/ref/intro                                   
....................  *              http://picosa.narod.ru                                                           
....................  *                                                                                               
....................  *---------------------------------------------------------------------------------------------- 
....................  *                                                                                               
....................  *  File:       osa_csem.h                                                                       
....................  *                                                                                               
....................  *  Programmer: Timofeev Victor                                                                  
....................  *              osa@pic24.ru, testerplus@mail.ru                                                 
....................  *                                                                                               
....................  *  Definition: Services for work with counting semaphores                                       
....................  *                                                                                               
....................  *  History:    21.01.2009                                                                       
....................  *              21.03.2009 -    Enable/disable interrupt actions on SignalCsem are placed incide 
....................  *                              macro OS_Csem_Signal and deleted from _OS_Csem_Signal            
....................  *                                                                                               
....................  *              10.12.2009 -    1. Services for interrupt were corrected. 
....................  *                              2. Service OS_Csem_Signal waits for semaphore is free. 
....................  *                                 Service OS_Csem_Signal_Now added 
....................  *  
....................  *              31.05.2010 -    3. OS_Csem_Check returns boolean value now 
....................  *                                                                                               
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                            C O U N T I N G   S E M A P H O R E S                             * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_CSEM 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
.................... extern void _OS_Csem_Signal(OST_CSEM *pCSem); 
....................  
.................... #ifdef OS_ENABLE_INT_CSEM 
.................... extern void _OS_Csem_Signal_I(OST_CSEM *pCSem); 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... // These services are used in countsem functions (see OSA.C) 
....................  
.................... #if defined(OS_ENABLE_INT_CSEM) && ((OS_CSEM_SIZE > 1) || defined(OS_PROTECT_MEMORY_ACCESS))  
....................  
....................     #define __OS_CSEM_DI()      _OS_DI_INT()  
....................     #define __OS_CSEM_RI()      _OS_RI_INT()  
....................  
.................... #else 
....................  
....................     #define __OS_CSEM_DI() 
....................     #define __OS_CSEM_RI() 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #define __OS_Csem_Accept(countsem)              countsem-- 
.................... #define __OS_Csem_Check(countsem)              (countsem != 0)       
.................... #define __OS_Csem_SetValue(countsem,value)      countsem = value 
....................  
....................  
.................... // Increase counting semaphore's value by 1 
....................  
.................... #define OS_Csem_Signal(countsem)                                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         for (;;) {                                                      \ 
....................             __OS_CSEM_DI();                                             \ 
....................             _OS_Csem_Signal(&(countsem));                               \ 
....................             __OS_CSEM_RI();                                             \ 
....................             if (!OS_IsEventError()) break;                              \ 
....................             OS_Yield();                                                 \ 
....................         }                                                               \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... // Increase counting semaphore's value by 1 
....................  
.................... #define OS_Csem_Signal_Now(countsem)                                    \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_CSEM_DI();                                                 \ 
....................         _OS_Csem_Signal(&(countsem));                                   \ 
....................         __OS_CSEM_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
.................... // Set counting semaphore's value to given value 
....................  
....................  
.................... #define OS_Csem_SetValue(countsem,value)                                \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_CSEM_DI();                                                 \ 
....................         __OS_Csem_SetValue(countsem,value);                             \ 
....................         __OS_CSEM_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
.................... // Accepting counting semaphore. Decrease it's value by 1. 
....................  
.................... #define OS_Csem_Accept(countsem)                                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_CSEM_DI();                                                 \ 
....................         countsem--;                                                     \ 
....................         __OS_CSEM_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... // Set counting semaphore's value to 1. 
.................... #define OS_Csem_Set(countsem)    OS_Csem_SetValue(countsem, 1) 
....................  
.................... // Clear counting semaphore 
.................... #define OS_Csem_Reset(countsem)  OS_Csem_SetValue(countsem, 0) 
....................  
.................... #define OS_Csem_Create(countsem) OS_Csem_SetValue(countsem, 0) 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if (OS_CSEM_SIZE == 1) || (!defined(OS_ENABLE_INT_CSEM)) 
....................  
....................     // Check counting semaphore for non zero value 
....................     #define OS_Csem_Check(countsem)     __OS_Csem_Check(countsem) 
....................  
.................... #else 
....................  
....................     // Check counting semaphore for non zero value 
....................  
....................     #if defined(OS_ENABLE_INT_CSEM) 
....................         #define OS_Csem_Check(countsem) (__OS_CSEM_DI(),_OS_Temp = __OS_Csem_Check(countsem),__OS_CSEM_RI(),_OS_Temp) 
....................     #else 
....................         #define OS_Csem_Check(countsem) __OS_Csem_Check(countsem) 
....................     #endif 
....................  
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_INT_CSEM 
....................  
....................     // Set counting semaphore's value to given value 
....................     #define OS_Csem_SetValue_I(countsem,value)          countsem = value 
....................  
....................     // Set counting semaphore's value to 1 
....................     #define OS_Csem_Set_I(countsem)                     __OS_Csem_SetValue(countsem, 1) 
....................  
....................     // Clear counting semaphore 
....................     #define OS_Csem_Reset_I(countsem)                   __OS_Csem_SetValue(countsem, 0) 
....................  
....................     // Check counting semaphore for non zero value 
....................     #define OS_Csem_Check_I(countsem)                   __OS_Csem_Check(countsem) 
....................  
....................     // Accept counting semaphore. Decrease it's value by 1 
....................     #define OS_Csem_Accept_I(countsem)                  __OS_Csem_Accept(countsem) 
....................  
....................     // Increase counting semaphore's value by 1 
....................     #define OS_Csem_Signal_I(countsem)                  _OS_Csem_Signal_I(&countsem)              
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_CSEM) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     // Wait counting semaphore 
....................     #define OS_Csem_Wait(countsem)                                          \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait(__OS_Csem_Check(countsem));                  \ 
....................                 __OS_CSEM_DI();                                             \ 
....................                 if (__OS_Csem_Check(countsem)) break;                       \ 
....................                 __OS_CSEM_RI();                                             \ 
....................             }                                                               \ 
....................             __OS_Csem_Accept(countsem);                                     \ 
....................             __OS_CSEM_RI();                                                 \ 
....................         } OSM_END 
....................  
....................     // Wait counting semaphore. Exit if timeout expired. 
....................     #define OS_Csem_Wait_TO(countsem, timeout)                              \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait_TO(__OS_Csem_Check(countsem), timeout); \ 
....................                 __OS_CSEM_DI();                                             \ 
....................                 if (__OS_Csem_Check(countsem) || OS_IsTimeout()) break;     \ 
....................                 __OS_CSEM_RI();                                             \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 __OS_Csem_Accept(countsem);                                 \ 
....................             }                                                               \ 
....................             __OS_CSEM_RI();                                                 \ 
....................         } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     // Wait counting semaphore 
....................     #define OS_Csem_Wait(countsem)                                          \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait(__OS_Csem_Check(countsem));                      \ 
....................             __OS_Csem_Accept(countsem);                                     \ 
....................         } OSM_END 
....................  
....................     // Wait counting semaphore. Exit if timeout expired. 
....................     #define OS_Csem_Wait_TO(countsem, timeout)                              \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait_TO(__OS_Csem_Check(countsem), timeout);     \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 __OS_Csem_Accept(countsem);                                 \ 
....................             }                                                               \ 
....................         } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_CSEM 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_csem.h 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
.................... #include "kernel\events\osa_flag.h"         // Flags 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_flag.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for flags  
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************/ 
.................... /*                                                                                              */ 
.................... /*                     F L A G S                                                                */ 
.................... /*                                                                                              */ 
.................... /************************************************************************************************/ 
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #if defined(OS_ENABLE_INT_FLAG)                      
....................  
....................     #define __OS_FLAG_DI()      _OS_DI_INT() 
....................     #define __OS_FLAG_RI()      _OS_RI_INT() 
....................  
.................... #else 
....................  
....................     #define __OS_FLAG_DI() 
....................     #define __OS_FLAG_RI() 
....................  
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #define OS_FLAG_ATOMIC_WRITE_A(expr)    \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_FLAG_DI();                 \ 
....................         expr;                           \ 
....................         __OS_FLAG_RI();                 \ 
....................     } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... // Create flags and clear all bits 
....................  
.................... #define OS_Flag_Create(flags)               flags = 0 
....................  
....................  
.................... // Set flags to given value 
....................  
.................... #define OS_Flag_Init(flags, value)          flags = value 
....................  
....................  
.................... // Set bits in flag by given mask 
....................  
.................... #define OS_Flag_Set(flags, mask)            OS_FLAG_ATOMIC_WRITE_A(flags |= mask)       
....................  
.................... // Clear bits in flag by given mask 
....................  
.................... #define OS_Flag_Clear(flags, mask)          OS_FLAG_ATOMIC_WRITE_A(flags &= ~(mask))    
....................  
....................  
.................... // Check for all bits in flag are set by given mask 
....................  
.................... #define OS_Flag_Check_AllOn(flags, mask)     (((flags) & (mask))==(mask)) 
....................  
....................  
.................... // Check for any bit in flag is set by given mask 
....................  
.................... #define OS_Flag_Check_On(flags, mask)        ((flags) & (mask)) 
....................  
....................  
.................... // Check for bits in flag are cleared by given mask 
....................  
.................... #define OS_Flag_Check_AllOff(flags, mask)    (((flags) & (mask)) == 0) 
....................  
....................  
.................... // Check for any bit in flag is cleared by given mask 
....................  
.................... #define OS_Flag_Check_Off(flags, mask)       (((flags) & (mask)) != (mask)) 
....................  
....................  
.................... // Wait for all bits in flags are set by given mask 
....................  
.................... #define OS_Flag_Wait_AllOn(flags, mask)                                 \ 
....................     {                                                                   \ 
....................         OS_Wait(OS_Flag_Check_AllOn(flags, mask));                      \ 
....................     } 
....................  
....................  
.................... // Wait for any bit in flags is set by given mask 
....................  
.................... #define OS_Flag_Wait_On(flags, mask)                                    \ 
....................     {                                                                   \ 
....................         OS_Wait(OS_Flag_Check_On(flags, mask));                         \ 
....................     } 
....................  
....................  
.................... // Wait for all bits in flags are set by given mask. Exit if timeout expired. 
....................  
.................... #define OS_Flag_Wait_AllOn_TO(flags, mask, timeout)                     \ 
....................     {                                                                   \ 
....................         OS_Wait_TO(OS_Flag_Check_AllOn(flags, mask), timeout);          \ 
....................     } 
....................  
....................  
.................... // Wait for any bit in flags is set by given mask. Exit if timeout expired. 
....................  
.................... #define OS_Flag_Wait_On_TO(flags, mask, timeout)                        \ 
....................     {                                                                   \ 
....................         OS_Wait_TO(OS_Flag_Check_On(flags, mask), timeout);             \ 
....................     } 
....................  
....................  
.................... // Wait for all bits in flag are cleared by given mask 
....................  
.................... #define OS_Flag_Wait_AllOff(flags, mask)                                \ 
....................     {                                                                   \ 
....................         OS_Wait(OS_Flag_Check_AllOff(flags, mask));                     \ 
....................     } 
....................  
....................  
.................... // Wait for any bit in flag is cleared by given mask 
....................  
.................... #define OS_Flag_Wait_Off(flags, mask)                                   \ 
....................     {                                                                   \ 
....................         OS_Wait(OS_Flag_Check_Off(flags, mask));                        \ 
....................     } 
....................  
....................  
.................... // Wait for all bits in flag are cleared by given mask. Exit if timeout expired. 
....................  
.................... #define OS_Flag_Wait_AllOff_TO(flags, mask, timeout)                    \ 
....................     {                                                                   \ 
....................         OS_Wait_TO(OS_Flag_Check_AllOff(flags, mask), timeout);         \ 
....................     } 
....................  
.................... // Wait for any bit in flag is cleared by given mask. Exit if timeout expired. 
....................  
.................... #define OS_Flag_Wait_Off_TO(flags, mask, timeout)                       \ 
....................     {                                                                   \ 
....................         OS_Wait_TO(OS_Flag_Check_Off(flags, mask), timeout);            \ 
....................     } 
....................  
....................  
....................  
.................... #if defined(OS_ENABLE_INT_FLAG)                      
....................  
....................     #define OS_Flag_Set_I(flags, mask)          flags |= mask                               
....................     #define OS_Flag_Clear_I(flags, mask)        flags &= ~(mask)                            
....................     #define OS_Flag_Check_AllOn_I(flags, mask)   (((flags) & (mask))==(mask)) 
....................     #define OS_Flag_Check_On_I(flags, mask)      ((flags) & (mask)) 
....................     #define OS_Flag_Check_AllOff_I(flags, mask)  (((flags) & (mask)) == 0) 
....................     #define OS_Flag_Check_Off_I(flags, mask)     (((flags) & (mask)) != (mask)) 
....................     #define OS_Flag_Init_I(flags, value)        flags = value 
....................  
.................... #endif 
....................  
.................... //****************************************************************************** 
.................... // Old names  
.................... //****************************************************************************** 
....................  
....................  
.................... #define OS_Flag_Set_1(flags, mask)          OS_FLAG_ATOMIC_WRITE_A(flags |= mask)      
.................... #define OS_Flag_Set_0(flags, mask)          OS_FLAG_ATOMIC_WRITE_A(flags &= ~(mask))   
.................... #define OS_Flag_Check_11(flags, mask)       (((flags) & (mask))==(mask)) 
.................... #define OS_Flag_Check_1x(flags, mask)       ((flags) & (mask)) 
.................... #define OS_Flag_Check_00(flags, mask)       (((flags) & (mask)) == 0) 
.................... #define OS_Flag_Check_0x(flags, mask)       (((flags) & (mask)) != (mask)) 
....................  
.................... #define OS_Flag_Set_1_I(flags, mask)        OS_Flag_Set_1(flags, mask)       
.................... #define OS_Flag_Set_0_I(flags, mask)        OS_Flag_Set_0(flags, mask)       
.................... #define OS_Flag_Check_11_I(flags, mask)     OS_Flag_Check_11(flags, mask)    
.................... #define OS_Flag_Check_1x_I(flags, mask)     OS_Flag_Check_1x(flags, mask)    
.................... #define OS_Flag_Check_00_I(flags, mask)     OS_Flag_Check_00(flags, mask)    
.................... #define OS_Flag_Check_0x_I(flags, mask)     OS_Flag_Check_0x(flags, mask)    
....................  
....................  
....................  
.................... #define OS_Flag_Wait_11(flags, mask)                OS_Flag_Wait_AllOn(flags, mask) 
.................... #define OS_Flag_Wait_00(flags, mask)                OS_Flag_Wait_AllOff(flags, mask) 
.................... #define OS_Flag_Wait_1x(flags, mask)                OS_Flag_Wait_On(flags, mask) 
.................... #define OS_Flag_Wait_0x(flags, mask)                OS_Flag_Wait_Off(flags, mask) 
.................... #define OS_Flag_Wait_11_TO(flags, mask, timeout)    OS_Flag_Wait_AllOn_TO(flags, mask, timeout) 
.................... #define OS_Flag_Wait_00_TO(flags, mask, timeout)    OS_Flag_Wait_AllOff_TO(flags, mask, timeout) 
.................... #define OS_Flag_Wait_1x_TO(flags, mask, timeout)    OS_Flag_Wait_On_TO(flags, mask, timeout) 
.................... #define OS_Flag_Wait_0x_TO(flags, mask, timeout)    OS_Flag_Wait_Off_TO(flags, mask, timeout) 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_flag.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_msg.h"          // Pointer to messages 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_msg.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for messages 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                               P O I N T E R S   T O   M E S S A G E S                        * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... // These macro used in services 
.................... #if defined(OS_ENABLE_INT_MSG) 
....................  
....................     #define __OS_MSG_DI()       _OS_DI_INT() 
....................     #define __OS_MSG_RI()       _OS_RI_INT() 
....................  
.................... #else 
....................  
....................     #define __OS_MSG_DI() 
....................     #define __OS_MSG_RI() 
....................  
.................... #endif 
....................  
....................  
.................... #ifdef __OSACCS__                   // When OST_MSG = const char*, expressions like: 
....................                                     // (OST_MSG)(message) 
....................                                     // loose high byte of an address 
....................                                     // At this time (91210) it doesn't matter because of 
....................                                     // CCS bugs. Expression pointer1 = pointer2 copies only 
....................                                     // low byte. May be in future this bug will be fixed 
....................     #define OST_CONVERT_TYPE_MSG 
.................... #else 
....................     #define OST_CONVERT_TYPE_MSG    (OST_MSG) 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Check for message exists 
....................  
.................... #define OS_Msg_Check(msg_cb)          ((msg_cb).status & 1) 
.................... #define OS_Msg_Check2(msg_cb)         ((msg_cb).status) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Create message and zero it. 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Msg_Create(msg_cb)                       \ 
....................     OSM_BEGIN {                                     \ 
....................         __OS_MSG_DI();                              \ 
....................         (msg_cb).status = 0;                        \ 
....................         (msg_cb).msg = OST_CONVERT_TYPE_MSG 0;      \ 
....................         __OS_MSG_RI();                              \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Make message free 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Msg_Clear(msg_cb)          (msg_cb).status = 0 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Send message. If message is already exists then it will be overwritten. 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Msg_Send_Now(msg_cb, value)                                          \ 
....................     OSM_BEGIN {                                                                 \ 
....................         _OS_Flags.bEventError = 0;                                              \ 
....................         __OS_MSG_DI();                                                          \ 
....................         if (OS_Msg_Check(msg_cb)) _OS_Flags.bEventError = 1;                    \ 
....................         (msg_cb).status = 1;                                                    \ 
....................         (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                            \ 
....................         __OS_MSG_RI();                                                          \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Accept existing message. After accepting message is set free. 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Msg_Accept(msg_cb, os_msg_type_var)                          \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_MSG_DI();                                                  \ 
....................         os_msg_type_var = (msg_cb).msg;                                 \ 
....................         OS_Msg_Clear(msg_cb);                                           \ 
....................         __OS_MSG_RI();                                                  \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Get pointer to message. Message remains existing.     
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Msg_Get(msg_cb, os_msg_type_var)                             \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_MSG_DI();                                                  \ 
....................         os_msg_type_var = (msg_cb).msg;                                 \ 
....................         OS_Msg_Clear(msg_cb);                                           \ 
....................         __OS_MSG_RI();                                                  \ 
....................     } OSM_END 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_INT_MSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message from interrupt. If message is already exists then it will be overwritten. 
....................     //------------------------------------------------------------------------------ 
....................     #define OS_Msg_Send_I(msg_cb, value)                                    \ 
....................         OSM_BEGIN {                                                         \ 
....................             _OS_Flags.bEventError = 0;                                       \ 
....................             if (OS_Msg_Check_I(msg_cb)) _OS_Flags.bEventError = 1;           \ 
....................             (msg_cb).status = 1;                                            \ 
....................             (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                    \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Accept existing message. After accepting message is set free. 
....................     //------------------------------------------------------------------------------ 
....................     #define OS_Msg_Accept_I(msg_cb, os_msg_type_var)                        \ 
....................         OSM_BEGIN {                                                         \ 
....................             os_msg_type_var = (msg_cb).msg;                                 \ 
....................             OS_Msg_Clear_I(msg_cb);                                         \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Get existing message. Message slill remains existing 
....................     //------------------------------------------------------------------------------ 
....................     #define OS_Msg_Get_I(msg_cb, os_msg_type_var)                           \ 
....................         OSM_BEGIN {                                                         \ 
....................             os_msg_type_var = (msg_cb).msg;                                 \ 
....................         } OSM_END 
....................  
....................  
....................     #define OS_Msg_Check_I(msg_cb)      OS_Msg_Check(msg_cb) 
....................     #define OS_Msg_Clear_I(msg_cb)      OS_Msg_Clear(msg_cb) 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message. If message is already exists then wait when it became free. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Send(msg_cb, value)                                      \ 
....................         OSM_BEGIN {                                                         \ 
....................             __OS_MSG_DI();                                                  \ 
....................             while (OS_Msg_Check(msg_cb))                                    \ 
....................             {                                                               \ 
....................                 __OS_MSG_RI();                                              \ 
....................                 OS_Wait(!OS_Msg_Check(msg_cb));                      \ 
....................                 __OS_MSG_DI();                                              \ 
....................             };                                                              \ 
....................             (msg_cb).status = 1;                                            \ 
....................             (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                    \ 
....................             __OS_MSG_RI();                                                  \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message. If message is already exists then wait when it became free. Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Send_TO(msg_cb, value,timeout)                               \ 
....................         OSM_BEGIN {                                                             \ 
....................             _OS_Flags.bTimeout = 0;                                              \ 
....................             __OS_MSG_DI();                                                      \ 
....................             while (OS_Msg_Check(msg_cb) && !OS_IsTimeout())                     \ 
....................             {                                                                   \ 
....................                 __OS_MSG_RI();                                                  \ 
....................                 OS_Wait_TO(!OS_Msg_Check(msg_cb), timeout);         \ 
....................                 __OS_MSG_DI();                                                  \ 
....................             };                                                                  \ 
....................             if (!OS_IsTimeout()){                                               \ 
....................                 (msg_cb).status = 1;                                            \ 
....................                 (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                    \ 
....................             }                                                                   \ 
....................             __OS_MSG_RI();                                                      \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for message. After waiting message is set free 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Wait(msg_cb, os_msg_type_var)                        \ 
....................         OSM_BEGIN {                                                     \ 
....................             for (;;) {                                                  \ 
....................                 OS_Wait(OS_Msg_Check(msg_cb));                   \ 
....................                 __OS_MSG_DI();                                          \ 
....................                 if (OS_Msg_Check(msg_cb)) break;                        \ 
....................                 __OS_MSG_RI();                                          \ 
....................             }                                                           \ 
....................             os_msg_type_var = (msg_cb).msg;                             \ 
....................             OS_Msg_Clear(msg_cb);                                       \ 
....................             __OS_MSG_RI();                                              \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for mesage. Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................     #define OS_Msg_Wait_TO(msg_cb, os_msg_type_var,timeout)             \ 
....................         OSM_BEGIN {                                                     \ 
....................             for (;;) {                                                  \ 
....................                 OS_Wait_TO(OS_Msg_Check(msg_cb), timeout);  \ 
....................                 __OS_MSG_DI();                                          \ 
....................                 if (OS_Msg_Check(msg_cb) || OS_IsTimeout()) break;      \ 
....................                 __OS_MSG_RI();                                          \ 
....................             }                                                           \ 
....................             if (!OS_IsTimeout()) {                                      \ 
....................                 os_msg_type_var = (msg_cb).msg;                         \ 
....................                 OS_Msg_Clear(msg_cb);                                   \ 
....................             }                                                           \ 
....................             __OS_MSG_RI();                                              \ 
....................         } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   // OS_ENABLE_INT_MSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message. If message is already exists then wait when it became free. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Send(msg_cb, value)                                              \ 
....................         OSM_BEGIN {                                                                 \ 
....................             if (OS_Msg_Check(msg_cb)) OS_Wait(!OS_Msg_Check(msg_cb));        \ 
....................             (msg_cb).status = 1;                                                    \ 
....................             (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                            \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message. If message is already exists then wait when it became free. Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Send_TO(msg_cb, value,timeout)                                   \ 
....................         OSM_BEGIN {                                                                 \ 
....................             _OS_Flags.bTimeout = 0;                                                  \ 
....................             if (OS_Msg_Check(msg_cb))                                               \ 
....................             {                                                                       \ 
....................                 OS_Wait_TO(!OS_Msg_Check(msg_cb), timeout);             \ 
....................             }                                                                       \ 
....................             if (!OS_IsTimeout()){                                                   \ 
....................                 (msg_cb).status = 1;                                                \ 
....................                 (msg_cb).msg = OST_CONVERT_TYPE_MSG (value);                        \ 
....................             }                                                                       \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for message. After waiting message is set free 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Wait(msg_cb, os_msg_type_var)                            \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait(OS_Msg_Check(msg_cb));                           \ 
....................             os_msg_type_var = (msg_cb).msg;                                 \ 
....................             OS_Msg_Clear(msg_cb);                                           \ 
....................         } OSM_END 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for mesage. Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Msg_Wait_TO(msg_cb, os_msg_type_var,timeout)                 \ 
....................         OSM_BEGIN {                                                         \ 
....................             os_msg_type_var = OST_CONVERT_TYPE_MSG 0;                       \ 
....................             OS_Wait_TO(OS_Msg_Check(msg_cb), timeout);          \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 os_msg_type_var = (msg_cb).msg;                             \ 
....................                 OS_Msg_Clear(msg_cb);                                       \ 
....................             }                                                               \ 
....................         } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_INT_MSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_msg.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_queue.h"        // Queue of pointers to messages 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_queue.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for work with queue of pointers to messages  
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                              Q U E U E   O F   M E S S A G E S                               * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... #if defined(OS_ENABLE_INT_QUEUE) 
....................  
....................     #define __OS_QUEUE_DI()       _OS_DI_INT()  
....................     #define __OS_QUEUE_RI()       _OS_RI_INT()  
....................  
....................     #if defined(OS_PROTECT_MEMORY_ACCESS)            
....................         #define __OS_QUEUE_DI_A()    _OS_DI_INT() 
....................         #define __OS_QUEUE_RI_A()    _OS_RI_INT() 
....................     #else 
....................         #define __OS_QUEUE_DI_A() 
....................         #define __OS_QUEUE_RI_A() 
....................     #endif 
....................  
.................... #else 
....................  
....................     #define __OS_QUEUE_DI() 
....................     #define __OS_QUEUE_RI() 
....................     #define __OS_QUEUE_DI_A() 
....................     #define __OS_QUEUE_RI_A() 
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_QUEUE_ATOMIC_WRITE_A(expr)                                       \ 
....................     OSM_BEGIN {                                                             \ 
....................         __OS_QUEUE_DI_A();                                                  \ 
....................         expr;                                                               \ 
....................         __OS_QUEUE_RI_A();                                                  \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_QUEUE_ATOMIC_READ_A(expr)                                        \ 
....................     (__OS_QUEUE_DI_A(), _OS_Temp = (expr), __OS_QUEUE_RI_A(), _OS_Temp)     \ 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_QUEUE 
.................... //------------------------------------------------------------------------------ 
....................  
.................... extern void     _OS_Queue_Send (OST_QUEUE *pQueue, OST_MSG Msg); 
.................... extern OST_MSG  _OS_Queue_Get  (OST_QUEUE *pQueue); 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Create queue 
....................  
.................... #define OS_Queue_Create(queue, buffer, size)             \ 
....................     OSM_BEGIN {                                          \ 
....................         __OS_QUEUE_DI();                                 \ 
....................         (queue).Q.cSize = size;                          \ 
....................         (queue).Q.cBegin = 0;                            \ 
....................         (queue).Q.cFilled = 0;                           \ 
....................         (queue).pMsg = (OST_MSG*)(buffer);               \ 
....................         __OS_QUEUE_RI();                                 \ 
....................     } OSM_END 
....................  
....................  
.................... // Internal macros 
....................  
.................... #define __OS_Queue_IsFull(queue)     ((queue).Q.cFilled == (queue).Q.cSize) 
.................... #define __OS_Queue_Check(queue)      ((queue).Q.cFilled) 
....................  
....................  
.................... // Check for any message present in queue 
.................... #define OS_Queue_Check(queue)        __OS_Queue_Check(queue) 
....................  
.................... // Clear queue 
.................... #define OS_Queue_Clear(queue)        (queue).Q.cFilled = 0 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Send message via queue. If queue is full then most rearly message will be pushed out. 
....................  
.................... #define OS_Queue_Send_Now(queue, value)                                 \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         _OS_Queue_Send(&(queue), OST_CONVERT_TYPE_MSG(value));          \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define __OS_Queue_Accept(queue,os_msg_type_var)                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         os_msg_type_var = _OS_Queue_Get(&(queue));                      \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Queue_Accept(queue,os_msg_type_var)                          \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         __OS_Queue_Accept(queue,os_msg_type_var);                       \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Queue_Delete(queue)                                          \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         _OS_Queue_Get(&(queue));                                        \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Queue_Get(queue,os_msg_type_var)                             \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         os_msg_type_var = (queue).pMsg[(queue).Q.cBegin];               \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_QUEUE) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................     extern void     _OS_Queue_Send_I (OST_QUEUE *pQueue, OST_MSG Msg); 
....................     extern OST_MSG  _OS_Queue_Get_I  (OST_QUEUE *pQueue); 
....................  
....................     #define OS_Queue_Send_I(queue, value)   _OS_Queue_Send_I(&(queue), OST_CONVERT_TYPE_MSG(value)) 
....................     #define OS_Queue_Accept_I(queue,os_msg_type_var)    os_msg_type_var = _OS_Queue_Get_I(&(queue)) 
....................     #define OS_Queue_Check_I(queue)         __OS_Queue_Check(queue) 
....................     #define OS_Queue_Clear_I(queue)         OS_Queue_Clear(queue) 
....................     #define OS_Queue_IsFull_I(queue)        __OS_Queue_IsFull(queue) 
....................  
....................     #define OS_Queue_Delete_I(queue,os_msg_type_var)    _OS_Queue_Get_I(&(queue))    
....................     #define OS_Queue_Get_I(queue,os_msg_type_var)       os_msg_type_var = (queue).pMsg[(queue).Q.cBegin]  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. 
....................      
....................     #define OS_Queue_Wait(queue, os_msg_type_var)                           \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait(__OS_Queue_Check(queue));                           \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................                 if (__OS_Queue_Check(queue)) break;                         \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................             }                                                               \ 
....................             __OS_Queue_Accept(queue,os_msg_type_var);                       \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................      
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. Exit if timeout expired. 
....................      
....................     #define OS_Queue_Wait_TO(queue, os_msg_type_var, timeout)               \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait_TO(__OS_Queue_Check(queue), timeout);               \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................                 if (__OS_Queue_Check(queue) || OS_IsTimeout()) break;       \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) __OS_Queue_Accept(queue,os_msg_type_var);  \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................     // Send message via queue. If queue full then wait for free place 
....................      
....................     #define OS_Queue_Send(queue, value)                                     \ 
....................         OSM_BEGIN {                                                         \ 
....................             __OS_QUEUE_DI();                                                \ 
....................             while (__OS_Queue_IsFull(queue))                                \ 
....................             {                                                               \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................                 OS_Wait(!__OS_Queue_IsFull(queue));                         \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................             }                                                               \ 
....................             _OS_Queue_Send(&(queue), OST_CONVERT_TYPE_MSG(value));          \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................      
....................      
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place. Exit if timeout expired. 
....................      
....................     #define OS_Queue_Send_TO(queue, value, timeout)                         \ 
....................         OSM_BEGIN {                                                         \ 
....................             _OS_Flags.bTimeout = 0;                                         \ 
....................             __OS_QUEUE_DI();                                                \ 
....................             while (__OS_Queue_IsFull(queue) && !OS_IsTimeout())             \ 
....................             {                                                               \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................                 OS_Wait_TO(!__OS_Queue_IsFull(queue), timeout);             \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 _OS_Queue_Send(&(queue), OST_CONVERT_TYPE_MSG(value));      \ 
....................             }                                                               \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................  
....................     // Check for queue is full 
....................      
....................     #define OS_Queue_IsFull(queue)  (__OS_QUEUE_DI(),_OS_Temp = __OS_Queue_IsFull(queue),__OS_QUEUE_RI(),_OS_Temp) 
....................      
....................      
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. 
....................      
....................     #define OS_Queue_Wait(queue, os_msg_type_var)                           \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait(__OS_Queue_Check(queue));                               \ 
....................             __OS_Queue_Accept(queue,os_msg_type_var);                       \ 
....................         } OSM_END 
....................      
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. Exit if timeout expired. 
....................      
....................     #define OS_Queue_Wait_TO(queue, os_msg_type_var, timeout)               \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait_TO(__OS_Queue_Check(queue), timeout);                   \ 
....................             if (!OS_IsTimeout()) __OS_Queue_Accept(queue,os_msg_type_var);  \ 
....................         } OSM_END 
....................      
....................     // Send message via queue. If queue full then wait for free place 
....................      
....................     #define OS_Queue_Send(queue, value)                                     \ 
....................         OSM_BEGIN {                                                         \ 
....................             if (__OS_Queue_IsFull(queue))                                   \ 
....................             {                                                               \ 
....................                 OS_Wait(!__OS_Queue_IsFull(queue));                         \ 
....................             }                                                               \ 
....................             _OS_Queue_Send(&(queue), OST_CONVERT_TYPE_MSG(value));          \ 
....................         } OSM_END 
....................      
....................      
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place. Exit if timeout expired. 
....................      
....................     #define OS_Queue_Send_TO(queue, value, timeout)                         \ 
....................         OSM_BEGIN {                                                         \ 
....................             _OS_Flags.bTimeout = 0;                                         \ 
....................             if (__OS_Queue_IsFull(queue))                                   \ 
....................             {                                                               \ 
....................                 OS_Wait_TO(!__OS_Queue_IsFull(queue), timeout);             \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 _OS_Queue_Send(&(queue), OST_CONVERT_TYPE_MSG(value));      \ 
....................             }                                                               \ 
....................         } OSM_END 
....................  
....................     // Check for queue is full 
....................     #define OS_Queue_IsFull(queue)  __OS_Queue_IsFull(queue) 
....................      
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................      
.................... //------------------------------------------------------------------------------ 
.................... // 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_ENABLE_QUEUE 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_queue.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_smsg.h"         // Simple messages 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_smsg.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for work with simple messages 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                              S I M P L E     M E S S A G E S                                 * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #if defined(OS_ENABLE_INT_SMSG) && ((OS_SMSG_SIZE != 1) || defined(OS_PROTECT_MEMORY_ACCESS)) 
....................  
....................     #define __OS_SMSG_DI()       _OS_DI_INT() 
....................     #define __OS_SMSG_RI()       _OS_RI_INT() 
....................  
....................     #if defined(OS_PROTECT_MEMORY_ACCESS)            
....................         #define __OS_SMSG_DI_A()    _OS_DI_INT() 
....................         #define __OS_SMSG_RI_A()    _OS_RI_INT() 
....................     #else 
....................         #define __OS_SMSG_DI_A() 
....................         #define __OS_SMSG_RI_A() 
....................     #endif 
....................  
.................... #else 
....................  
....................     #define __OS_SMSG_DI() 
....................     #define __OS_SMSG_RI() 
....................     #define __OS_SMSG_DI_A() 
....................     #define __OS_SMSG_RI_A() 
....................  
.................... #endif 
....................  
....................  
.................... #define OS_SMSG_ATOMIC_WRITE_A(expr)    \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_SMSG_DI_A();               \ 
....................         expr;                           \ 
....................         __OS_SMSG_RI_A();               \ 
....................     } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... #define __OS_Smsg_Check(smsg)   ((smsg) != (OST_SMSG)0) 
.................... #define __OS_Smsg_IsFree(smsg)  ((smsg) == (OST_SMSG)0) 
....................  
....................  
.................... #if defined(OS_ENABLE_INT_SMSG) && ((OS_SMSG_SIZE != 1) || defined(OS_PROTECT_MEMORY_ACCESS)) 
....................     // Check for message exists 
....................     #define OS_Smsg_Check(smsg)       (__OS_SMSG_DI(), _OS_Temp = __OS_Smsg_Check(smsg), __OS_SMSG_RI(), _OS_Temp) 
....................  
....................     // Check for message is free 
....................     #define OS_Smsg_IsFree(smsg)      (__OS_SMSG_DI(), _OS_Temp = __OS_Smsg_IsFree(smsg), __OS_SMSG_RI(), _OS_Temp) 
....................  
.................... #else 
....................  
....................     // Check for message exists 
....................     #define OS_Smsg_Check(smsg)       __OS_Smsg_Check(smsg) 
....................  
....................     // Check for message is free 
....................     #define OS_Smsg_IsFree(smsg)      __OS_Smsg_IsFree(smsg) 
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Internal macro: Clear message (internal system service) 
.................... //------------------------------------------------------------------------------ 
.................... #define __OS_Smsg_MakeFree(smsg)       smsg = (OST_SMSG)0 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Create simple message 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Smsg_Create(smsg)                                            \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_SMSG_DI();                                                 \ 
....................         __OS_Smsg_MakeFree(smsg);                                       \ 
....................         __OS_SMSG_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Send simple message. If message already exists then it will be overwritten. 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Smsg_Send_Now(smsg, message)                                 \ 
....................     OSM_BEGIN {                                                         \ 
....................         _OS_Flags.bEventError = 0;                                      \ 
....................         __OS_SMSG_DI();                                                 \ 
....................         if (__OS_Smsg_Check(smsg)) _OS_Flags.bEventError = 1;           \ 
....................         smsg = (OST_SMSG) (message);                                    \ 
....................         __OS_SMSG_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Accept existing simple message. After accepting message is cleared. 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_Smsg_Accept(smsg, os_smsg_type_var)                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         os_smsg_type_var = smsg;                                        \ 
....................         __OS_Smsg_MakeFree(smsg);                                       \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Smsg_Accept(smsg, os_smsg_type_var)                          \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_SMSG_DI();                                                 \ 
....................         __OS_Smsg_Accept(smsg, os_smsg_type_var);                       \ 
....................         __OS_SMSG_RI();                                                 \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Get message. Message remains existing.     
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_Smsg_Get(smsg, os_smsg_type_var)                             \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_SMSG_DI();                                                 \ 
....................         os_smsg_type_var = smsg;                                        \ 
....................         __OS_SMSG_RI();                                                 \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_INT_SMSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................     // Send simple message from interrupt. If message already exists then it will be overwritten. 
....................     #define OS_Smsg_Send_I(smsg, message)                               \ 
....................         OSM_BEGIN {                                                     \ 
....................             _OS_Flags.bEventError = 0;                                  \ 
....................             if (OS_Smsg_Check_I(smsg)) _OS_Flags.bEventError = 1;       \ 
....................             smsg = (OST_SMSG) (message);                                \ 
....................         } OSM_END 
....................  
....................     #define OS_Smsg_Accept_I(smsg, os_smsg_type_var)    __OS_Smsg_Accept(smsg, os_smsg_type_var) 
....................     #define OS_Smsg_Get_I(smsg, os_smsg_type_var)       os_smsg_type_var = smsg      
....................  
....................     //#define OS_Smsg_MakeFree_I(smsg)                    __OS_Smsg_MakeFree(smsg) 
....................     #define OS_Smsg_Check_I(smsg)                       __OS_Smsg_Check(smsg) 
....................     #define OS_Smsg_IsFree_I(smsg)                      __OS_Smsg_IsFree(smsg) 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send simple message. If message already exists then wait when it became free. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Send(smsg, message)                                 \ 
....................         OSM_BEGIN {                                                     \ 
....................             __OS_SMSG_DI();                                             \ 
....................             while (__OS_Smsg_Check(smsg)) {                             \ 
....................                 __OS_SMSG_RI();                                         \ 
....................                 OS_Wait(__OS_Smsg_IsFree(smsg));                        \ 
....................                 __OS_SMSG_DI();                                         \ 
....................             }                                                           \ 
....................             smsg = (OST_SMSG) (message);                                \ 
....................             __OS_SMSG_RI();                                             \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send simple message. If message already exists then wait when it became free. 
....................     // Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Send_TO(smsg, message, timeout)                     \ 
....................         OSM_BEGIN {                                                     \ 
....................             _OS_Flags.bTimeout = 0;                                     \ 
....................             __OS_SMSG_DI();                                             \ 
....................             while (__OS_Smsg_Check(smsg) && !OS_IsTimeout())            \ 
....................             {                                                           \ 
....................                 __OS_SMSG_RI();                                         \ 
....................                 OS_Wait_TO(__OS_Smsg_IsFree(smsg), timeout);            \ 
....................                 __OS_SMSG_DI();                                         \ 
....................             }                                                           \ 
....................             if (!OS_IsTimeout()) {                                      \ 
....................                 smsg = (OST_SMSG) (message);                            \ 
....................             }                                                           \ 
....................             __OS_SMSG_RI();                                             \ 
....................         } OSM_END 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for simple message. After accepting simple message is cleared. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Wait(smsg, os_smsg_type_var)                        \ 
....................         OSM_BEGIN {                                                     \ 
....................             for (;;) {                                                  \ 
....................                 OS_Wait(__OS_Smsg_Check(smsg));                         \ 
....................                 __OS_SMSG_DI();                                         \ 
....................                 if (__OS_Smsg_Check(smsg)) break;                       \ 
....................                 __OS_SMSG_RI();                                         \ 
....................             }                                                           \ 
....................             __OS_Smsg_Accept(smsg, os_smsg_type_var);                   \ 
....................             __OS_SMSG_RI();                                             \ 
....................         } OSM_END 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for simple message. After accepting simple message is cleared. 
....................     // Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Wait_TO(smsg, os_smsg_type_var, timeout)            \ 
....................         OSM_BEGIN {                                                     \ 
....................             for (;;) {                                                  \ 
....................                 OS_Wait_TO(__OS_Smsg_Check(smsg), timeout);             \ 
....................                 __OS_SMSG_DI();                                         \ 
....................                 if (__OS_Smsg_Check(smsg) || OS_IsTimeout()) break;     \ 
....................                 __OS_SMSG_RI();                                         \ 
....................             }                                                           \ 
....................             if (!OS_IsTimeout()) {                                      \ 
....................                 __OS_Smsg_Accept(smsg, os_smsg_type_var);               \ 
....................             }                                                           \ 
....................             __OS_SMSG_RI();                                             \ 
....................         } OSM_END 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   // OS_ENABLE_INT_SMSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send simple message. If message already exists then wait when it became free. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Send(smsg, message)                                 \ 
....................         OSM_BEGIN {                                                     \ 
....................             if (__OS_Smsg_Check(smsg))                                  \ 
....................                 OS_Wait(__OS_Smsg_IsFree(smsg));                        \ 
....................             smsg = (OST_SMSG) (message);                                \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send simple message. If message already exists then wait when it became free. 
....................     // Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Send_TO(smsg, message, timeout)                     \ 
....................         OSM_BEGIN {                                                     \ 
....................             _OS_Flags.bTimeout = 0;                                     \ 
....................             if (__OS_Smsg_Check(smsg))                                  \ 
....................             {                                                           \ 
....................                 OS_Wait_TO(__OS_Smsg_IsFree(smsg), timeout);            \ 
....................             }                                                           \ 
....................             if (!OS_IsTimeout()) {                                      \ 
....................                 smsg = (OST_SMSG) (message);                            \ 
....................             }                                                           \ 
....................         } OSM_END 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for simple message. After accepting simple message is cleared. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Wait(smsg, os_smsg_type_var)                        \ 
....................         OSM_BEGIN {                                                     \ 
....................             OS_Wait(__OS_Smsg_Check(smsg));                             \ 
....................             __OS_Smsg_Accept(smsg, os_smsg_type_var);                   \ 
....................         } OSM_END 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait for simple message. After accepting simple message is cleared. 
....................     // Exit if timeout expired. 
....................     //------------------------------------------------------------------------------ 
....................  
....................     #define OS_Smsg_Wait_TO(smsg, os_smsg_type_var, timeout)            \ 
....................         OSM_BEGIN {                                                     \ 
....................             OS_Wait_TO(__OS_Smsg_Check(smsg), timeout);                 \ 
....................             if (!OS_IsTimeout()) {                                      \ 
....................                 __OS_Smsg_Accept(smsg, os_smsg_type_var);               \ 
....................             }                                                           \ 
....................         } OSM_END 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_INT_SMSG 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Alternate names 
.................... //****************************************************************************** 
....................  
.................... #if !defined(__OSACCS__) && !defined(__OSAMIKROC__) 
....................  
.................... #define OS_SMsg_Create          OS_Smsg_Create 
.................... #define OS_SMsg_Check           OS_Smsg_Check 
.................... #define OS_SMsg_Accept          OS_Smsg_Accept 
.................... #define OS_SMsg_Send            OS_Smsg_Send 
.................... #define OS_SMsg_Send_TO         OS_Smsg_Send_TO 
.................... #define OS_SMsg_Send_Now        OS_Smsg_Send_Now 
.................... #define OS_SMsg_Send_I          OS_Smsg_Send_I 
.................... #define OS_SMsg_Wait            OS_Smsg_Wait 
.................... #define OS_SMsg_Wait_TO         OS_Smsg_Wait_TO 
.................... #define OS_SMsg_IsFree          OS_Smsg_IsFree 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_smsg.h 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_squeue.h"       // Queue of simple messages 
.................... /* 
....................  *********************************************************************************************** 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:        http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  *              http://picosa.narod.ru 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:       osa_squeue.h 
....................  * 
....................  *  Programmer: Timofeev Victor 
....................  *              osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Definition: Services for work with queue of simple messages 
....................  * 
....................  *  History:    21.01.2009 
....................  *              21.03.2009 -    Enable/disable interrupt actions on SendSQueue are placed incide 
....................  *                              macro OS_SQueue_Send and deleted from _OS_SQueue_Send 
....................  *              18.06.2009 -    Argument "value" placed in braces 
....................  *                              Alternate names added 
....................  *  
....................  *              10.12.2009      1. Services for interrupt were corrected. 
....................  * 
....................  *              12.06.2010      1. OS_Squeue_IsFree and OS_Squeue_IsEmpty services are removed. 
....................  *  
....................  *              01.09.2010      New services added: OS_Squeue_Get, OS_Squeue_Get_I, OS_Squeue_Delete, OS_Squeue_Delete_I 
....................  * 
....................  *********************************************************************************************** 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                    Q U E U E   O F   S I M P L E    M E S S A G E S                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #ifdef OS_ENABLE_SQUEUE 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................     #if defined(OS_QUEUE_SQUEUE_IDENTICAL) 
....................  
....................         // If size of pointer to message eq. to size of simple message then we 
....................         // can use same functions for sending and getting messages. 
....................         // 
....................         #define _OS_Squeue_Send(pSQueue,SMsg)      _OS_Queue_Send((OST_QUEUE*)pSQueue, (OST_MSG)SMsg) 
....................         #define _OS_Squeue_Send_I(pSQueue,SMsg)    _OS_Queue_Send_I((OST_QUEUE*)pSQueue, (OST_MSG)SMsg) 
....................         #define _OS_Squeue_Get(pSQueue)            _OS_Queue_Get((OST_QUEUE*)pSQueue) 
....................         #define _OS_Squeue_Get_I(pSQueue)          _OS_Queue_Get_I((OST_QUEUE*)pSQueue) 
....................  
....................     #else 
....................  
....................         extern void         _OS_Squeue_Send (OST_SQUEUE * pSQueue, OST_SMSG SMsg); 
....................         extern OST_SMSG     _OS_Squeue_Get (OST_SQUEUE *pSQueue); 
....................  
....................     #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Create queue 
....................  
.................... #define OS_Squeue_Create(squeue, buffer, size)               \ 
....................     OSM_BEGIN {                                              \ 
....................         __OS_QUEUE_DI();                                     \ 
....................         (squeue).Q.cSize = size;                             \ 
....................         (squeue).Q.cBegin = 0;                               \ 
....................         (squeue).Q.cFilled = 0;                              \ 
....................         (squeue).pSMsg = (OST_SMSG*)(buffer);                \ 
....................         __OS_QUEUE_RI();                                     \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define __OS_Squeue_Check(squeue)       ((squeue).Q.cFilled) 
....................  
.................... // Check for queue is full 
.................... #define __OS_Squeue_IsFull(squeue)      ((squeue).Q.cFilled == (squeue).Q.cSize) 
....................  
.................... // Check for any message present in queue 
.................... #define OS_Squeue_Check(squeue)         __OS_Squeue_Check(squeue) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Clear queue 
....................  
.................... #define OS_Squeue_Clear(squeue)        { (squeue).Q.cFilled = 0; } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Send message via queue. If queue is full then most rearly message will be pushed out. 
....................  
.................... #define OS_Squeue_Send_Now(squeue, value)                               \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         _OS_Squeue_Send((OST_SQUEUE*)&(squeue), (OST_SMSG)(value));     \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define __OS_Squeue_Accept(squeue,os_smsg_type_var)                     \ 
....................     OSM_BEGIN {                                                         \ 
....................         os_smsg_type_var = _OS_Squeue_Get((OST_SQUEUE*)&(squeue));      \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Squeue_Accept(squeue,os_smsg_type_var)                       \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         __OS_Squeue_Accept(squeue,os_smsg_type_var);                    \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Squeue_Delete(squeue)                                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         _OS_Squeue_Get((OST_SQUEUE*)&(squeue));                         \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Squeue_Get(squeue,os_smsg_type_var)                          \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_QUEUE_DI();                                                \ 
....................         os_smsg_type_var = (squeue).pSMsg[(squeue).Q.cBegin];           \ 
....................         __OS_QUEUE_RI();                                                \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Send message via queue from interrupt. If queue is full then most rearly message will be pushed out. 
.................... #if defined(OS_ENABLE_INT_QUEUE) 
....................  
....................     extern void     _OS_Squeue_Send_I (OST_SQUEUE *pSQueue, OST_SMSG SMsg); 
....................     extern OST_SMSG _OS_Squeue_Get_I  (OST_SQUEUE *pSQueue); 
....................  
....................  
....................     #define OS_Squeue_Send_I(squeue, value)   _OS_Squeue_Send_I((OST_SQUEUE*)&(squeue), (OST_SMSG)(value)) 
....................     #define OS_Squeue_Accept_I(squeue,os_smsg_type_var) os_smsg_type_var = _OS_Squeue_Get_I((OST_SQUEUE*)&(squeue)) 
....................  
....................     #define OS_Squeue_Check_I(squeue)         __OS_Squeue_Check(squeue) 
....................     #define OS_Squeue_Clear_I(squeue)         OS_Squeue_Clear(squeue) 
....................     #define OS_Squeue_IsFull_I(squeue)        __OS_Squeue_IsFull(squeue) 
....................  
....................  
....................     #define OS_Squeue_Delete_I(squeue)                  _OS_Squeue_Get_I((OST_SQUEUE*)&(squeue))     
....................     #define OS_Squeue_Get_I(squeue,os_smsg_type_var)    os_smsg_type_var = (squeue).pSMsg[(squeue).Q.cBegin]  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place 
....................  
....................     #define OS_Squeue_Send(squeue, value)                                   \ 
....................         OSM_BEGIN {                                                         \ 
....................             __OS_QUEUE_DI();                                                \ 
....................             while (__OS_Squeue_IsFull(squeue))                              \ 
....................             {                                                               \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................                 OS_Wait(!__OS_Squeue_IsFull(squeue));                \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................             }                                                               \ 
....................             _OS_Squeue_Send((OST_SQUEUE*)&(squeue), (OST_SMSG)(value));     \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place. Exit if timeout expired. 
....................  
....................     #define OS_Squeue_Send_TO(squeue, value, timeout)                       \ 
....................         OSM_BEGIN {                                                         \ 
....................             _OS_Flags.bTimeout = 0;                                          \ 
....................             __OS_QUEUE_DI();                                                \ 
....................             while (__OS_Squeue_IsFull(squeue) && !OS_IsTimeout())           \ 
....................             {                                                               \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................                 OS_Wait_TO(!__OS_Squeue_IsFull(squeue), timeout);\ 
....................                 __OS_QUEUE_DI();                                            \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 _OS_Squeue_Send((OST_SQUEUE*)&(squeue), (OST_SMSG)(value)); \ 
....................             }                                                               \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................     // Wait message from queue. After accepting message will be deleted from queue. 
....................  
....................     #define OS_Squeue_Wait(squeue, os_smsg_type_var)                        \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait(__OS_Squeue_Check(squeue));                  \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................                 if (__OS_Squeue_Check(squeue)) break;                       \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................             }                                                               \ 
....................             __OS_Squeue_Accept(squeue,os_smsg_type_var);                    \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. Exit if timeout expired. 
....................  
....................     #define OS_Squeue_Wait_TO(squeue, os_smsg_type_var, timeout)            \ 
....................         OSM_BEGIN {                                                         \ 
....................             for (;;) {                                                      \ 
....................                 OS_Wait_TO(__OS_Squeue_Check(squeue), timeout); \ 
....................                 __OS_QUEUE_DI();                                            \ 
....................                 if (__OS_Squeue_Check(squeue) || OS_IsTimeout()) break;     \ 
....................                 __OS_QUEUE_RI();                                            \ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout())                                            \ 
....................             {                                                               \ 
....................                 __OS_Squeue_Accept(squeue,os_smsg_type_var);                \ 
....................             }                                                               \ 
....................             __OS_QUEUE_RI();                                                \ 
....................         } OSM_END 
....................  
....................  
....................     // Check for queue is full 
....................     #define OS_Squeue_IsFull(squeue)    (__OS_QUEUE_DI(),_OS_Temp=__OS_Squeue_IsFull(squeue),__OS_QUEUE_RI(),_OS_Temp) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   // OS_ENABLE_INT_QUEUE 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place 
....................  
....................     #define OS_Squeue_Send(squeue, value)                                   \ 
....................         OSM_BEGIN {                                                         \ 
....................             if (__OS_Squeue_IsFull(squeue))                                 \ 
....................             {                                                               \ 
....................                 OS_Wait(!__OS_Squeue_IsFull(squeue));                \ 
....................             }                                                               \ 
....................             _OS_Squeue_Send((OST_SQUEUE*)&(squeue), (OST_SMSG)(value));     \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Send message via queue. If queue full then wait for free place. Exit if timeout expired. 
....................  
....................     #define OS_Squeue_Send_TO(squeue, value, timeout)                       \ 
....................         OSM_BEGIN {                                                         \ 
....................             _OS_Flags.bTimeout = 0;                                          \ 
....................             if (__OS_Squeue_IsFull(squeue))                                 \ 
....................             {                                                               \ 
....................                 OS_Wait_TO(!__OS_Squeue_IsFull(squeue), timeout);\ 
....................             }                                                               \ 
....................             if (!OS_IsTimeout()) {                                          \ 
....................                 _OS_Squeue_Send((OST_SQUEUE*)&(squeue), (OST_SMSG)(value)); \ 
....................             }                                                               \ 
....................         } OSM_END 
....................  
....................     // Wait message from queue. After accepting message will be deleted from queue. 
....................  
....................     #define OS_Squeue_Wait(squeue, os_smsg_type_var)                        \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait(__OS_Squeue_Check(squeue));                      \ 
....................             __OS_Squeue_Accept(squeue,os_smsg_type_var);                    \ 
....................         } OSM_END 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Wait message from queue. After accepting message will be deleted from queue. Exit if timeout expired. 
....................  
....................     #define OS_Squeue_Wait_TO(squeue, os_smsg_type_var, timeout)            \ 
....................         OSM_BEGIN {                                                         \ 
....................             OS_Wait_TO(__OS_Squeue_Check(squeue), timeout);     \ 
....................             if (!OS_IsTimeout())                                            \ 
....................             {                                                               \ 
....................                 __OS_Squeue_Accept(squeue,os_smsg_type_var);                \ 
....................             }                                                               \ 
....................         } OSM_END 
....................  
....................  
....................     // Check for queue is full 
....................     #define OS_Squeue_IsFull(squeue)       __OS_Squeue_IsFull(squeue) 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_INT_QUEUE 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Alternate names 
.................... //****************************************************************************** 
....................  
.................... #ifndef __OSACCS__  // To avoid "Warning: dublicate define" 
....................  
.................... #define OS_SQueue_Create        OS_Squeue_Create 
.................... #define OS_SQueue_Check         OS_Squeue_Check 
.................... #define OS_SQueue_IsFull        OS_Squeue_IsFull 
.................... #define OS_SQueue_Send          OS_Squeue_Send 
.................... #define OS_SQueue_Send_TO       OS_Squeue_Send_TO 
.................... #define OS_SQueue_Send_Now      OS_Squeue_Send_Now 
.................... #define OS_SQueue_Send_I        OS_Squeue_Send_I 
.................... #define OS_SQueue_Wait          OS_Squeue_Wait 
.................... #define OS_SQueue_Wait_TO       OS_Squeue_Wait_TO 
....................  
.................... #endif  // __OSACCS__ 
....................  
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "kernel\timers\osa_stimer.h"       // Static timers 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_stimer.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for work with static timers  
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        02.10.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                         S T A T I C   T I M E R S   S E R V I C E S                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_STIMERS > 0 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
.................... extern  volatile OS_STIMERS_BANK     OS_STIMER_TYPE     _OS_Stimers[OS_STIMERS]    ; 
....................  
.................... #ifdef OS_STIMERS_ENABLE_ALLOCATION     
.................... extern  OS_STIMERS_BANK     OST_UINT   _OS_StimersFree[(OS_STIMERS + _OST_INT_SIZE-1) / _OST_INT_SIZE]; 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
.................... #ifdef OS_STIMERS_ENABLE_ALLOCATION 
....................  
....................     OST_UINT8   _OS_Stimer_GetFree  (OST_UINT bCreate); 
....................     void        _OS_Stimer_Free     (OST_UINT8 ID); 
....................  
.................... #endif 
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #if defined(OS_PROTECT_MEMORY_ACCESS) 
....................     #define __OS_STIMER_DI_A()  _OS_DI_INT() 
....................     #define __OS_STIMER_RI_A()  _OS_RI_INT() 
.................... #else 
....................     #define __OS_STIMER_DI_A() 
....................     #define __OS_STIMER_RI_A() 
.................... #endif 
....................  
....................  
.................... #define OS_STIMER_ATOMIC_WRITE_A(expr)  \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_STIMER_DI_A();             \ 
....................         expr;                           \ 
....................         __OS_STIMER_RI_A();             \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... #if     OS_STIMER_SIZE == 1 
....................     #define OS_STIMER_RUN_BIT   0x80 
.................... #elif   OS_STIMER_SIZE == 2 
....................     #define OS_STIMER_RUN_BIT   0x8000 
.................... #elif   OS_STIMER_SIZE == 4 
....................     #define OS_STIMER_RUN_BIT   0x80000000UL 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... #ifdef OS_STIMERS_ENABLE_ALLOCATION  
....................  
....................     #define OS_Stimer_Alloc(var_stimer_id)     var_stimer_id = _OS_Stimer_GetFree(1) 
....................     #define OS_Stimer_Free(stimer_id)         _OS_Stimer_Free(stimer_id) 
....................  
....................     #define OS_Stimer_Found()                   (_OS_Stimer_GetFree (0) != 0xFF) 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Check timer's states                                                 */ 
.................... /************************************************************************/ 
....................  
.................... #ifdef __OSA_PIC16_MIKROC__ 
....................     #define OS_Stimer_Check(stimer_id)   (!(*((char*)&_OS_Stimers[stimer_id]+(OS_STIMER_SIZE-1)) & 0x80)) 
....................     #define OS_Stimer_IsRun(stimer_id)     (*((char*)&_OS_Stimers[stimer_id]+(OS_STIMER_SIZE-1)) & 0x80) 
.................... #else 
....................     #define OS_Stimer_Check(stimer_id)   (!(_OS_Stimers[stimer_id] & OS_STIMER_RUN_BIT)) 
....................     #define OS_Stimer_IsRun(stimer_id)     (_OS_Stimers[stimer_id] & OS_STIMER_RUN_BIT) 
.................... #endif 
....................  
....................  
.................... /************************************************************************/ 
.................... /* Run/Break timer for counting                                         */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Stimer_Run(stimer_id, time)                                  \ 
....................     {                                                                   \ 
....................         OS_Stimer_Stop(stimer_id);                                      \ 
....................         _OS_Stimers[stimer_id] = -(OS_STIMER_TYPE)(time);               \ 
....................     } 
....................  
....................     // At the end of this macro we can't set bit Run since before we do it, 
....................     // flag can became clear in interrupt. 
....................  
.................... #define OS_Stimer_Break(stimer_id)   OS_STIMER_ATOMIC_WRITE_A(_OS_Stimers[stimer_id] = 0)    
....................  
....................  
.................... /************************************************************************/ 
.................... /* Pause/continue timer                                                 */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Stimer_Pause(stimer_id)      OS_STIMER_ATOMIC_WRITE_A(_OS_Stimers[stimer_id] &= ~OS_STIMER_RUN_BIT) 
.................... #define OS_Stimer_Continue(stimer_id)   OS_STIMER_ATOMIC_WRITE_A(_OS_Stimers[stimer_id] |= OS_STIMER_RUN_BIT) 
....................  
....................  
.................... /************************************************************************/ 
.................... /* Get remaining time of counting                                       */ 
.................... /* It is nessesary to disable interrupt ehile reading STimer value      */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Stimer_Get(stimer_id)    (OS_Stimer_Check(stimer_id)? (_OS_Stimers[stimer_id]):(-_OS_Stimers[stimer_id])) 
....................  
....................  
.................... /************************************************************************/ 
.................... /* Continue counting after pause                                        */ 
.................... /************************************************************************/ 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Wait for timer overflow                                              */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Stimer_Wait(stimer_id)                   \ 
....................     {                                               \ 
....................         OS_Wait(OS_Stimer_Check(stimer_id)); \ 
....................     } 
....................  
....................  
.................... /************************************************************************/ 
.................... /* Delay current task using static timer                                */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Stimer_Delay(stimer_id, delay)           \ 
....................     {                                               \ 
....................         OS_Stimer_Run(stimer_id, delay);            \ 
....................         OS_Stimer_Wait(stimer_id);                  \ 
....................     } 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // OLD SERVICES 
.................... //------------------------------------------------------------------------------ 
.................... #define OS_Stimer_Stop(stimer_id)    OS_STIMER_ATOMIC_WRITE_A(_OS_Stimers[stimer_id] &= ~OS_STIMER_RUN_BIT) 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_STIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "kernel\timers\osa_stimer_old.h"   // Old style static timers 
.................... /* 
....................  *********************************************************************************************** 
....................  *                                                                                               
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  *                                                                                               
....................  *  OSA is distributed under BSD license (see license.txt)                                       
....................  *                                                                                               
....................  *  URL:        http://wiki.pic24.ru/doku.php/en/osa/ref/intro                                   
....................  *              http://picosa.narod.ru                                                           
....................  *                                                                                               
....................  *---------------------------------------------------------------------------------------------- 
....................  *                                                                                               
....................  *  File:       osa_stimer_old.h                                                                 
....................  *                                                                                               
....................  *  Programmer: Timofeev Victor                                                                  
....................  *              osa@pic24.ru, testerplus@mail.ru                                                 
....................  *                                                                                               
....................  *  Definition: Services with old static services                                                
....................  *                                                                                               
....................  *  History:    21.01.2009                                                                       
....................  *                                                                                               
....................  *  (not recommended to use. use STimers instead (see osa_stimers.h)                             
....................  *                                                                                               
....................  *                                                                                               
....................  *********************************************************************************************** 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                           O L D   S T Y L E   S T A T I C   T I M E R S                      * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
.................... #if OS_TIMERS > 0 
.................... extern  OS_TIMEOUTS_BANK    OST_UINT      OS_Timeouts[]; 
.................... #endif 
....................  
.................... #if OS_TIMERS32 > 0 
.................... extern  OS_TIMERS32_BANK    OST_UINT32    OS_Timers32[]; 
.................... #endif 
....................  
.................... #if OS_TIMERS24 > 0 
.................... extern  OS_TIMERS24_BANK    OST_UINT16    OS_Timers24[]; 
.................... #endif 
....................  
.................... #if OS_TIMERS16 > 0 
.................... extern  OS_TIMERS16_BANK    OST_UINT16    OS_Timers16[]; 
.................... #endif 
....................  
.................... #if OS_TIMERS8  > 0 
.................... extern  OS_TIMERS8_BANK     OST_UINT8     OS_Timers8[]; 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_TIMERS24 > 0 
.................... extern volatile OS_BANK OST_UINT    OS_Ticks;   // Prescaler for 24-bit old style static timers 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... #define _OS_TMR_POS(timer_id)   ((timer_id) >> _OST_INT_SHIFT) 
.................... #define _OS_TMR_MASK(timer_id)  (1 << ((timer_id) & _OST_INT_MASK)) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Stop timer 
....................  
.................... #define OS_Oldtimer_Pause(timer_id)     OS_Timeouts[_OS_TMR_POS(timer_id)] &= ~_OS_TMR_MASK(timer_id)    
.................... #define OS_Oldtimer_Continue(timer_id)  OS_Timeouts[_OS_TMR_POS(timer_id)] |=  _OS_TMR_MASK(timer_id)    
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run timer (internal system macro) 
....................  
.................... #define _OS_RunTimer(timer_id)  OS_Timeouts[_OS_TMR_POS(timer_id)] |=  _OS_TMR_MASK(timer_id) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Check for overflow 
....................  
.................... #define OS_Oldtimer_Check(timer_id) !(OS_Timeouts[_OS_TMR_POS(timer_id)] & _OS_TMR_MASK(timer_id)) 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Check for timer is running 
....................  
.................... #define OS_IsTimerRun(timer_id) (OS_Timeouts[_OS_TMR_POS(timer_id)] & _OS_TMR_MASK(timer_id)) 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run 8-bit timer 
....................  
.................... #define OS_Oldtimer_Run8(timer_id, time)                                    \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Pause(timer_id);                                         \ 
....................         OS_Timers8 [timer_id] = -(time);                                    \ 
....................         _OS_RunTimer(timer_id);                                             \ 
....................     } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run 16-bit timer 
....................  
.................... #define OS_Oldtimer_Run16(timer_id, time)                                   \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Pause(timer_id);                                         \ 
....................         OS_Timers16[(timer_id) - _OS_TIMER16_POS] = -(time);                \ 
....................         _OS_RunTimer(timer_id);                                             \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run 24-bit timer 
....................  
.................... #define OS_Oldtimer_Run24(timer_id, time)                                   \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Pause(timer_id);                                         \ 
....................         OS_Timers24[(timer_id) - _OS_TIMER24_POS] = - (((time) + 128) >> 8);\ 
....................         _OS_RunTimer(timer_id);                                             \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run 24-bit timer withowt recounting prescaler (not recomended to use) 
....................  
.................... #define OS_Oldtimer_Run24prs(timer_id, time)                                \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Pause(timer_id);                                         \ 
....................         OS_Timers24[(timer_id) - _OS_TIMER24_POS] = -(time);                \ 
....................         _OS_RunTimer(timer_id);                                             \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Run 32-bit timer 
....................  
.................... #define OS_Oldtimer_Run32(timer_id, time)                                   \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Pause(timer_id);                                         \ 
....................         OS_Timers32[(timer_id) - _OS_TIMER32_POS] = -(time);                \ 
....................         _OS_RunTimer(timer_id);                                             \ 
....................     } 
.................... //------------------------------------------------------------------------------ 
.................... // Wait for timer overflowed 
....................  
.................... #define OS_Oldtimer_Wait(timer_id)                                          \ 
....................     {                                                                       \ 
....................         OS_Wait(OS_Oldtimer_Check(timer_id));                        \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Delay current task using old style static timer 
.................... #define OS_DelayTimer8(timer_id, delay)                                     \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Run8(timer_id, delay);                                  \ 
....................         OS_Oldtimer_Wait(timer_id);                                         \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define OS_DelayTimer16(timer_id, delay)                                    \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Run16(timer_id, delay);                                 \ 
....................         OS_Oldtimer_Wait(timer_id);                                         \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define OS_DelayTimer24(timer_id, delay)                                    \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Run24(timer_id, delay);                                 \ 
....................         OS_Oldtimer_Wait(timer_id);                                         \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define OS_DelayTimer32(timer_id, delay)                                    \ 
....................     {                                                                       \ 
....................         OS_Oldtimer_Run32(timer_id, delay);                                 \ 
....................         OS_Oldtimer_Wait(timer_id);                                         \ 
....................     } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "kernel\timers\osa_dtimer.h"       // Dynamic timers 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_dtimer.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Dynamic timers specific macros 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        02.10.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                 D Y N A M I C   T I M E R S                                  * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
.................... extern OS_BANK  OST_DTIMER_CB   _OS_DTimers; 
....................  
....................  
.................... #ifndef _OS_DtimersWork_DEFINED 
.................... extern OST_DTIMER *    _OS_DtimerWork; 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
.................... void _OS_Dtimer_Create (OST_DTIMER *dtimer); 
.................... void _OS_Dtimer_Delete (OST_DTIMER *dtimer); 
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #if defined(OS_PROTECT_MEMORY_ACCESS) 
....................     #define __OS_DTIMER_DI_A()  _OS_DI_INT() 
....................     #define __OS_DTIMER_RI_A()  _OS_RI_INT() 
.................... #else 
....................     #define __OS_DTIMER_DI_A() 
....................     #define __OS_DTIMER_RI_A() 
.................... #endif 
....................  
....................  
.................... #define OS_DTIMER_ATOMIC_WRITE_A(expr)  \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_DTIMER_DI_A();             \ 
....................         expr;                           \ 
....................         __OS_DTIMER_RI_A();             \ 
....................     } OSM_END 
....................  
.................... #define OS_DTIMER_ATOMIC_READ_A(expr)                                       \ 
....................     (__OS_DTIMER_DI_A(), _OS_Temp = (expr), __OS_DTIMER_RI_A(), _OS_Temp)   \ 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... /************************************************************************/ 
.................... /* Create and delete dynamic timers                                     */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Dtimer_Create(dtimer)     _OS_Dtimer_Create(&dtimer) 
.................... #define OS_Dtimer_Delete(dtimer)     _OS_Dtimer_Delete(&dtimer) 
....................  
.................... /************************************************************************/ 
.................... /* Check dynamic timer's states                                         */ 
.................... /************************************************************************/ 
....................  
.................... #define OS_Dtimer_Check(dtimer)         ((dtimer).Flags.bTimeout)       // overflowed 
.................... #define OS_Dtimer_IsActive(dtimer)      ((dtimer).Flags.bActive)        // created 
.................... #define OS_Dtimer_IsStopped(dtimer)     (!((dtimer).Flags.bRun))        // stopped 
.................... #define OS_Dtimer_IsRun(dtimer)         ((dtimer).Flags.bRun)           // run 
....................  
.................... #define OS_Dtimer_Check_I(dtimer)       ((dtimer).Flags.bTimeout)       // overflowed 
.................... #define OS_Dtimer_IsActive_I(dtimer)    ((dtimer).Flags.bActive)        // created 
.................... #define OS_Dtimer_IsStopped_I(dtimer)   (!((dtimer).Flags.bRun))        // stopped 
.................... #define OS_Dtimer_IsRun_I(dtimer)       ((dtimer).Flags.bRun)           // run 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Get remaining time of counting 
.................... #define OS_Dtimer_Get(dtimer)      (-(dtimer).Timer) 
.................... #define OS_Dtimer_Get_I(dtimer)    (-(dtimer).Timer) 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Stop, pause and continue counting                                    */ 
.................... /************************************************************************/ 
....................  
.................... #define __OS_Dtimer_Stop(dtimer)        (dtimer).Flags.bRun = 0        // Stop timer (pause it) 
.................... #define __OS_Dtimer_Pause(dtimer)       (dtimer).Flags.bRun = 0        // Stop timer (pause it) 
.................... #define __OS_Dtimer_Continue(dtimer)    (dtimer).Flags.bRun = 1        // Continue after pause 
.................... #define __OS_Dtimer_Break(dtimer)       (dtimer).Flags.bTimeout = 1    // 
....................  
.................... #define OS_Dtimer_Stop(dtimer)          OS_DTIMER_ATOMIC_WRITE_A(__OS_Dtimer_Stop(dtimer)) 
.................... #define OS_Dtimer_Pause(dtimer)         OS_DTIMER_ATOMIC_WRITE_A(__OS_Dtimer_Pause(dtimer)) 
.................... #define OS_Dtimer_Continue(dtimer)      OS_DTIMER_ATOMIC_WRITE_A(__OS_Dtimer_Continue(dtimer)) 
.................... #define OS_Dtimer_Break(dtimer)         OS_DTIMER_ATOMIC_WRITE_A(__OS_Dtimer_Break(dtimer)) 
....................  
.................... #define OS_Dtimer_Stop_I(dtimer)        __OS_Dtimer_Stop(dtimer) 
.................... #define OS_Dtimer_Pause_I(dtimer)       __OS_Dtimer_Pause(dtimer) 
.................... #define OS_Dtimer_Continue_I(dtimer)    __OS_Dtimer_Continue(dtimer) 
.................... #define OS_Dtimer_Break_I(dtimer)       __OS_Dtimer_Break(dtimer) 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Services for run dynamic timers                                      */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Start counting with given time. Timeout flag is cleared. 
....................  
.................... #define OS_Dtimer_Run(dtimer, time)                         \ 
....................     OSM_BEGIN {                                             \ 
....................         OS_DTIMER_ATOMIC_WRITE_A((dtimer).Flags.bRun = 0;); \ 
....................         (dtimer).Timer =-(OS_DTIMER_TYPE)(time);            \ 
....................         OS_DTIMER_ATOMIC_WRITE_A(                           \ 
....................             (dtimer).Flags.bTimeout = 0;                    \ 
....................             (dtimer).Flags.bRun = 1;                        \ 
....................         );                                                  \ 
....................     } OSM_END 
....................  
.................... #define OS_Dtimer_Run_I(dtimer, time)                       \ 
....................     OSM_BEGIN {                                             \ 
....................         (dtimer).Flags.bRun = 0;                            \ 
....................         (dtimer).Timer = -(OS_DTIMER_TYPE)(time);           \ 
....................         (dtimer).Flags.bTimeout = 0;                        \ 
....................         (dtimer).Flags.bRun = 1;                            \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Re-run static timer for time time since last overflow. Timeout flag is cleared. 
....................  
.................... #define OS_Dtimer_Update(dtimer, time)                      \ 
....................     OSM_BEGIN {                                             \ 
....................         OS_DTIMER_ATOMIC_WRITE_A((dtimer).Flags.bRun = 0;); \ 
....................         (dtimer).Timer =-(OS_DTIMER_TYPE)(time);            \ 
....................         OS_DTIMER_ATOMIC_WRITE_A(                           \ 
....................             (dtimer).Flags.bTimeout = 0;                    \ 
....................             (dtimer).Flags.bRun = 1;                        \ 
....................         );                                                  \ 
....................     } OSM_END 
....................  
.................... #define OS_Dtimer_Update_I(dtimer, time)                    \ 
....................     OSM_BEGIN {                                             \ 
....................         (dtimer).Flags.bRun = 0;                            \ 
....................         (dtimer).Timer = -(OS_DTIMER_TYPE)(time);           \ 
....................         (dtimer).Flags.bTimeout = 0;                        \ 
....................         (dtimer).Flags.bRun = 1;                            \ 
....................     } OSM_END 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Increase time of dinamic timer counter. Timeout flag remain unchanged. 
....................  
.................... #define OS_Dtimer_Add(dtimer, time)                         \ 
....................     OSM_BEGIN {                                             \ 
....................         OS_DTIMER_ATOMIC_WRITE_A((dtimer).Flags.bRun = 0;); \ 
....................         (dtimer).Timer -= (OS_DTIMER_TYPE)(time);           \ 
....................         OS_DTIMER_ATOMIC_WRITE_A((dtimer).Flags.bRun = 1;); \ 
....................     } OSM_END 
....................  
.................... #define OS_Dtimer_Add_I(dtimer, time)                       \ 
....................     OSM_BEGIN {                                             \ 
....................         (dtimer).Flags.bRun = 0;                            \ 
....................         (dtimer).Timer -= (OS_DTIMER_TYPE)(time);           \ 
....................         (dtimer).Flags.bRun = 1;                            \ 
....................     } OSM_END 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Wait services                                                        */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Wait for dynamic timer overflowed 
....................  
.................... #define OS_Dtimer_Wait(dtimer)                  \ 
....................     {                                           \ 
....................         OS_Wait(OS_Dtimer_Check(dtimer));\ 
....................     } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Delay current task using dynamic timer 
....................  
.................... #define OS_Dtimer_Delay(dtimer, delay)          \ 
....................     {                                           \ 
....................         OS_Dtimer_Run(dtimer, delay);           \ 
....................         OS_Dtimer_Wait(dtimer);                 \ 
....................     } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_DTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "kernel\timers\osa_qtimer.h"       // Fast timers 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_qtimer.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Queue of timers specific macros 
....................  *                  This file directly included in osa.h 
....................  * 
....................  *  History:        02.10.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... #ifdef OS_ENABLE_QTIMERS 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
.................... extern OS_BANK  OST_QTIMER_CB   _OS_Qtimers; 
....................  
....................  
.................... #ifndef _OS_QtimersWork_DEFINED 
.................... extern OST_QTIMER    * OS_BANK        _OS_QtimerWork; 
.................... #endif 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // Macros for atomic access 
....................  
.................... #if defined(OS_PROTECT_MEMORY_ACCESS) 
....................     #define __OS_QTIMER_DI_A()  _OS_DI_INT() 
....................     #define __OS_QTIMER_RI_A()  _OS_RI_INT() 
.................... #else 
....................     #define __OS_QTIMER_DI_A() 
....................     #define __OS_QTIMER_RI_A() 
.................... #endif 
....................  
....................  
.................... #define OS_QTIMER_ATOMIC_WRITE_A(expr)  \ 
....................     OSM_BEGIN {                         \ 
....................         __OS_QTIMER_DI_A();             \ 
....................         expr;                           \ 
....................         __OS_QTIMER_RI_A();             \ 
....................     } OSM_END 
....................  
.................... #define OS_QTIMER_ATOMIC_READ_A(expr)                                     \ 
....................     (__OS_QTIMER_DI_A(), _OS_Temp = (expr), __OS_QTIMER_RI_A(), _OS_Temp) \ 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... OS_QTIMER_TYPE _OS_Qtimer_List  (OS_QTIMER_TYPE time, OST_QTIMER *ftimer); 
....................  
....................  
....................  
.................... #define __OS_Qtimer_Add(ftimer, time)                                   \ 
....................     OSM_BEGIN {                                                         \ 
....................         _OS_Qtimer_List(time, &(ftimer));                               \ 
....................     } OSM_END                                                           \ 
....................  
....................  
.................... #define __OS_Qtimer_Delete(ftimer)                                      \ 
....................     OSM_BEGIN {                                                         \ 
....................         _OS_Qtimers.Flags.bListFunction = OS_QTIMER_LIST_FUNCTION_DELETE;\ 
....................         _OS_Qtimer_List(0, &(ftimer));                                  \ 
....................     } OSM_END                                                           \ 
....................  
....................  
.................... #define OS_Qtimer_Check(ftimer)      ((ftimer).Flags.bTimeout)       // overflowed 
.................... #define OS_Qtimer_IsRun(ftimer)      ((ftimer).Flags.bActive)        // created 
....................  
.................... #define OS_Qtimer_Run(ftimer, time)                                     \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_Qtimer_Add(ftimer, time);                                  \ 
....................     } OSM_END                                                           \ 
....................  
....................  
.................... #define OS_Qtimer_Delete(ftimer)                                        \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_Qtimer_Delete(ftimer);                                     \ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Qtimer_Break(ftimer)                                         \ 
....................     OSM_BEGIN {                                                         \ 
....................         __OS_Qtimer_Delete(ftimer);                                     \ 
....................         OS_QTIMER_ATOMIC_WRITE_A((ftimer).Flags.bTimeout = 1);          \ 
....................     } OSM_END 
....................  
....................  
....................  
.................... #define OS_Qtimer_Create(ftimer)                                        \ 
....................     OS_QTIMER_ATOMIC_WRITE_A(                                           \ 
....................         (ftimer).Flags.bActive  = 0;                                    \ 
....................         (ftimer).Flags.bTimeout = 0;                                    \ 
....................     ) 
....................  
....................  
.................... #define OS_Qtimer_Get(ftimer)                                                       \ 
....................     (_OS_Qtimers.Flags.bListGetTime = 1, _OS_Qtimer_List(1, &(ftimer)))             \ 
....................  
....................  
....................  
.................... #define OS_Qtimer_Wait(ftimer)                  \ 
....................     OSM_BEGIN {                                 \ 
....................         OS_Wait(OS_Qtimer_Check(ftimer));\ 
....................     } OSM_END 
....................  
....................  
.................... #define OS_Qtimer_Delay(ftimer, delay)          \ 
....................     {                                           \ 
....................         OS_Qtimer_Run(ftimer, delay);           \ 
....................         OS_Qtimer_Wait(ftimer);                 \ 
....................     } 
....................  
....................  
....................  
....................  
....................  
....................  
....................   
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #endif  // OS_ENABLE_QTIMERS 
....................  
....................  
.................... #include "kernel\timers\osa_ttimer.h"       // Task timers 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_ttimer.h 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for Task Timers 
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  *  
....................  *                  25.10.2010  -   Definition of OS_Ttimer_Delay fixed 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                    T A S K   T I M E R S                                     *  
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
....................  
.................... void _OS_InitDelay(OS_TTIMER_TYPE Delay); 
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /* Delay current task                                                   */ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
.................... #define OS_Delay(delaytime)                        \ 
....................     {                                              \ 
....................         _OS_InitDelay(delaytime);                  \ 
....................         OS_Yield();                                \ 
....................     }                                              \ 
....................  
....................  
.................... #define OS_Ttimer_Delay(delaytime)   OS_Delay(delaytime)    /*101025*/ 
....................  
.................... /************************************************************************/ 
.................... // Run task timer for user purpose 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Run(delaytime)                    \ 
....................     {                                               \ 
....................         _OS_InitDelay(delaytime);                   \ 
....................         _OS_bTaskCanContinue = 1;                   \ 
....................     }                                               \ 
....................  
.................... /************************************************************************/ 
.................... // Check task timer for timeout 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Check()            !_OS_CurTask->State.bDelay 
....................  
.................... /************************************************************************/ 
.................... // Check task timer is run 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_IsRun()            _OS_CurTask->State.bDelay 
....................  
....................  
.................... /************************************************************************/ 
.................... // Get task timer's value 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Get()              (-_OS_CurTask->Timer) 
....................  
.................... /************************************************************************/ 
.................... // Wait for task timer will overflow 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Wait()             OS_Wait(OS_Ttimer_Check()) 
....................  
....................  
.................... /************************************************************************/ 
.................... // Break timer and clear counter 
.................... /************************************************************************/ 
....................  
.................... #define OS_Ttimer_Break()                           \ 
....................     _OS_TASK_ATOMIC_WRITE_A(                        \ 
....................         _OS_CurTask->State.bDelay = 0;              \ 
....................         _OS_CurTask->Timer        = 0;              \ 
....................     ) 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif          // OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\timers\osa_timer.h"        // System timer 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Services for work with system timer 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        02.10.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                          S Y S T E M   T I M E R   W O R K                                   * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //****************************************************************************** 
.................... //  VARIABLES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  FUNCTION PROTOTYPES 
.................... //****************************************************************************** 
....................  
....................  
.................... //****************************************************************************** 
.................... //  MACROS 
.................... //****************************************************************************** 
....................  
.................... #ifndef _OS_TIMER_H_ 
.................... #define _OS_TIMER_H_ 
....................  
....................  
.................... #ifdef OS_ENABLE_OS_TIMER 
....................  
....................     #ifndef OS_USE_INLINE_TIMER 
....................         extern void OS_Timer (void); 
....................     #else 
....................         #define OS_Timer()  __OS_TimerInline() 
....................     #endif 
....................  
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef _OS_DtimersWork_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #ifndef OS_ENABLE_DTIMERS 
....................     //------------------------------------------------------------------------------ 
....................  
....................         #define __OS_DtimersWork() 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #else 
....................     //------------------------------------------------------------------------------ 
....................  
....................  
....................         #define __OS_DtimersWork()                                              \ 
....................             {                                                                   \ 
....................                 _OS_DtimerWork = (OST_DTIMER*)&_OS_DTimers;                     \ 
....................                 while (_OS_DtimerWork->Flags.bNextEnable)                       \ 
....................                 {                                                               \ 
....................                   _OS_DtimerWork = (OST_DTIMER*)_OS_DtimerWork->Next;           \ 
....................                   if (!(++_OS_DtimerWork->Timer))                               \ 
....................                     _OS_DtimerWork->Flags.bTimeout |= 1;                        \ 
....................                 }                                                               \ 
....................             } 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #endif  // OS_ENABLE_DTIMER 
....................     //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef _OS_QtimersWork_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #ifndef OS_ENABLE_QTIMERS 
....................     //------------------------------------------------------------------------------ 
....................  
....................         #define __OS_QtimersWork() 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #else 
....................     //------------------------------------------------------------------------------ 
....................  
....................  
....................         #define __OS_QtimersWork()                                          \ 
....................             if (_OS_Qtimers.Flags.bNextEnable)                              \ 
....................             {                                                               \ 
....................                 _OS_QtimerWork = (OST_QTIMER*)_OS_Qtimers.Next;             \ 
....................                 _OS_QtimerWork->Timer++;                                    \ 
....................                 while (!_OS_QtimerWork->Timer)                              \ 
....................                 {                                                           \ 
....................                     _OS_QtimerWork->Flags.bTimeout = 1;                     \ 
....................                     _OS_QtimerWork->Flags.bActive  = 0;                     \ 
....................                     if (!_OS_QtimerWork->Flags.bNextEnable)                 \ 
....................                     {                                                       \ 
....................                         _OS_Qtimers.Flags.bNextEnable = 0;                  \ 
....................                         break;                                              \ 
....................                     }                                                       \ 
....................                     _OS_Qtimers.Next = _OS_QtimerWork->Next;                \ 
....................                     _OS_QtimerWork = (OST_QTIMER*)_OS_Qtimers.Next;         \ 
....................                 }                                                           \ 
....................             }                                                               \ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #endif  // OS_ENABLE_QTIMER 
....................     //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Old style static timers                                              */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_Timer8Work 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_Timer8Work(TIMER_ID)                                                               \ 
....................     {                                                                                           \ 
....................         if ((OS_Timeouts[(TIMER_ID)>>_OST_INT_SHIFT]&(1<<((TIMER_ID)&_OST_INT_MASK)))) {        \ 
....................             if (!++OS_Timers8[TIMER_ID])                                                        \ 
....................                 OS_Timeouts[(TIMER_ID)>>_OST_INT_SHIFT] &= ~(1<<((TIMER_ID)&_OST_INT_MASK));    \ 
....................         }                                                                                       \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_Timer16Work 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_Timer16Work(TIMER_ID)                                                                                          \ 
....................     {                                                                                                                       \ 
....................         if ((OS_Timeouts[(TIMER_ID+_OS_TIMER16_POS)>>_OST_INT_SHIFT]&(1<<((TIMER_ID+_OS_TIMER16_POS)&_OST_INT_MASK)))) {    \ 
....................             if (!++OS_Timers16[TIMER_ID])                                                                                   \ 
....................                 OS_Timeouts[(TIMER_ID+_OS_TIMER16_POS)>>_OST_INT_SHIFT] &= ~(1<<((TIMER_ID+_OS_TIMER16_POS)&_OST_INT_MASK));\ 
....................         }                                                                                                                   \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_Timer24Work 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_Timer24Work(TIMER_ID)                                                                                          \ 
....................     {                                                                                                                       \ 
....................         if ((OS_Timeouts[(TIMER_ID+_OS_TIMER24_POS)>>_OST_INT_SHIFT]&(1<<((TIMER_ID+_OS_TIMER24_POS)&_OST_INT_MASK)))) {    \ 
....................             if (!++OS_Timers24[TIMER_ID])                                                                                   \ 
....................                 OS_Timeouts[(TIMER_ID+_OS_TIMER24_POS)>>_OST_INT_SHIFT] &= ~(1<<((TIMER_ID+_OS_TIMER24_POS)&_OST_INT_MASK));\ 
....................         }                                                                                                                   \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_Timer32Work 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_Timer32Work(TIMER_ID)                                                                                          \ 
....................     {                                                                                                                       \ 
....................         if ((OS_Timeouts[(TIMER_ID+_OS_TIMER32_POS)>>_OST_INT_SHIFT]&(1<<((TIMER_ID+_OS_TIMER32_POS)&_OST_INT_MASK)))) {    \ 
....................             if (!++OS_Timers32[TIMER_ID])                                                                                   \ 
....................                 OS_Timeouts[(TIMER_ID+_OS_TIMER32_POS)>>_OST_INT_SHIFT] &= ~(1<<((TIMER_ID+_OS_TIMER32_POS)&_OST_INT_MASK));\ 
....................         }                                                                                                                   \ 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* Task timers                                                          */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_TtimerWork 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_TtimerWork(TASK_ID)                                                    \ 
....................     if (_OS_Tasks[TASK_ID].State.bDelay)                                          \ 
....................     {                                                                               \ 
....................         if(!++_OS_Tasks[TASK_ID].Timer) _OS_Tasks[TASK_ID].State.bDelay = 0;    \ 
....................     }                                                                               \ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /* New style static timers                                              */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OS_StimerWork 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define __OS_StimerWork(STIMER_ID)                                                  \ 
....................     if (_OS_Stimers[STIMER_ID] & OS_STIMER_RUN_BIT)                                   \ 
....................     {                                                                               \ 
....................         _OS_Stimers[STIMER_ID]++;                                                     \ 
....................     }                                                                               \ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                         C O M M O N   T I M E R ' S   M A C R O S                             * 
....................  *                                                                                               * 
....................  ************************************************************************************************/ 
....................  
.................... #if OS_TIMERS8 > 0 
.................... #define __OS_Timer8Work0()    __OS_Timer8Work(0) 
.................... #else 
.................... #define __OS_Timer8Work0() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 1 
.................... #define __OS_Timer8Work1()    __OS_Timer8Work(1) 
.................... #else 
.................... #define __OS_Timer8Work1() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 2 
.................... #define __OS_Timer8Work2()    __OS_Timer8Work(2) 
.................... #else 
.................... #define __OS_Timer8Work2() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 3 
.................... #define __OS_Timer8Work3()    __OS_Timer8Work(3) 
.................... #else 
.................... #define __OS_Timer8Work3() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 4 
.................... #define __OS_Timer8Work4()    __OS_Timer8Work(4) 
.................... #else 
.................... #define __OS_Timer8Work4() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 5 
.................... #define __OS_Timer8Work5()    __OS_Timer8Work(5) 
.................... #else 
.................... #define __OS_Timer8Work5() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 6 
.................... #define __OS_Timer8Work6()    __OS_Timer8Work(6) 
.................... #else 
.................... #define __OS_Timer8Work6() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 7 
.................... #define __OS_Timer8Work7()    __OS_Timer8Work(7) 
.................... #else 
.................... #define __OS_Timer8Work7() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 8 
.................... #define __OS_Timer8Work8()    __OS_Timer8Work(8) 
.................... #else 
.................... #define __OS_Timer8Work8() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 9 
.................... #define __OS_Timer8Work9()    __OS_Timer8Work(9) 
.................... #else 
.................... #define __OS_Timer8Work9() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 10 
.................... #define __OS_Timer8Work10()    __OS_Timer8Work(10) 
.................... #else 
.................... #define __OS_Timer8Work10() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 11 
.................... #define __OS_Timer8Work11()    __OS_Timer8Work(11) 
.................... #else 
.................... #define __OS_Timer8Work11() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 12 
.................... #define __OS_Timer8Work12()    __OS_Timer8Work(12) 
.................... #else 
.................... #define __OS_Timer8Work12() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 13 
.................... #define __OS_Timer8Work13()    __OS_Timer8Work(13) 
.................... #else 
.................... #define __OS_Timer8Work13() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 14 
.................... #define __OS_Timer8Work14()    __OS_Timer8Work(14) 
.................... #else 
.................... #define __OS_Timer8Work14() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 15 
.................... #define __OS_Timer8Work15()    __OS_Timer8Work(15) 
.................... #else 
.................... #define __OS_Timer8Work15() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 16 
.................... #define __OS_Timer8Work16()    __OS_Timer8Work(16) 
.................... #else 
.................... #define __OS_Timer8Work16() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 17 
.................... #define __OS_Timer8Work17()    __OS_Timer8Work(17) 
.................... #else 
.................... #define __OS_Timer8Work17() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 18 
.................... #define __OS_Timer8Work18()    __OS_Timer8Work(18) 
.................... #else 
.................... #define __OS_Timer8Work18() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 19 
.................... #define __OS_Timer8Work19()    __OS_Timer8Work(19) 
.................... #else 
.................... #define __OS_Timer8Work19() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 20 
.................... #define __OS_Timer8Work20()    __OS_Timer8Work(20) 
.................... #else 
.................... #define __OS_Timer8Work20() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 21 
.................... #define __OS_Timer8Work21()    __OS_Timer8Work(21) 
.................... #else 
.................... #define __OS_Timer8Work21() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 22 
.................... #define __OS_Timer8Work22()    __OS_Timer8Work(22) 
.................... #else 
.................... #define __OS_Timer8Work22() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 23 
.................... #define __OS_Timer8Work23()    __OS_Timer8Work(23) 
.................... #else 
.................... #define __OS_Timer8Work23() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 24 
.................... #define __OS_Timer8Work24()    __OS_Timer8Work(24) 
.................... #else 
.................... #define __OS_Timer8Work24() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 25 
.................... #define __OS_Timer8Work25()    __OS_Timer8Work(25) 
.................... #else 
.................... #define __OS_Timer8Work25() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 26 
.................... #define __OS_Timer8Work26()    __OS_Timer8Work(26) 
.................... #else 
.................... #define __OS_Timer8Work26() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 27 
.................... #define __OS_Timer8Work27()    __OS_Timer8Work(27) 
.................... #else 
.................... #define __OS_Timer8Work27() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 28 
.................... #define __OS_Timer8Work28()    __OS_Timer8Work(28) 
.................... #else 
.................... #define __OS_Timer8Work28() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 29 
.................... #define __OS_Timer8Work29()    __OS_Timer8Work(29) 
.................... #else 
.................... #define __OS_Timer8Work29() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 30 
.................... #define __OS_Timer8Work30()    __OS_Timer8Work(30) 
.................... #else 
.................... #define __OS_Timer8Work30() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS8 > 31 
.................... #define __OS_Timer8Work31()    __OS_Timer8Work(31) 
.................... #else 
.................... #define __OS_Timer8Work31() 
.................... #endif 
.................... //.............................................................................. 
....................  
....................  
.................... //______________________________________________________________________________ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 0 
.................... #define __OS_Timer16Work0()    __OS_Timer16Work(0) 
.................... #else 
.................... #define __OS_Timer16Work0() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 1 
.................... #define __OS_Timer16Work1()    __OS_Timer16Work(1) 
.................... #else 
.................... #define __OS_Timer16Work1() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 2 
.................... #define __OS_Timer16Work2()    __OS_Timer16Work(2) 
.................... #else 
.................... #define __OS_Timer16Work2() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 3 
.................... #define __OS_Timer16Work3()    __OS_Timer16Work(3) 
.................... #else 
.................... #define __OS_Timer16Work3() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 4 
.................... #define __OS_Timer16Work4()    __OS_Timer16Work(4) 
.................... #else 
.................... #define __OS_Timer16Work4() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 5 
.................... #define __OS_Timer16Work5()    __OS_Timer16Work(5) 
.................... #else 
.................... #define __OS_Timer16Work5() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 6 
.................... #define __OS_Timer16Work6()    __OS_Timer16Work(6) 
.................... #else 
.................... #define __OS_Timer16Work6() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 7 
.................... #define __OS_Timer16Work7()    __OS_Timer16Work(7) 
.................... #else 
.................... #define __OS_Timer16Work7() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 8 
.................... #define __OS_Timer16Work8()    __OS_Timer16Work(8) 
.................... #else 
.................... #define __OS_Timer16Work8() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 9 
.................... #define __OS_Timer16Work9()    __OS_Timer16Work(9) 
.................... #else 
.................... #define __OS_Timer16Work9() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 10 
.................... #define __OS_Timer16Work10()    __OS_Timer16Work(10) 
.................... #else 
.................... #define __OS_Timer16Work10() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 11 
.................... #define __OS_Timer16Work11()    __OS_Timer16Work(11) 
.................... #else 
.................... #define __OS_Timer16Work11() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 12 
.................... #define __OS_Timer16Work12()    __OS_Timer16Work(12) 
.................... #else 
.................... #define __OS_Timer16Work12() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 13 
.................... #define __OS_Timer16Work13()    __OS_Timer16Work(13) 
.................... #else 
.................... #define __OS_Timer16Work13() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 14 
.................... #define __OS_Timer16Work14()    __OS_Timer16Work(14) 
.................... #else 
.................... #define __OS_Timer16Work14() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 15 
.................... #define __OS_Timer16Work15()    __OS_Timer16Work(15) 
.................... #else 
.................... #define __OS_Timer16Work15() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 16 
.................... #define __OS_Timer16Work16()    __OS_Timer16Work(16) 
.................... #else 
.................... #define __OS_Timer16Work16() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 17 
.................... #define __OS_Timer16Work17()    __OS_Timer16Work(17) 
.................... #else 
.................... #define __OS_Timer16Work17() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 18 
.................... #define __OS_Timer16Work18()    __OS_Timer16Work(18) 
.................... #else 
.................... #define __OS_Timer16Work18() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 19 
.................... #define __OS_Timer16Work19()    __OS_Timer16Work(19) 
.................... #else 
.................... #define __OS_Timer16Work19() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 20 
.................... #define __OS_Timer16Work20()    __OS_Timer16Work(20) 
.................... #else 
.................... #define __OS_Timer16Work20() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 21 
.................... #define __OS_Timer16Work21()    __OS_Timer16Work(21) 
.................... #else 
.................... #define __OS_Timer16Work21() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 22 
.................... #define __OS_Timer16Work22()    __OS_Timer16Work(22) 
.................... #else 
.................... #define __OS_Timer16Work22() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 23 
.................... #define __OS_Timer16Work23()    __OS_Timer16Work(23) 
.................... #else 
.................... #define __OS_Timer16Work23() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 24 
.................... #define __OS_Timer16Work24()    __OS_Timer16Work(24) 
.................... #else 
.................... #define __OS_Timer16Work24() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 25 
.................... #define __OS_Timer16Work25()    __OS_Timer16Work(25) 
.................... #else 
.................... #define __OS_Timer16Work25() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 26 
.................... #define __OS_Timer16Work26()    __OS_Timer16Work(26) 
.................... #else 
.................... #define __OS_Timer16Work26() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 27 
.................... #define __OS_Timer16Work27()    __OS_Timer16Work(27) 
.................... #else 
.................... #define __OS_Timer16Work27() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 28 
.................... #define __OS_Timer16Work28()    __OS_Timer16Work(28) 
.................... #else 
.................... #define __OS_Timer16Work28() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 29 
.................... #define __OS_Timer16Work29()    __OS_Timer16Work(29) 
.................... #else 
.................... #define __OS_Timer16Work29() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 30 
.................... #define __OS_Timer16Work30()    __OS_Timer16Work(30) 
.................... #else 
.................... #define __OS_Timer16Work30() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS16 > 31 
.................... #define __OS_Timer16Work31()    __OS_Timer16Work(31) 
.................... #else 
.................... #define __OS_Timer16Work31() 
.................... #endif 
.................... //.............................................................................. 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //______________________________________________________________________________ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... #if OS_TIMERS24 > 0 
.................... #define __OS_CheckInc24()   if (!(OS_Ticks & 0xFF)) 
.................... #else 
.................... #define __OS_CheckInc24() 
.................... #endif 
....................  
....................  
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 0 
.................... #define __OS_Timer24Work0()    __OS_Timer24Work(0) 
.................... #else 
.................... #define __OS_Timer24Work0() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 1 
.................... #define __OS_Timer24Work1()    __OS_Timer24Work(1) 
.................... #else 
.................... #define __OS_Timer24Work1() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 2 
.................... #define __OS_Timer24Work2()    __OS_Timer24Work(2) 
.................... #else 
.................... #define __OS_Timer24Work2() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 3 
.................... #define __OS_Timer24Work3()    __OS_Timer24Work(3) 
.................... #else 
.................... #define __OS_Timer24Work3() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 4 
.................... #define __OS_Timer24Work4()    __OS_Timer24Work(4) 
.................... #else 
.................... #define __OS_Timer24Work4() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 5 
.................... #define __OS_Timer24Work5()    __OS_Timer24Work(5) 
.................... #else 
.................... #define __OS_Timer24Work5() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 6 
.................... #define __OS_Timer24Work6()    __OS_Timer24Work(6) 
.................... #else 
.................... #define __OS_Timer24Work6() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 7 
.................... #define __OS_Timer24Work7()    __OS_Timer24Work(7) 
.................... #else 
.................... #define __OS_Timer24Work7() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 8 
.................... #define __OS_Timer24Work8()    __OS_Timer24Work(8) 
.................... #else 
.................... #define __OS_Timer24Work8() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 9 
.................... #define __OS_Timer24Work9()    __OS_Timer24Work(9) 
.................... #else 
.................... #define __OS_Timer24Work9() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 10 
.................... #define __OS_Timer24Work10()    __OS_Timer24Work(10) 
.................... #else 
.................... #define __OS_Timer24Work10() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 11 
.................... #define __OS_Timer24Work11()    __OS_Timer24Work(11) 
.................... #else 
.................... #define __OS_Timer24Work11() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 12 
.................... #define __OS_Timer24Work12()    __OS_Timer24Work(12) 
.................... #else 
.................... #define __OS_Timer24Work12() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 13 
.................... #define __OS_Timer24Work13()    __OS_Timer24Work(13) 
.................... #else 
.................... #define __OS_Timer24Work13() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 14 
.................... #define __OS_Timer24Work14()    __OS_Timer24Work(14) 
.................... #else 
.................... #define __OS_Timer24Work14() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 15 
.................... #define __OS_Timer24Work15()    __OS_Timer24Work(15) 
.................... #else 
.................... #define __OS_Timer24Work15() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 16 
.................... #define __OS_Timer24Work16()    __OS_Timer24Work(16) 
.................... #else 
.................... #define __OS_Timer24Work16() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 17 
.................... #define __OS_Timer24Work17()    __OS_Timer24Work(17) 
.................... #else 
.................... #define __OS_Timer24Work17() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 18 
.................... #define __OS_Timer24Work18()    __OS_Timer24Work(18) 
.................... #else 
.................... #define __OS_Timer24Work18() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 19 
.................... #define __OS_Timer24Work19()    __OS_Timer24Work(19) 
.................... #else 
.................... #define __OS_Timer24Work19() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 20 
.................... #define __OS_Timer24Work20()    __OS_Timer24Work(20) 
.................... #else 
.................... #define __OS_Timer24Work20() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 21 
.................... #define __OS_Timer24Work21()    __OS_Timer24Work(21) 
.................... #else 
.................... #define __OS_Timer24Work21() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 22 
.................... #define __OS_Timer24Work22()    __OS_Timer24Work(22) 
.................... #else 
.................... #define __OS_Timer24Work22() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 23 
.................... #define __OS_Timer24Work23()    __OS_Timer24Work(23) 
.................... #else 
.................... #define __OS_Timer24Work23() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 24 
.................... #define __OS_Timer24Work24()    __OS_Timer24Work(24) 
.................... #else 
.................... #define __OS_Timer24Work24() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 25 
.................... #define __OS_Timer24Work25()    __OS_Timer24Work(25) 
.................... #else 
.................... #define __OS_Timer24Work25() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 26 
.................... #define __OS_Timer24Work26()    __OS_Timer24Work(26) 
.................... #else 
.................... #define __OS_Timer24Work26() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 27 
.................... #define __OS_Timer24Work27()    __OS_Timer24Work(27) 
.................... #else 
.................... #define __OS_Timer24Work27() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 28 
.................... #define __OS_Timer24Work28()    __OS_Timer24Work(28) 
.................... #else 
.................... #define __OS_Timer24Work28() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 29 
.................... #define __OS_Timer24Work29()    __OS_Timer24Work(29) 
.................... #else 
.................... #define __OS_Timer24Work29() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 30 
.................... #define __OS_Timer24Work30()    __OS_Timer24Work(30) 
.................... #else 
.................... #define __OS_Timer24Work30() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS24 > 31 
.................... #define __OS_Timer24Work31()    __OS_Timer24Work(31) 
.................... #else 
.................... #define __OS_Timer24Work31() 
.................... #endif 
.................... //.............................................................................. 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //______________________________________________________________________________ 
.................... //////////////////////////////////////////////////////////////////////////////// 
.................... //------------------------------------------------------------------------------ 
.................... //------------------------------------------------------------------------------ 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 0 
.................... #define __OS_Timer32Work0()    __OS_Timer32Work(0) 
.................... #else 
.................... #define __OS_Timer32Work0() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 1 
.................... #define __OS_Timer32Work1()    __OS_Timer32Work(1) 
.................... #else 
.................... #define __OS_Timer32Work1() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 2 
.................... #define __OS_Timer32Work2()    __OS_Timer32Work(2) 
.................... #else 
.................... #define __OS_Timer32Work2() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 3 
.................... #define __OS_Timer32Work3()    __OS_Timer32Work(3) 
.................... #else 
.................... #define __OS_Timer32Work3() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 4 
.................... #define __OS_Timer32Work4()    __OS_Timer32Work(4) 
.................... #else 
.................... #define __OS_Timer32Work4() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 5 
.................... #define __OS_Timer32Work5()    __OS_Timer32Work(5) 
.................... #else 
.................... #define __OS_Timer32Work5() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 6 
.................... #define __OS_Timer32Work6()    __OS_Timer32Work(6) 
.................... #else 
.................... #define __OS_Timer32Work6() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 7 
.................... #define __OS_Timer32Work7()    __OS_Timer32Work(7) 
.................... #else 
.................... #define __OS_Timer32Work7() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 8 
.................... #define __OS_Timer32Work8()    __OS_Timer32Work(8) 
.................... #else 
.................... #define __OS_Timer32Work8() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 9 
.................... #define __OS_Timer32Work9()    __OS_Timer32Work(9) 
.................... #else 
.................... #define __OS_Timer32Work9() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 10 
.................... #define __OS_Timer32Work10()    __OS_Timer32Work(10) 
.................... #else 
.................... #define __OS_Timer32Work10() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 11 
.................... #define __OS_Timer32Work11()    __OS_Timer32Work(11) 
.................... #else 
.................... #define __OS_Timer32Work11() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 12 
.................... #define __OS_Timer32Work12()    __OS_Timer32Work(12) 
.................... #else 
.................... #define __OS_Timer32Work12() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 13 
.................... #define __OS_Timer32Work13()    __OS_Timer32Work(13) 
.................... #else 
.................... #define __OS_Timer32Work13() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 14 
.................... #define __OS_Timer32Work14()    __OS_Timer32Work(14) 
.................... #else 
.................... #define __OS_Timer32Work14() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 15 
.................... #define __OS_Timer32Work15()    __OS_Timer32Work(15) 
.................... #else 
.................... #define __OS_Timer32Work15() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 16 
.................... #define __OS_Timer32Work16()    __OS_Timer32Work(16) 
.................... #else 
.................... #define __OS_Timer32Work16() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 17 
.................... #define __OS_Timer32Work17()    __OS_Timer32Work(17) 
.................... #else 
.................... #define __OS_Timer32Work17() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 18 
.................... #define __OS_Timer32Work18()    __OS_Timer32Work(18) 
.................... #else 
.................... #define __OS_Timer32Work18() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 19 
.................... #define __OS_Timer32Work19()    __OS_Timer32Work(19) 
.................... #else 
.................... #define __OS_Timer32Work19() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 20 
.................... #define __OS_Timer32Work20()    __OS_Timer32Work(20) 
.................... #else 
.................... #define __OS_Timer32Work20() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 21 
.................... #define __OS_Timer32Work21()    __OS_Timer32Work(21) 
.................... #else 
.................... #define __OS_Timer32Work21() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 22 
.................... #define __OS_Timer32Work22()    __OS_Timer32Work(22) 
.................... #else 
.................... #define __OS_Timer32Work22() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 23 
.................... #define __OS_Timer32Work23()    __OS_Timer32Work(23) 
.................... #else 
.................... #define __OS_Timer32Work23() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 24 
.................... #define __OS_Timer32Work24()    __OS_Timer32Work(24) 
.................... #else 
.................... #define __OS_Timer32Work24() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 25 
.................... #define __OS_Timer32Work25()    __OS_Timer32Work(25) 
.................... #else 
.................... #define __OS_Timer32Work25() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 26 
.................... #define __OS_Timer32Work26()    __OS_Timer32Work(26) 
.................... #else 
.................... #define __OS_Timer32Work26() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 27 
.................... #define __OS_Timer32Work27()    __OS_Timer32Work(27) 
.................... #else 
.................... #define __OS_Timer32Work27() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 28 
.................... #define __OS_Timer32Work28()    __OS_Timer32Work(28) 
.................... #else 
.................... #define __OS_Timer32Work28() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 29 
.................... #define __OS_Timer32Work29()    __OS_Timer32Work(29) 
.................... #else 
.................... #define __OS_Timer32Work29() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 30 
.................... #define __OS_Timer32Work30()    __OS_Timer32Work(30) 
.................... #else 
.................... #define __OS_Timer32Work30() 
.................... #endif 
.................... //.............................................................................. 
.................... #if OS_TIMERS32 > 31 
.................... #define __OS_Timer32Work31()    __OS_Timer32Work(31) 
.................... #else 
.................... #define __OS_Timer32Work31() 
.................... #endif 
.................... //.............................................................................. 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //______________________________________________________________________________ 
.................... //****************************************************************************** 
.................... /**/ 
....................  
....................  
.................... #ifndef ASM_OST_TCB_SIZE_CONST 
.................... #define ASM_OST_TCB_SIZE_CONST 
.................... #endif 
....................  
.................... #ifndef ASM_SET_BANK 
.................... #define ASM_SET_BANK 
.................... #endif 
....................  
.................... #if defined(OS_ENABLE_TTIMERS) 
....................  
....................     #if OS_TASKS > 0 
....................     #define __OS_TtimerWork0()    __OS_TtimerWork(0) 
....................     #else 
....................     #define __OS_TtimerWork0() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 1 
....................     #define __OS_TtimerWork1()    __OS_TtimerWork(1) 
....................     #else 
....................     #define __OS_TtimerWork1() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 2 
....................     #define __OS_TtimerWork2()    __OS_TtimerWork(2) 
....................     #else 
....................     #define __OS_TtimerWork2() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 3 
....................     #define __OS_TtimerWork3()    __OS_TtimerWork(3) 
....................     #else 
....................     #define __OS_TtimerWork3() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 4 
....................     #define __OS_TtimerWork4()    __OS_TtimerWork(4) 
....................     #else 
....................     #define __OS_TtimerWork4() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 5 
....................     #define __OS_TtimerWork5()    __OS_TtimerWork(5) 
....................     #else 
....................     #define __OS_TtimerWork5() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 6 
....................     #define __OS_TtimerWork6()    __OS_TtimerWork(6) 
....................     #else 
....................     #define __OS_TtimerWork6() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 7 
....................     #define __OS_TtimerWork7()    __OS_TtimerWork(7) 
....................     #else 
....................     #define __OS_TtimerWork7() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 8 
....................     #define __OS_TtimerWork8()    __OS_TtimerWork(8) 
....................     #else 
....................     #define __OS_TtimerWork8() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 9 
....................     #define __OS_TtimerWork9()    __OS_TtimerWork(9) 
....................     #else 
....................     #define __OS_TtimerWork9() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 10 
....................     #define __OS_TtimerWork10()    __OS_TtimerWork(10) 
....................     #else 
....................     #define __OS_TtimerWork10() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 11 
....................     #define __OS_TtimerWork11()    __OS_TtimerWork(11) 
....................     #else 
....................     #define __OS_TtimerWork11() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 12 
....................     #define __OS_TtimerWork12()    __OS_TtimerWork(12) 
....................     #else 
....................     #define __OS_TtimerWork12() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 13 
....................     #define __OS_TtimerWork13()    __OS_TtimerWork(13) 
....................     #else 
....................     #define __OS_TtimerWork13() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 14 
....................     #define __OS_TtimerWork14()    __OS_TtimerWork(14) 
....................     #else 
....................     #define __OS_TtimerWork14() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 15 
....................     #define __OS_TtimerWork15()    __OS_TtimerWork(15) 
....................     #else 
....................     #define __OS_TtimerWork15() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 16 
....................     #define __OS_TtimerWork16()    __OS_TtimerWork(16) 
....................     #else 
....................     #define __OS_TtimerWork16() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 17 
....................     #define __OS_TtimerWork17()    __OS_TtimerWork(17) 
....................     #else 
....................     #define __OS_TtimerWork17() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 18 
....................     #define __OS_TtimerWork18()    __OS_TtimerWork(18) 
....................     #else 
....................     #define __OS_TtimerWork18() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 19 
....................     #define __OS_TtimerWork19()    __OS_TtimerWork(19) 
....................     #else 
....................     #define __OS_TtimerWork19() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 20 
....................     #define __OS_TtimerWork20()    __OS_TtimerWork(20) 
....................     #else 
....................     #define __OS_TtimerWork20() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 21 
....................     #define __OS_TtimerWork21()    __OS_TtimerWork(21) 
....................     #else 
....................     #define __OS_TtimerWork21() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 22 
....................     #define __OS_TtimerWork22()    __OS_TtimerWork(22) 
....................     #else 
....................     #define __OS_TtimerWork22() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 23 
....................     #define __OS_TtimerWork23()    __OS_TtimerWork(23) 
....................     #else 
....................     #define __OS_TtimerWork23() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 24 
....................     #define __OS_TtimerWork24()    __OS_TtimerWork(24) 
....................     #else 
....................     #define __OS_TtimerWork24() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 25 
....................     #define __OS_TtimerWork25()    __OS_TtimerWork(25) 
....................     #else 
....................     #define __OS_TtimerWork25() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 26 
....................     #define __OS_TtimerWork26()    __OS_TtimerWork(26) 
....................     #else 
....................     #define __OS_TtimerWork26() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 27 
....................     #define __OS_TtimerWork27()    __OS_TtimerWork(27) 
....................     #else 
....................     #define __OS_TtimerWork27() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 28 
....................     #define __OS_TtimerWork28()    __OS_TtimerWork(28) 
....................     #else 
....................     #define __OS_TtimerWork28() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 29 
....................     #define __OS_TtimerWork29()    __OS_TtimerWork(29) 
....................     #else 
....................     #define __OS_TtimerWork29() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 30 
....................     #define __OS_TtimerWork30()    __OS_TtimerWork(30) 
....................     #else 
....................     #define __OS_TtimerWork30() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 31 
....................     #define __OS_TtimerWork31()    __OS_TtimerWork(31) 
....................     #else 
....................     #define __OS_TtimerWork31() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 32 
....................     #define __OS_TtimerWork32()    __OS_TtimerWork(32) 
....................     #else 
....................     #define __OS_TtimerWork32() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 33 
....................     #define __OS_TtimerWork33()    __OS_TtimerWork(33) 
....................     #else 
....................     #define __OS_TtimerWork33() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 34 
....................     #define __OS_TtimerWork34()    __OS_TtimerWork(34) 
....................     #else 
....................     #define __OS_TtimerWork34() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 35 
....................     #define __OS_TtimerWork35()    __OS_TtimerWork(35) 
....................     #else 
....................     #define __OS_TtimerWork35() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 36 
....................     #define __OS_TtimerWork36()    __OS_TtimerWork(36) 
....................     #else 
....................     #define __OS_TtimerWork36() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 37 
....................     #define __OS_TtimerWork37()    __OS_TtimerWork(37) 
....................     #else 
....................     #define __OS_TtimerWork37() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 38 
....................     #define __OS_TtimerWork38()    __OS_TtimerWork(38) 
....................     #else 
....................     #define __OS_TtimerWork38() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 39 
....................     #define __OS_TtimerWork39()    __OS_TtimerWork(39) 
....................     #else 
....................     #define __OS_TtimerWork39() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 40 
....................     #define __OS_TtimerWork40()    __OS_TtimerWork(40) 
....................     #else 
....................     #define __OS_TtimerWork40() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 41 
....................     #define __OS_TtimerWork41()    __OS_TtimerWork(41) 
....................     #else 
....................     #define __OS_TtimerWork41() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 42 
....................     #define __OS_TtimerWork42()    __OS_TtimerWork(42) 
....................     #else 
....................     #define __OS_TtimerWork42() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 43 
....................     #define __OS_TtimerWork43()    __OS_TtimerWork(43) 
....................     #else 
....................     #define __OS_TtimerWork43() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 44 
....................     #define __OS_TtimerWork44()    __OS_TtimerWork(44) 
....................     #else 
....................     #define __OS_TtimerWork44() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 45 
....................     #define __OS_TtimerWork45()    __OS_TtimerWork(45) 
....................     #else 
....................     #define __OS_TtimerWork45() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 46 
....................     #define __OS_TtimerWork46()    __OS_TtimerWork(46) 
....................     #else 
....................     #define __OS_TtimerWork46() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 47 
....................     #define __OS_TtimerWork47()    __OS_TtimerWork(47) 
....................     #else 
....................     #define __OS_TtimerWork47() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 48 
....................     #define __OS_TtimerWork48()    __OS_TtimerWork(48) 
....................     #else 
....................     #define __OS_TtimerWork48() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 49 
....................     #define __OS_TtimerWork49()    __OS_TtimerWork(49) 
....................     #else 
....................     #define __OS_TtimerWork49() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 50 
....................     #define __OS_TtimerWork50()    __OS_TtimerWork(50) 
....................     #else 
....................     #define __OS_TtimerWork50() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 51 
....................     #define __OS_TtimerWork51()    __OS_TtimerWork(51) 
....................     #else 
....................     #define __OS_TtimerWork51() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 52 
....................     #define __OS_TtimerWork52()    __OS_TtimerWork(52) 
....................     #else 
....................     #define __OS_TtimerWork52() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 53 
....................     #define __OS_TtimerWork53()    __OS_TtimerWork(53) 
....................     #else 
....................     #define __OS_TtimerWork53() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 54 
....................     #define __OS_TtimerWork54()    __OS_TtimerWork(54) 
....................     #else 
....................     #define __OS_TtimerWork54() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 55 
....................     #define __OS_TtimerWork55()    __OS_TtimerWork(55) 
....................     #else 
....................     #define __OS_TtimerWork55() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 56 
....................     #define __OS_TtimerWork56()    __OS_TtimerWork(56) 
....................     #else 
....................     #define __OS_TtimerWork56() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 57 
....................     #define __OS_TtimerWork57()    __OS_TtimerWork(57) 
....................     #else 
....................     #define __OS_TtimerWork57() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 58 
....................     #define __OS_TtimerWork58()    __OS_TtimerWork(58) 
....................     #else 
....................     #define __OS_TtimerWork58() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 59 
....................     #define __OS_TtimerWork59()    __OS_TtimerWork(59) 
....................     #else 
....................     #define __OS_TtimerWork59() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 60 
....................     #define __OS_TtimerWork60()    __OS_TtimerWork(60) 
....................     #else 
....................     #define __OS_TtimerWork60() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 61 
....................     #define __OS_TtimerWork61()    __OS_TtimerWork(61) 
....................     #else 
....................     #define __OS_TtimerWork61() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 62 
....................     #define __OS_TtimerWork62()    __OS_TtimerWork(62) 
....................     #else 
....................     #define __OS_TtimerWork62() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_TASKS > 63 
....................     #define __OS_TtimerWork63()    __OS_TtimerWork(63) 
....................     #else 
....................     #define __OS_TtimerWork63() 
....................     #endif 
....................     //........................................................... 
....................  
....................  
....................     #define __OS_TtimersWorkSpeed()      \ 
....................     {                                    \ 
....................         ASM_OST_TCB_SIZE_CONST;          \ 
....................         ASM_SET_BANK;                    \ 
....................         __OS_TtimerWork0();         \ 
....................         __OS_TtimerWork1();         \ 
....................         __OS_TtimerWork2();         \ 
....................         __OS_TtimerWork3();         \ 
....................         __OS_TtimerWork4();         \ 
....................         __OS_TtimerWork5();         \ 
....................         __OS_TtimerWork6();         \ 
....................         __OS_TtimerWork7();         \ 
....................         __OS_TtimerWork8();         \ 
....................         __OS_TtimerWork9();         \ 
....................         __OS_TtimerWork10();        \ 
....................         __OS_TtimerWork11();        \ 
....................         __OS_TtimerWork12();        \ 
....................         __OS_TtimerWork13();        \ 
....................         __OS_TtimerWork14();        \ 
....................         __OS_TtimerWork15();        \ 
....................         __OS_TtimerWork16();        \ 
....................         __OS_TtimerWork17();        \ 
....................         __OS_TtimerWork18();        \ 
....................         __OS_TtimerWork19();        \ 
....................         __OS_TtimerWork20();        \ 
....................         __OS_TtimerWork21();        \ 
....................         __OS_TtimerWork22();        \ 
....................         __OS_TtimerWork23();        \ 
....................         __OS_TtimerWork24();        \ 
....................         __OS_TtimerWork25();        \ 
....................         __OS_TtimerWork26();        \ 
....................         __OS_TtimerWork27();        \ 
....................         __OS_TtimerWork28();        \ 
....................         __OS_TtimerWork29();        \ 
....................         __OS_TtimerWork30();        \ 
....................         __OS_TtimerWork31();        \ 
....................         __OS_TtimerWork32();        \ 
....................         __OS_TtimerWork33();        \ 
....................         __OS_TtimerWork34();        \ 
....................         __OS_TtimerWork35();        \ 
....................         __OS_TtimerWork36();        \ 
....................         __OS_TtimerWork37();        \ 
....................         __OS_TtimerWork38();        \ 
....................         __OS_TtimerWork39();        \ 
....................         __OS_TtimerWork40();        \ 
....................         __OS_TtimerWork41();        \ 
....................         __OS_TtimerWork42();        \ 
....................         __OS_TtimerWork43();        \ 
....................         __OS_TtimerWork44();        \ 
....................         __OS_TtimerWork45();        \ 
....................         __OS_TtimerWork46();        \ 
....................         __OS_TtimerWork47();        \ 
....................         __OS_TtimerWork48();        \ 
....................         __OS_TtimerWork49();        \ 
....................         __OS_TtimerWork50();        \ 
....................         __OS_TtimerWork51();        \ 
....................         __OS_TtimerWork52();        \ 
....................         __OS_TtimerWork53();        \ 
....................         __OS_TtimerWork54();        \ 
....................         __OS_TtimerWork55();        \ 
....................         __OS_TtimerWork56();        \ 
....................         __OS_TtimerWork57();        \ 
....................         __OS_TtimerWork58();        \ 
....................         __OS_TtimerWork59();        \ 
....................         __OS_TtimerWork60();        \ 
....................         __OS_TtimerWork61();        \ 
....................         __OS_TtimerWork62();        \ 
....................         __OS_TtimerWork63();        \ 
....................     } 
....................  
....................     #ifndef __OS_TtimersWorkSize 
....................  
....................         #define __OS_TtimersWorkSize()                                                      \ 
....................         {                                                                                   \ 
....................             OST_UINT _os_i;                                                            \ 
....................             ASM_OST_TCB_SIZE_CONST;                                                         \ 
....................             ASM_SET_BANK;                                                                   \ 
....................             for (_os_i = 0; _os_i < OS_TASKS; _os_i++)                                      \ 
....................             {                                                                               \ 
....................                 if (_OS_Tasks[_os_i].State.bDelay){                                       \ 
....................                     if (!++_OS_Tasks[_os_i].Timer) _OS_Tasks[_os_i].State.bDelay = 0;   \ 
....................                 }                                                                           \ 
....................             }                                                                               \ 
....................         } 
....................     #endif 
....................  
.................... #else 
....................  
....................  
....................     #ifndef __OS_TtimersWorkSize 
....................         #define __OS_TtimersWorkSize() 
....................     #endif 
....................     #define __OS_TtimersWorkSpeed() 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************/ 
.................... /*                                                                      */ 
.................... /************************************************************************/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_STIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................     //........................................................... 
....................     #if OS_STIMERS > 0 
....................     #define __OS_StimerWork0()    __OS_StimerWork(0) 
....................     #else 
....................     #define __OS_StimerWork0() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 1 
....................     #define __OS_StimerWork1()    __OS_StimerWork(1) 
....................     #else 
....................     #define __OS_StimerWork1() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 2 
....................     #define __OS_StimerWork2()    __OS_StimerWork(2) 
....................     #else 
....................     #define __OS_StimerWork2() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 3 
....................     #define __OS_StimerWork3()    __OS_StimerWork(3) 
....................     #else 
....................     #define __OS_StimerWork3() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 4 
....................     #define __OS_StimerWork4()    __OS_StimerWork(4) 
....................     #else 
....................     #define __OS_StimerWork4() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 5 
....................     #define __OS_StimerWork5()    __OS_StimerWork(5) 
....................     #else 
....................     #define __OS_StimerWork5() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 6 
....................     #define __OS_StimerWork6()    __OS_StimerWork(6) 
....................     #else 
....................     #define __OS_StimerWork6() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 7 
....................     #define __OS_StimerWork7()    __OS_StimerWork(7) 
....................     #else 
....................     #define __OS_StimerWork7() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 8 
....................     #define __OS_StimerWork8()    __OS_StimerWork(8) 
....................     #else 
....................     #define __OS_StimerWork8() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 9 
....................     #define __OS_StimerWork9()    __OS_StimerWork(9) 
....................     #else 
....................     #define __OS_StimerWork9() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 10 
....................     #define __OS_StimerWork10()    __OS_StimerWork(10) 
....................     #else 
....................     #define __OS_StimerWork10() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 11 
....................     #define __OS_StimerWork11()    __OS_StimerWork(11) 
....................     #else 
....................     #define __OS_StimerWork11() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 12 
....................     #define __OS_StimerWork12()    __OS_StimerWork(12) 
....................     #else 
....................     #define __OS_StimerWork12() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 13 
....................     #define __OS_StimerWork13()    __OS_StimerWork(13) 
....................     #else 
....................     #define __OS_StimerWork13() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 14 
....................     #define __OS_StimerWork14()    __OS_StimerWork(14) 
....................     #else 
....................     #define __OS_StimerWork14() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 15 
....................     #define __OS_StimerWork15()    __OS_StimerWork(15) 
....................     #else 
....................     #define __OS_StimerWork15() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 16 
....................     #define __OS_StimerWork16()    __OS_StimerWork(16) 
....................     #else 
....................     #define __OS_StimerWork16() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 17 
....................     #define __OS_StimerWork17()    __OS_StimerWork(17) 
....................     #else 
....................     #define __OS_StimerWork17() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 18 
....................     #define __OS_StimerWork18()    __OS_StimerWork(18) 
....................     #else 
....................     #define __OS_StimerWork18() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 19 
....................     #define __OS_StimerWork19()    __OS_StimerWork(19) 
....................     #else 
....................     #define __OS_StimerWork19() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 20 
....................     #define __OS_StimerWork20()    __OS_StimerWork(20) 
....................     #else 
....................     #define __OS_StimerWork20() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 21 
....................     #define __OS_StimerWork21()    __OS_StimerWork(21) 
....................     #else 
....................     #define __OS_StimerWork21() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 22 
....................     #define __OS_StimerWork22()    __OS_StimerWork(22) 
....................     #else 
....................     #define __OS_StimerWork22() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 23 
....................     #define __OS_StimerWork23()    __OS_StimerWork(23) 
....................     #else 
....................     #define __OS_StimerWork23() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 24 
....................     #define __OS_StimerWork24()    __OS_StimerWork(24) 
....................     #else 
....................     #define __OS_StimerWork24() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 25 
....................     #define __OS_StimerWork25()    __OS_StimerWork(25) 
....................     #else 
....................     #define __OS_StimerWork25() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 26 
....................     #define __OS_StimerWork26()    __OS_StimerWork(26) 
....................     #else 
....................     #define __OS_StimerWork26() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 27 
....................     #define __OS_StimerWork27()    __OS_StimerWork(27) 
....................     #else 
....................     #define __OS_StimerWork27() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 28 
....................     #define __OS_StimerWork28()    __OS_StimerWork(28) 
....................     #else 
....................     #define __OS_StimerWork28() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 29 
....................     #define __OS_StimerWork29()    __OS_StimerWork(29) 
....................     #else 
....................     #define __OS_StimerWork29() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 30 
....................     #define __OS_StimerWork30()    __OS_StimerWork(30) 
....................     #else 
....................     #define __OS_StimerWork30() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 31 
....................     #define __OS_StimerWork31()    __OS_StimerWork(31) 
....................     #else 
....................     #define __OS_StimerWork31() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 32 
....................     #define __OS_StimerWork32()    __OS_StimerWork(32) 
....................     #else 
....................     #define __OS_StimerWork32() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 33 
....................     #define __OS_StimerWork33()    __OS_StimerWork(33) 
....................     #else 
....................     #define __OS_StimerWork33() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 34 
....................     #define __OS_StimerWork34()    __OS_StimerWork(34) 
....................     #else 
....................     #define __OS_StimerWork34() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 35 
....................     #define __OS_StimerWork35()    __OS_StimerWork(35) 
....................     #else 
....................     #define __OS_StimerWork35() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 36 
....................     #define __OS_StimerWork36()    __OS_StimerWork(36) 
....................     #else 
....................     #define __OS_StimerWork36() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 37 
....................     #define __OS_StimerWork37()    __OS_StimerWork(37) 
....................     #else 
....................     #define __OS_StimerWork37() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 38 
....................     #define __OS_StimerWork38()    __OS_StimerWork(38) 
....................     #else 
....................     #define __OS_StimerWork38() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 39 
....................     #define __OS_StimerWork39()    __OS_StimerWork(39) 
....................     #else 
....................     #define __OS_StimerWork39() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 40 
....................     #define __OS_StimerWork40()    __OS_StimerWork(40) 
....................     #else 
....................     #define __OS_StimerWork40() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 41 
....................     #define __OS_StimerWork41()    __OS_StimerWork(41) 
....................     #else 
....................     #define __OS_StimerWork41() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 42 
....................     #define __OS_StimerWork42()    __OS_StimerWork(42) 
....................     #else 
....................     #define __OS_StimerWork42() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 43 
....................     #define __OS_StimerWork43()    __OS_StimerWork(43) 
....................     #else 
....................     #define __OS_StimerWork43() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 44 
....................     #define __OS_StimerWork44()    __OS_StimerWork(44) 
....................     #else 
....................     #define __OS_StimerWork44() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 45 
....................     #define __OS_StimerWork45()    __OS_StimerWork(45) 
....................     #else 
....................     #define __OS_StimerWork45() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 46 
....................     #define __OS_StimerWork46()    __OS_StimerWork(46) 
....................     #else 
....................     #define __OS_StimerWork46() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 47 
....................     #define __OS_StimerWork47()    __OS_StimerWork(47) 
....................     #else 
....................     #define __OS_StimerWork47() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 48 
....................     #define __OS_StimerWork48()    __OS_StimerWork(48) 
....................     #else 
....................     #define __OS_StimerWork48() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 49 
....................     #define __OS_StimerWork49()    __OS_StimerWork(49) 
....................     #else 
....................     #define __OS_StimerWork49() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 50 
....................     #define __OS_StimerWork50()    __OS_StimerWork(50) 
....................     #else 
....................     #define __OS_StimerWork50() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 51 
....................     #define __OS_StimerWork51()    __OS_StimerWork(51) 
....................     #else 
....................     #define __OS_StimerWork51() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 52 
....................     #define __OS_StimerWork52()    __OS_StimerWork(52) 
....................     #else 
....................     #define __OS_StimerWork52() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 53 
....................     #define __OS_StimerWork53()    __OS_StimerWork(53) 
....................     #else 
....................     #define __OS_StimerWork53() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 54 
....................     #define __OS_StimerWork54()    __OS_StimerWork(54) 
....................     #else 
....................     #define __OS_StimerWork54() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 55 
....................     #define __OS_StimerWork55()    __OS_StimerWork(55) 
....................     #else 
....................     #define __OS_StimerWork55() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 56 
....................     #define __OS_StimerWork56()    __OS_StimerWork(56) 
....................     #else 
....................     #define __OS_StimerWork56() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 57 
....................     #define __OS_StimerWork57()    __OS_StimerWork(57) 
....................     #else 
....................     #define __OS_StimerWork57() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 58 
....................     #define __OS_StimerWork58()    __OS_StimerWork(58) 
....................     #else 
....................     #define __OS_StimerWork58() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 59 
....................     #define __OS_StimerWork59()    __OS_StimerWork(59) 
....................     #else 
....................     #define __OS_StimerWork59() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 60 
....................     #define __OS_StimerWork60()    __OS_StimerWork(60) 
....................     #else 
....................     #define __OS_StimerWork60() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 61 
....................     #define __OS_StimerWork61()    __OS_StimerWork(61) 
....................     #else 
....................     #define __OS_StimerWork61() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 62 
....................     #define __OS_StimerWork62()    __OS_StimerWork(62) 
....................     #else 
....................     #define __OS_StimerWork62() 
....................     #endif 
....................     //........................................................... 
....................     #if OS_STIMERS > 63 
....................     #define __OS_StimerWork63()    __OS_StimerWork(63) 
....................     #else 
....................     #define __OS_StimerWork63() 
....................     #endif 
....................     //........................................................... 
....................  
....................     #ifndef __OS_StimerBank 
....................     #define __OS_StimerBank() 
....................     #endif 
....................  
....................  
....................     #define __OS_StimersWorkSpeed()    \ 
....................     {                                  \ 
....................         __OS_StimerBank();             \ 
....................         __OS_StimerWork0();            \ 
....................         __OS_StimerWork1();            \ 
....................         __OS_StimerWork2();            \ 
....................         __OS_StimerWork3();            \ 
....................         __OS_StimerWork4();            \ 
....................         __OS_StimerWork5();            \ 
....................         __OS_StimerWork6();            \ 
....................         __OS_StimerWork7();            \ 
....................         __OS_StimerWork8();            \ 
....................         __OS_StimerWork9();            \ 
....................         __OS_StimerWork10();           \ 
....................         __OS_StimerWork11();           \ 
....................         __OS_StimerWork12();           \ 
....................         __OS_StimerWork13();           \ 
....................         __OS_StimerWork14();           \ 
....................         __OS_StimerWork15();           \ 
....................         __OS_StimerWork16();           \ 
....................         __OS_StimerWork17();           \ 
....................         __OS_StimerWork18();           \ 
....................         __OS_StimerWork19();           \ 
....................         __OS_StimerWork20();           \ 
....................         __OS_StimerWork21();           \ 
....................         __OS_StimerWork22();           \ 
....................         __OS_StimerWork23();           \ 
....................         __OS_StimerWork24();           \ 
....................         __OS_StimerWork25();           \ 
....................         __OS_StimerWork26();           \ 
....................         __OS_StimerWork27();           \ 
....................         __OS_StimerWork28();           \ 
....................         __OS_StimerWork29();           \ 
....................         __OS_StimerWork30();           \ 
....................         __OS_StimerWork31();           \ 
....................         __OS_StimerWork32();           \ 
....................         __OS_StimerWork33();           \ 
....................         __OS_StimerWork34();           \ 
....................         __OS_StimerWork35();           \ 
....................         __OS_StimerWork36();           \ 
....................         __OS_StimerWork37();           \ 
....................         __OS_StimerWork38();           \ 
....................         __OS_StimerWork39();           \ 
....................         __OS_StimerWork40();           \ 
....................         __OS_StimerWork41();           \ 
....................         __OS_StimerWork42();           \ 
....................         __OS_StimerWork43();           \ 
....................         __OS_StimerWork44();           \ 
....................         __OS_StimerWork45();           \ 
....................         __OS_StimerWork46();           \ 
....................         __OS_StimerWork47();           \ 
....................         __OS_StimerWork48();           \ 
....................         __OS_StimerWork49();           \ 
....................         __OS_StimerWork50();           \ 
....................         __OS_StimerWork51();           \ 
....................         __OS_StimerWork52();           \ 
....................         __OS_StimerWork53();           \ 
....................         __OS_StimerWork54();           \ 
....................         __OS_StimerWork55();           \ 
....................         __OS_StimerWork56();           \ 
....................         __OS_StimerWork57();           \ 
....................         __OS_StimerWork58();           \ 
....................         __OS_StimerWork59();           \ 
....................         __OS_StimerWork60();           \ 
....................         __OS_StimerWork61();           \ 
....................         __OS_StimerWork62();           \ 
....................         __OS_StimerWork63();           \ 
....................     } 
....................  
....................  
....................     #ifndef __OS_StimersWorkSize 
....................  
....................         #define __OS_StimersWorkSize()                                          \ 
....................         {                                                                       \ 
....................             OST_UINT _os_i;                                                \ 
....................             for (_os_i = 0; _os_i < OS_STIMERS; _os_i++)                        \ 
....................             {                                                                   \ 
....................                 if (_OS_Stimers[_os_i] & OS_STIMER_RUN_BIT) _OS_Stimers[_os_i]++;   \ 
....................             }                                                                   \ 
....................         } 
....................  
....................     #endif 
....................  
.................... #else 
....................  
....................     #define __OS_StimersWorkSpeed() 
....................     #ifndef __OS_StimersWorkSize 
....................         #define __OS_StimersWorkSize() 
....................     #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_STIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
.................... //______________________________________________________________________________ 
.................... //****************************************************************************** 
....................  
....................  
.................... #define OS_TimerInline()    __OS_TimerInline() 
....................  
....................  
.................... #if defined(OS_SLOW_TIMERS) || OS_TIMERS24 > 0 
.................... #define _OS_IncOSTicks()    OS_Ticks++; 
.................... #else 
.................... #define _OS_IncOSTicks() 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     S Y S T E M   T I M E R   W O R K   M A C R O                                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... #define __OS_OldTimersWork()               \ 
.................... {                                          \ 
....................     _OS_IncOSTicks();                      \ 
....................                                            \ 
....................     __OS_Timer8Work0();                    \ 
....................     __OS_Timer8Work1();                    \ 
....................     __OS_Timer8Work2();                    \ 
....................     __OS_Timer8Work3();                    \ 
....................     __OS_Timer8Work4();                    \ 
....................     __OS_Timer8Work5();                    \ 
....................     __OS_Timer8Work6();                    \ 
....................     __OS_Timer8Work7();                    \ 
....................     __OS_Timer8Work8();                    \ 
....................     __OS_Timer8Work9();                    \ 
....................     __OS_Timer8Work10();                   \ 
....................     __OS_Timer8Work11();                   \ 
....................     __OS_Timer8Work12();                   \ 
....................     __OS_Timer8Work13();                   \ 
....................     __OS_Timer8Work14();                   \ 
....................     __OS_Timer8Work15();                   \ 
....................     __OS_Timer8Work16();                   \ 
....................     __OS_Timer8Work17();                   \ 
....................     __OS_Timer8Work18();                   \ 
....................     __OS_Timer8Work19();                   \ 
....................     __OS_Timer8Work20();                   \ 
....................     __OS_Timer8Work21();                   \ 
....................     __OS_Timer8Work22();                   \ 
....................     __OS_Timer8Work23();                   \ 
....................     __OS_Timer8Work24();                   \ 
....................     __OS_Timer8Work25();                   \ 
....................     __OS_Timer8Work26();                   \ 
....................     __OS_Timer8Work27();                   \ 
....................     __OS_Timer8Work28();                   \ 
....................     __OS_Timer8Work29();                   \ 
....................     __OS_Timer8Work30();                   \ 
....................     __OS_Timer8Work31();                   \ 
....................                                            \ 
....................     __OS_Timer16Work0();                   \ 
....................     __OS_Timer16Work1();                   \ 
....................     __OS_Timer16Work2();                   \ 
....................     __OS_Timer16Work3();                   \ 
....................     __OS_Timer16Work4();                   \ 
....................     __OS_Timer16Work5();                   \ 
....................     __OS_Timer16Work6();                   \ 
....................     __OS_Timer16Work7();                   \ 
....................     __OS_Timer16Work8();                   \ 
....................     __OS_Timer16Work9();                   \ 
....................     __OS_Timer16Work10();                  \ 
....................     __OS_Timer16Work11();                  \ 
....................     __OS_Timer16Work12();                  \ 
....................     __OS_Timer16Work13();                  \ 
....................     __OS_Timer16Work14();                  \ 
....................     __OS_Timer16Work15();                  \ 
....................     __OS_Timer16Work16();                  \ 
....................     __OS_Timer16Work17();                  \ 
....................     __OS_Timer16Work18();                  \ 
....................     __OS_Timer16Work19();                  \ 
....................     __OS_Timer16Work20();                  \ 
....................     __OS_Timer16Work21();                  \ 
....................     __OS_Timer16Work22();                  \ 
....................     __OS_Timer16Work23();                  \ 
....................     __OS_Timer16Work24();                  \ 
....................     __OS_Timer16Work25();                  \ 
....................     __OS_Timer16Work26();                  \ 
....................     __OS_Timer16Work27();                  \ 
....................     __OS_Timer16Work28();                  \ 
....................     __OS_Timer16Work29();                  \ 
....................     __OS_Timer16Work30();                  \ 
....................     __OS_Timer16Work31();                  \ 
....................                                            \ 
....................     __OS_Timer32Work0();                   \ 
....................     __OS_Timer32Work1();                   \ 
....................     __OS_Timer32Work2();                   \ 
....................     __OS_Timer32Work3();                   \ 
....................     __OS_Timer32Work4();                   \ 
....................     __OS_Timer32Work5();                   \ 
....................     __OS_Timer32Work6();                   \ 
....................     __OS_Timer32Work7();                   \ 
....................     __OS_Timer32Work8();                   \ 
....................     __OS_Timer32Work9();                   \ 
....................     __OS_Timer32Work10();                  \ 
....................     __OS_Timer32Work11();                  \ 
....................     __OS_Timer32Work12();                  \ 
....................     __OS_Timer32Work13();                  \ 
....................     __OS_Timer32Work14();                  \ 
....................     __OS_Timer32Work15();                  \ 
....................     __OS_Timer32Work16();                  \ 
....................     __OS_Timer32Work17();                  \ 
....................     __OS_Timer32Work18();                  \ 
....................     __OS_Timer32Work19();                  \ 
....................     __OS_Timer32Work20();                  \ 
....................     __OS_Timer32Work21();                  \ 
....................     __OS_Timer32Work22();                  \ 
....................     __OS_Timer32Work23();                  \ 
....................     __OS_Timer32Work24();                  \ 
....................     __OS_Timer32Work25();                  \ 
....................     __OS_Timer32Work26();                  \ 
....................     __OS_Timer32Work27();                  \ 
....................     __OS_Timer32Work28();                  \ 
....................     __OS_Timer32Work29();                  \ 
....................     __OS_Timer32Work30();                  \ 
....................     __OS_Timer32Work31();                  \ 
....................                                            \ 
....................     __OS_CheckInc24()                      \ 
....................     {                                      \ 
....................         __OS_Timer24Work0();               \ 
....................         __OS_Timer24Work1();               \ 
....................         __OS_Timer24Work2();               \ 
....................         __OS_Timer24Work3();               \ 
....................         __OS_Timer24Work4();               \ 
....................         __OS_Timer24Work5();               \ 
....................         __OS_Timer24Work6();               \ 
....................         __OS_Timer24Work7();               \ 
....................         __OS_Timer24Work8();               \ 
....................         __OS_Timer24Work9();               \ 
....................         __OS_Timer24Work10();              \ 
....................         __OS_Timer24Work11();              \ 
....................         __OS_Timer24Work12();              \ 
....................         __OS_Timer24Work13();              \ 
....................         __OS_Timer24Work14();              \ 
....................         __OS_Timer24Work15();              \ 
....................         __OS_Timer24Work16();              \ 
....................         __OS_Timer24Work17();              \ 
....................         __OS_Timer24Work18();              \ 
....................         __OS_Timer24Work19();              \ 
....................         __OS_Timer24Work20();              \ 
....................         __OS_Timer24Work21();              \ 
....................         __OS_Timer24Work22();              \ 
....................         __OS_Timer24Work23();              \ 
....................         __OS_Timer24Work24();              \ 
....................         __OS_Timer24Work25();              \ 
....................         __OS_Timer24Work26();              \ 
....................         __OS_Timer24Work27();              \ 
....................         __OS_Timer24Work28();              \ 
....................         __OS_Timer24Work29();              \ 
....................         __OS_Timer24Work30();              \ 
....................         __OS_Timer24Work31();              \ 
....................     }                                      \ 
.................... } 
....................  
....................  
....................  
.................... #define OS_OldTimer()           __OS_OldTimersWork() 
....................  
.................... #ifdef OS_TTIMERS_OPTIMIZE_SIZE 
....................     #define OS_Ttimer()             __OS_TtimersWorkSize() 
.................... #else 
....................     #define OS_Ttimer()             __OS_TtimersWorkSpeed() 
.................... #endif 
....................  
.................... #ifdef OS_STIMERS_OPTIMIZE_SIZE 
....................     #define OS_Stimer()             __OS_StimersWorkSize() 
.................... #else 
....................     #define OS_Stimer()             __OS_StimersWorkSpeed() 
.................... #endif 
....................  
....................  
.................... #define OS_Dtimer()                 __OS_DtimersWork() 
.................... #define OS_Qtimer()                 __OS_QtimersWork() 
....................  
....................  
....................  
.................... #define __OS_TimerInline()          \ 
.................... {                                   \ 
....................     OS_OldTimer();                  \ 
....................     OS_Ttimer();                    \ 
....................     OS_Stimer();                    \ 
....................     OS_Dtimer();                    \ 
....................     OS_Qtimer();                    \ 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // _OS_TIMER_H_ 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* This constant is defined in service's files */ 
....................  
.................... #if defined(OS_ENABLE_INT) 
....................  
....................     extern  volatile OS_RAM_NEAR OST_UINT _OS_Temp_I; 
....................  
....................     // _OS_DI_INT() and _OS_RI_INT() are defined in port\osa_xxx.h files for each platform 
....................  
.................... #else 
....................  
....................     #define _OS_DI_INT() 
....................     #define _OS_RI_INT() 
....................  
.................... #endif 
....................  
.................... #define _OS_ATOMIC_WRITE_A(expr)        \ 
....................     OSM_BEGIN {                         \ 
....................         _OS_DI_INT();                   \ 
....................         expr;                           \ 
....................         _OS_RI_INT();                   \ 
....................     } OSM_END 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // These two macros are used in mikroC for PIC16. For all others they are  
.................... // defined as empty macros 
.................... // ----------------------------------------------------------------------------- 
.................... #ifndef _OS_SET_IRP_CUR_TASK 
.................... #define _OS_SET_IRP_CUR_TASK() 
.................... #endif 
....................  
.................... #ifndef _OS_CLR_IRP 
.................... #define _OS_CLR_IRP() 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... #ifdef __OSA_CCS__ 
.................... #include <osa.c> 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa.c 
....................  * 
....................  *  Compilers:      HT-PICC STD 
....................  *                  HT-PICC PRO 
....................  *                  HT-PICC18 STD 
....................  *                  Mplab C18 
....................  *                  Mplab C30 
....................  *                  MikroC PRO 
....................  *                  CCS 
....................  *                  WinAVR 
....................  *                  IAR 
....................  *                  Cosmic 
....................  *                  Raisonance 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    This file contains all system variables and functions definitions. 
....................  * 
....................  *  History:        10.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... #include <OSA.h> 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa.h 
....................  * 
....................  *  Compilers:      HT-PICC STD 
....................  *                  HT-PICC PRO 
....................  *                  HT-PICC18 STD 
....................  *                  Mplab C18 
....................  *                  Mplab C30 
....................  *                  MikroC PRO 
....................  *                  CCS 
....................  *                  WinAVR 
....................  *                  IAR 
....................  *                  Cosmic 
....................  *                  Raisonance 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    This file contains all prototypes of functions and variables, 
....................  *                  data types definitions, system constants. 
....................  *                  This file must be included in all modules that use OSA services. 
....................  * 
....................  *  History:        10.00.2010 -    Removed all modification marks 
....................  *  History:        10.07.2010 -    Added ports for STM8: IAR and Raisonance 
....................  *  
....................  *                  25.10.2010  -   Bug fixed: OS_Qtimer_Break did not deleted timer from the list 
....................  *                              -   Bug fixed: interrupt became disables after calling OS_Qtimer_Run for timer already 
....................  *                                  presented in queue 
....................  *                              -   (osa_qtimer.c) 
....................  *                              -   (osa_pic16_htpicc.c) 
....................  *                              -   Definition of OS_Ttimer_Delay fixed (osa_ttimer.h) 
....................  *  
....................  *                  30.10.2010  -   Another bug in qtimers fixed (osa_qtimer.c, osa_pic16_htpicc.c) 
....................  *  
....................  *                  22.11.2010  -   IAR for AVR port bugs fixed (osa_avr_iar.h) 
....................  *  
....................  *                  08.12.2010  -   osa_pic18_htpicc.h 
....................  *  
....................  *                  26.12.2010  -   Bug fixed for PIC18: _OS_RETURN_NO_SAVE 
....................  *  
....................  *                  06.03.2011  -   osa_avr_winavr.c 
....................  *                                  osa_avr_winavr.h 
....................  *                                  osa_pic18_mikroc.c  
....................  * 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... #ifndef __OSA__ 
.................... #define __OSA__ 
....................  
....................  
....................  
.................... #define __OSA_VERSION__         110306          /* 6 mar, 2011    */ 
....................  
....................  
....................  
....................  
.................... #define __OSAVERSION__          __OSA_VERSION__ /*old*/ 
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Setting compiler constant. This constant used in "osa.c" to make most                       * 
....................  *  efficient code for used compiler.                                                           * 
....................  *                                                                                              * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if   defined(__PICC18__)           /* HT-PICC18        */ 
....................  
....................     #define __OSA_PIC18_HTPICC__ 
....................     #define __OSA_PIC18__ 
....................     #define __OSA_HTPICC__ 
....................  
....................     #define __OSAPICC18__   /*old*/ 
....................     #define __OSAPICC__     /*old*/ 
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__18CXX)              /* Microchip C18    */ 
....................  
....................     #if __EXTENDED18__ == 1 
....................         #define __OSA_PIC18_MPLABC_EXT__      
....................         #define __OSAMCC18EXT__             /*old*/  
....................     #else 
....................         #define __OSA_PIC18_MPLABC__ 
....................         #define __OSAMCC18__                /*old*/ 
....................     #endif 
....................  
....................     #define __OSA_PIC18__ 
....................     #define __OSA_MPLABC__ 
....................  
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__C30__)              /* Microchip C30    */ 
....................  
....................     #define __OSA_PIC24_MPLABC__ 
....................     #define __OSA_DSPIC_MPLABC__ 
....................  
....................     #define __OSA_MPLABC__ 
....................     // See osa_pic24_mplabc.h for processor definition 
....................  
....................     #define __OSAMCC30__    /*old*/ 
....................     #define __OSA30__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__PCH__)              /* CCS for PIC18  */ 
....................  
....................     #define __OSA_PIC18_CCS__ 
....................     #define __OSA_PIC18__ 
....................     #define __OSA_CCS__ 
....................  
....................     #define __OSACCS18__    /*old*/ 
....................     #define __OSACCS__      /*old*/ 
....................     #define __OSA18__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__PCM__)              /* CCS for PIC16  */ 
....................  
....................     #define __OSA_PIC16_CCS__ 
....................     #define __OSA_PIC16__ 
....................     #define __OSA_CCS__ 
....................  
....................     #define __OSACCS16__    /*old*/ 
....................     #define __OSACCS__      /*old*/ 
....................     #define __OSA16__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(_PIC12)               /* HT-PICC with baserange family  */ 
....................  
....................     #define __OSA_PIC12_HTPICC__ 
....................     #define __OSA_PIC12__ 
....................     #define __OSA_HTPICC__ 
....................  
....................     #define __OSAPICC12__   /*old*/ 
....................     #define __OSAPICC__     /*old*/ 
....................     #define __OSA12__       /*old*/ 
....................     #define __OSAPIC__      /*old*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__MIKROC_PRO_FOR_PIC__) 
....................  
....................     #if   defined(P16)              /* mikroC for PIC16 */ 
....................         #define __OSA_PIC16_MIKROC__ 
....................         #define __OSA_PIC16__ 
....................         #define __OSA_MIKROC__ 
....................  
....................         #define __OSAMIKROC16__         /*old*/ 
....................         #define __OSAMIKROC__           /*old*/ 
....................         #define __OSA16__               /*old*/ 
....................     #elif defined(P18)              /* mikroC for PIC18 */ 
....................         #define __OSA_PIC18_MIKROC__ 
....................         #define __OSA_PIC18__ 
....................         #define __OSA_MIKROC__ 
....................  
....................         #define __OSAMIKROC18__         /*old*/ 
....................         #define __OSAMIKROC__           /*old*/ 
....................         #define __OSA18__               /*old*/ 
....................     #endif 
....................  
....................     #define __OSAPIC__                  /*old*/ 
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__AVR__) 
....................  
....................     #define __OSA_AVR_WINAVR__ 
....................     #define __OSA_WINAVR__ 
....................     #define __OSA_AVR__ 
....................  
....................     #define __OSAWINAVR__       /*old*/ 
....................     #define __OSAAVR__          /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__ICCAVR__) 
....................  
....................     #define __OSA_AVR_IAR__ 
....................     #define __OSA_IAR__ 
....................     #define __OSA_AVR__ 
....................  
....................     #define __OSAIARAVR__       /*old*/ 
....................     #define __OSAAVR__          /*old*/ 
....................     #define __OSAICCAVR__       /*old*/ 
....................   
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__CODEVISIONAVR__) 
....................  
....................     #define __OSA_AVR__ 
....................     #define __OSA_AVR_CODEVISION__ 
....................     #define __OSA_CODEVISION__ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__ICCSTM8__) 
....................  
....................     #define __OSA_STM8_IAR__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_IAR__ 
....................  
....................     #define __OSAIARSTM8__      /*old*/ 
....................     #define __OSASTM8__         /*old*/ 
....................     #define __OSAICCSTM8__      /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__CSMC__) 
....................  
....................     #define __OSA_STM8_COSMIC__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_COSMIC__ 
....................  
....................     #define __OSACOSMICSTM8__   /*old*/ 
....................     #define __OSASTM8__         /*old*/ 
....................  
....................     #define OS_PROTECT_MEMORY_ACCESS            // for atomic access protection 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__RCST7__)            /* Raisonance*/ 
....................  
....................     #define __OSA_STM8_RAISONANCE__ 
....................     #define __OSA_STM8__ 
....................     #define __OSA_RAISONANCE__ 
....................     #define __OSA_RCST7__ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else                               /* HT-PICC with midrange family */ 
....................  
....................     #if _HTC_VER_MAJOR_ >= 9 && _HTC_VER_MINOR_ > 60 
....................         #ifdef _PIC14E 
....................             #define __OSA_PIC16E_HTPICC_PRO__ 
....................             #define __OSA_PIC16E__ 
....................             #define __OSA_HTPICC_PRO__ 
....................  
....................             #define __OSAPICC16E__              /*old*/ 
....................             #define __OSA16E__                  /*old*/ 
....................         #else 
....................             #define __OSA_PIC16_HTPICC__ 
....................             #define __OSA_PIC16__ 
....................             #define __OSA_HTPICC__ 
....................  
....................             #define __OSAPICC16__               /*old*/ 
....................             #define __OSA16__                   /*old*/ 
....................         #endif 
....................         #define __OSAPICC__         /*old*/ 
....................         #define __OSAPICCPRO__      /*old*/ 
....................         #define __OSAPIC__          /*old*/ 
....................     #else 
....................         #define __OSA_PIC16_HTPICC__ 
....................         #define __OSA_PIC16__ 
....................         #define __OSA_HTPICC__ 
....................  
....................         #define __OSAPICC16__       /*old*/ 
....................         #define __OSAPICC__         /*old*/ 
....................         #define __OSA16__           /*old*/ 
....................         #define __OSAPIC__          /*old*/ 
....................     #endif 
....................  
....................  
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #include "OSAcfg.h"         /* This file contains project configuration         */ 
....................  
....................  
.................... #if defined(__OSACCS__) || defined(__OSAMIKROC__) || defined(__OSA_AVR_WINAVR__) 
....................  
....................     #define OSM_BEGIN 
....................     #define OSM_END 
....................  
.................... #else 
....................  
....................     #define OSM_BEGIN   do 
....................     #define OSM_END     while (0) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  * OSA CONFIGURATION                                                                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... //****************************************************************************** 
.................... //  PRIORITY MODE 
.................... //****************************************************************************** 
....................  
.................... #define OS_PRIORITY_NORMAL      0 
.................... #define OS_PRIORITY_DISABLED    1 
.................... #define OS_PRIORITY_EXTENDED    2 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef OS_PRIORITY_LEVEL 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #if     defined(OS_DISABLE_PRIORITY) 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_DISABLED 
....................     #elif   defined(OS_EXTENDED_PRIORITY) 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_EXTENDED 
....................     #else 
....................     #define OS_PRIORITY_LEVEL   OS_PRIORITY_NORMAL 
....................     #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  
.................... //  CHECK FOR SET OF SERVICES 
.................... //  
.................... //****************************************************************************** 
....................  
....................  
.................... #if defined(OS_ENABLE_ALL) 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // undef all config constants 
....................  
....................     #ifdef OS_ENABLE_TIMER 
....................     #undef OS_ENABLE_TIMER 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_CSEM 
....................     #undef OS_ENABLE_CSEM 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QUEUE 
....................     #undef OS_ENABLE_QUEUE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_SQUEUE 
....................     #undef OS_ENABLE_SQUEUE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_CRITICAL_SECTION 
....................     #undef OS_ENABLE_CRITICAL_SECTION 
....................     #endif 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // undef all old style config constants 
....................  
....................     #ifdef OS_TIMER_ENABLE 
....................     #undef OS_TIMER_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_CSEM_ENABLE 
....................     #undef OS_CSEM_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_QMSG_ENABLE 
....................     #undef OS_QMSG_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_QSMSG_ENABLE 
....................     #undef OS_QSMSG_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_DTIMERS_ENABLE 
....................     #undef OS_DTIMERS_ENABLE 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QMSG 
....................     #undef OS_ENABLE_QMSG 
....................     #endif 
....................  
....................     #ifdef OS_ENABLE_QSMSG 
....................     #undef OS_ENABLE_QSMSG 
....................     #endif 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // define all config constants 
....................  
....................     #define OS_ENABLE_CSEM 
....................     #define OS_ENABLE_QUEUE 
....................     #define OS_ENABLE_SQUEUE 
....................     #define OS_ENABLE_TTIMERS 
....................     #define OS_ENABLE_CRITICAL_SECTION 
....................  
.................... #endif 
....................  
.................... #if defined(OS_ENABLE_QTIMER) && defined(__OSA_PIC12_HTPICC__)  
.................... #error "OSA error #22: Qtimers are not supported under 12-bit controllers (PIC10 and PIC12)" 
.................... #endif 
....................  
....................  
.................... /*------------------------------------------*/ 
.................... /*                                          */ 
.................... /* (OSA configuration)                      */ 
.................... /* Redefining old style constants           */ 
.................... /*                                          */ 
.................... /*------------------------------------------*/ 
....................  
.................... #ifdef OS_TIMER_ENABLE 
.................... #define OS_ENABLE_TIMER     /* Defined when using timers in tasks (OS_Delay     */ 
....................                             /* and wait events with timeout)                    */ 
.................... #endif 
....................  
.................... #ifdef OS_CSEM_ENABLE 
.................... #define OS_ENABLE_CSEM      /* Defined when using counting semaphores           */ 
.................... #endif 
....................  
.................... #ifdef OS_QMSG_ENABLE       //^ 
.................... #define OS_ENABLE_QUEUE      /* Defined when using queue of pointer to messages  */ 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_QMSG       //^ 
.................... #define OS_ENABLE_QUEUE      /* Defined when using queue of pointer to messages  */ 
.................... #endif 
....................  
.................... #ifdef OS_QSMSG_ENABLE      //^ 
.................... #define OS_ENABLE_SQUEUE     /* Defined when using queue of simple messages      */ 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_QSMSG      //^ 
.................... #define OS_ENABLE_SQUEUE     /* Defined when using queue of simple messages      */ 
.................... #endif 
....................  
.................... #ifdef OS_DTIMERS_ENABLE 
.................... #define OS_ENABLE_DTIMERS   /* Defined when using dynamic timers                */ 
.................... #endif 
....................  
....................  
.................... #ifdef OS_QUEUES_IDENTICAL   //^ 
.................... #define OS_QUEUE_SQUEUE_IDENTICAL  // Defined to reduce code size when both types 
....................                                    // of queues are used 
.................... #endif 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... // (OSA configuration) 
.................... // Set constants for interrupt usage 
....................  
.................... #ifdef  OS_ENABLE_INT_SERVICE       // Redefining old style constant 
.................... #define OS_ENABLE_INT_ALL 
.................... #endif 
....................  
.................... #ifdef OS_ENABLE_INT_ALL 
....................  
....................     #define OS_ENABLE_INT_BSEM      /* Enables interrupt services for binary    */ 
....................                                     /* semaphores                               */ 
....................  
....................     #define OS_ENABLE_INT_CSEM      /* Enables interrupt services for counting  */ 
....................                                     /* semaphores                               */ 
....................  
....................     #define OS_ENABLE_INT_MSG       /* Enables interrupt services for pointers  */ 
....................                                     /* to messages                              */ 
....................  
....................     #define OS_ENABLE_INT_SMSG      /* Enables interrupt services for simple    */ 
....................                                     /* messages                                 */ 
....................  
....................     #define OS_ENABLE_INT_QUEUE     /* Enables interrupt services for queues of */ 
....................                                     /* pointers to messages and simple messages */ 
....................  
....................     #define OS_ENABLE_INT_FLAG      /* Enables interrupt services for flags     */ 
....................                                      
.................... #endif 
....................  
....................  
.................... #if defined(OS_ENABLE_INT_CSEM)  ||                     \ 
....................     defined(OS_ENABLE_INT_BSEM)  ||                     \ 
....................     defined(OS_ENABLE_INT_MSG)   ||                     \ 
....................     defined(OS_ENABLE_INT_SMSG)  ||                     \ 
....................     defined(OS_ENABLE_INT_QUEUE) ||                     \ 
....................     defined(OS_ENABLE_INT_FLAG)  ||                     \ 
....................     defined(OS_PROTECT_MEMORY_ACCESS) 
....................  
....................  
....................     #define OS_ENABLE_INT 
....................  
.................... #endif 
....................  
.................... /* 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  * (OSA configuration)                                                          * 
....................  * Set system constants for timers                                              * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  */ 
....................  
.................... #if defined(OS_ENABLE_TIMER) 
.................... #define OS_ENABLE_TTIMERS       /* Enables task timers                          */ 
.................... #endif 
....................  
....................  
.................... #ifdef OS_ENABLE_PTIMERS        /* Redefining old name (ptimer) to new (dtimer) */ 
....................     #define OS_ENABLE_DTIMERS  
.................... #endif 
....................  
.................... #if !defined(OS_STIMERS) 
....................     #define OS_STIMERS  0       /* Number of STimers                            */ 
.................... #endif 
....................  
....................  
.................... /*--------------------------------------------------*/ 
.................... /*                                                  */ 
.................... /* Counting number of old style static timers       */ 
.................... /*                                                  */ 
.................... /* note:    it is not recommended to use this       */ 
.................... /*          type of timers. Use STimers instead.    */ 
.................... /*                                                  */ 
.................... /*--------------------------------------------------*/ 
....................  
.................... #ifndef OS_TIMERS8                  /* not recommended to use       */ 
....................     #define OS_TIMERS8 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS16                 /* not recommended to use       */ 
....................     #define OS_TIMERS16 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS24                 /* not recommended to use       */ 
....................     #define OS_TIMERS24 0 
.................... #endif 
....................  
.................... #ifndef OS_TIMERS32                 /* not recommended to use       */ 
....................     #define OS_TIMERS32 0 
.................... #endif 
....................  
....................  
.................... #define _OS_TIMER8_POS      (0) 
.................... #define _OS_TIMER16_POS     (_OS_TIMER8_POS  + OS_TIMERS8) 
.................... #define _OS_TIMER24_POS     (_OS_TIMER16_POS + OS_TIMERS16) 
.................... #define _OS_TIMER32_POS     (_OS_TIMER24_POS + OS_TIMERS24) 
....................  
....................  
.................... #define OS_TIMERS           (OS_TIMERS8 + OS_TIMERS16 + OS_TIMERS24 + OS_TIMERS32) 
....................  
.................... #if OS_STIMERS > 0 
....................     #define OS_ENABLE_STIMERS   1 
.................... #endif 
....................  
....................  
....................  
.................... /*--------------------------------------------------*/ 
.................... /* Enable system timer if any type of timers used   */ 
.................... /*--------------------------------------------------*/ 
....................  
.................... #if defined(OS_ENABLE_DTIMERS)  ||              \ 
....................     defined(OS_ENABLE_TTIMERS)  ||              \ 
....................     defined(OS_ENABLE_STIMERS)  ||              \ 
....................     defined(OS_ENABLE_QTIMERS)  ||              \ 
....................     (OS_TIMERS > 0) 
....................  
....................     #define OS_ENABLE_OS_TIMER 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  DEFINE BANKS TO ALLOCATE DATA                                                               * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... /*------------------------------------------*/ 
.................... /* Check for old style defitions            */ 
.................... /*------------------------------------------*/ 
.................... #if     defined(OS_BANK)            ||      \ 
....................         defined(OS_TASKS_BANK)      ||      \ 
....................         defined(OS_TIMERS_BANK)     ||      \ 
....................         defined(OS_TIMERS8_BANK)    ||      \ 
....................         defined(OS_TIMERS16_BANK)   ||      \ 
....................         defined(OS_TIMERS24_BANK)   ||      \ 
....................         defined(OS_TIMERS32_BANK)   ||      \ 
....................         defined(OS_TIMEOUTS_BANK)   ||      \ 
....................         defined(OS_BSEM_BANK) 
....................  
.................... #error "OSA error #2: Constants OS_xxx_BANK are not allowed now (use OS_BANK_xxx instead)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
....................  
.................... #endif 
....................  
....................  
....................  
.................... /*------------------------------------------*/ 
.................... /*                                          */ 
.................... /* Set RAM bank constants                   */ 
.................... /*                                          */ 
.................... /*------------------------------------------*/ 
....................  
.................... #ifndef OS_BANK_OS 
.................... #define OS_BANK_OS      0               /* RAM bank for OSA internal variables  */ 
.................... #endif 
....................  
....................  
.................... #if defined(OS_BANK_TASK) && !defined(OS_BANK_TASKS) 
.................... #define OS_BANK_TASKS   OS_BANK_TASK 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #if defined(OS_ADDRESS_TASKS) && defined(__OSA_PIC16_MIKROC__)   // For direct allocation of 
....................     #define OS_ALLOCATION_TASKS absolute OS_ADDRESS_TASKS   // task descriptors in 
....................                                                             // mikroC PRO for PIC16 
.................... #else 
....................     #define OS_ALLOCATION_TASKS                             // Empty for others 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #ifndef OS_BANK_TASKS 
.................... #define OS_BANK_TASKS       OS_BANK_OS  /* RAM bank for task descriptors        */ 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS 
.................... #define OS_BANK_TIMERS      OS_BANK_OS  /* RAM bank for old style static timers */ 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS8 
.................... #define OS_BANK_TIMERS8     OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS16 
.................... #define OS_BANK_TIMERS16    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS24 
.................... #define OS_BANK_TIMERS24    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMERS32 
.................... #define OS_BANK_TIMERS32    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_TIMEOUTS 
.................... #define OS_BANK_TIMEOUTS    OS_BANK_TIMERS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_STIMERS 
.................... #define OS_BANK_STIMERS     OS_BANK_TIMERS  /* RAM bank for static timers       */ 
.................... #endif 
....................  
.................... #if defined(OS_BANK_BSEMS) && !defined(OS_BANK_BSEM) 
.................... #define OS_BANK_BSEM   OS_BANK_BSEMS 
.................... #endif 
....................  
.................... #ifndef OS_BANK_BSEM 
.................... #define OS_BANK_BSEM      OS_BANK_OS /* RAM bank for array of binary semaphores */ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  Checking validness of bank settings for each type of OSA data 
.................... //  
.................... //****************************************************************************** 
....................  
....................  
.................... #if     OS_BANK_OS == 0 
.................... #define OS_BANK         OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_OS == 1 
.................... #define OS_BANK         OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_OS == 2 
.................... #define OS_BANK         OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_OS == 3 
.................... #define OS_BANK         OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #3: Incorrect OS_BANK_OS value (should be 0, 1, 2 or 3)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TASKS == 0 
.................... #define OS_TASKS_BANK       OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TASKS == 1 
.................... #define OS_TASKS_BANK       OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TASKS == 2 
.................... #define OS_TASKS_BANK       OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TASKS == 3 
.................... #define OS_TASKS_BANK       OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #4: Incorrect OS_BANK_TASKS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS == 0 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS == 1 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS == 2 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS == 3 
.................... #define OS_TIMERS_BANK      OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #5: Incorrect OS_BANK_TIMERS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_STIMERS == 0 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_STIMERS == 1 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_STIMERS == 2 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_STIMERS == 3 
.................... #define OS_STIMERS_BANK     OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #6: Incorrect OS_BANK_STIMERS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS8 == 0 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS8 == 1 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS8 == 2 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS8 == 3 
.................... #define OS_TIMERS8_BANK     OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #7: Incorrect OS_BANK_TIMERS8 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS16 == 0 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS16 == 1 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS16 == 2 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS16 == 3 
.................... #define OS_TIMERS16_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #8: Incorrect OS_BANK_TIMERS16 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS24 == 0 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS24 == 1 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS24 == 2 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS24 == 3 
.................... #define OS_TIMERS24_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #9: Incorrect OS_BANK_TIMERS24 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMERS32 == 0 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMERS32 == 1 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMERS32 == 2 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMERS32 == 3 
.................... #define OS_TIMERS32_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #10: Incorrect OS_BANK_TIMERS32 value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_TIMEOUTS == 0 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 1 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 2 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_TIMEOUTS == 3 
.................... #define OS_TIMEOUTS_BANK    OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #11: Incorrect OS_BANK_TIMEOUTS value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
.................... #if     OS_BANK_BSEM == 0 
.................... #define OS_BSEM_BANK        OS_RAM_BANK0 
....................  
.................... #elif   OS_BANK_BSEM == 1 
.................... #define OS_BSEM_BANK        OS_RAM_BANK1 
....................  
.................... #elif   OS_BANK_BSEM == 2 
.................... #define OS_BSEM_BANK        OS_RAM_BANK2 
....................  
.................... #elif   OS_BANK_BSEM == 3 
.................... #define OS_BSEM_BANK        OS_RAM_BANK3 
....................  
.................... #else 
.................... #error  "OSA error #12: Incorrect OS_BANK_BSEM value (should be 0, 1, 2 or 3)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Definition of data sizes for each type of OSA data                                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Number of task descriptors (maximum active tasks at one time 
.................... //****************************************************************************** 
....................  
.................... #if defined (OS_TASKS) && (OS_TASKS == 0) 
.................... #undef OS_TASKS 
.................... #endif 
....................  
....................  
.................... #ifndef OS_TASKS 
.................... #define OS_TASKS    1       // We need at least 1 task 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Types of timers 
.................... //****************************************************************************** 
....................  
.................... #if defined(OST_TIMER) 
.................... #error "OSA error #13: OST_TlMER is not supported! Use OS_TIMER_SIZE instead (see manual)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... #if !defined(OS_TIMER_SIZE) 
....................     #define OS_TIMER_SIZE   2           /* Default timer size   */ 
.................... #endif 
....................  
.................... #if     OS_TIMER_SIZE == 1 
.................... #define OS_TIMER_TYPE       OST_UINT8 
....................  
.................... #elif   OS_TIMER_SIZE == 2 
.................... #define OS_TIMER_TYPE       OST_UINT16 
....................  
.................... #elif   OS_TIMER_SIZE == 4 
.................... #define OS_TIMER_TYPE       OST_UINT32 
....................  
.................... #else 
....................     #error "OSA error #17: Bad TIMER size (must be 1, 2 or 4)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of static timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_STIMER_SIZE) 
.................... #define OS_STIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_STIMER_SIZE == 1 
.................... #define OS_STIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_STIMER_SIZE == 2 
.................... #define OS_STIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_STIMER_SIZE == 4 
.................... #define OS_STIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #18: Bad STIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of dynamic timer's counter 
.................... //****************************************************************************** 
....................  
.................... #ifdef OS_PTIMER_SIZE        // Redefine old name (ptimer) to new (dtimer) 
.................... #define OS_DTIMER_SIZE OS_PTIMER_SIZE 
.................... #endif 
....................  
.................... #if !defined(OS_DTIMER_SIZE) 
.................... #define OS_DTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_DTIMER_SIZE == 1 
.................... #define OS_DTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_DTIMER_SIZE == 2 
.................... #define OS_DTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_DTIMER_SIZE == 4 
.................... #define OS_DTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #19: Bad DTIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of fast timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_QTIMER_SIZE) 
.................... #define OS_QTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_QTIMER_SIZE == 1 
.................... #define OS_QTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_QTIMER_SIZE == 2 
.................... #define OS_QTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_QTIMER_SIZE == 4 
.................... #define OS_QTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #21: Bad QTIMER size (must be 1, 2 or 4)"  
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Size of task timer's counter 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_TTIMER_SIZE) 
.................... #define OS_TTIMER_SIZE  OS_TIMER_SIZE 
.................... #endif 
....................  
.................... #if     OS_TTIMER_SIZE == 1 
.................... #define OS_TTIMER_TYPE      OST_UINT8 
....................  
.................... #elif   OS_TTIMER_SIZE == 2 
.................... #define OS_TTIMER_TYPE      OST_UINT16 
....................  
.................... #elif   OS_TTIMER_SIZE == 4 
.................... #define OS_TTIMER_TYPE      OST_UINT32 
....................  
.................... #else 
.................... #error "OSA error #20: Bad TTIMER size (must be 1, 2 or 4)" 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  S Y S T E M   D A T A   T Y P E S                                                           * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Simple byte message 
.................... // (this type should be defined BEFORE including port\osa_xxx.h) 
.................... //****************************************************************************** 
....................  
.................... #ifdef  OST_SMSG 
.................... #error "OSA error #14: Can't redefine name OST SMSG in 'OSAcfg.h'. Use OST_SMSG instead." 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
.................... #if !defined(OS_SMSG_TYPE) 
.................... #define     OS_SMSG_TYPE    unsigned char 
.................... #endif 
....................  
.................... typedef OS_SMSG_TYPE    _OST_SMSG;      //  See port\pic16\osa_pic16_htpicc.h for example 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     INCLUDE PROCESSOR SPECIFIC DEFINITIONS                                                   * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... #include "port\osa_include.h" 
....................  
.................... #define OST_WORD        OST_UINT 
.................... #define _OST_INT_TYPE   OST_WORD        // Old types redefining (don't use it) 
.................... #define __osa_word      OST_WORD        // Old types redefining (don't use it) 
.................... #define __osa_uint8     OST_UINT8       // Old types redefining (don't use it) 
.................... #define __osa_uint16    OST_UINT16      // Old types redefining (don't use it) 
.................... #define __osa_uint32    OST_UINT32      // Old types redefining (don't use it) 
....................  
....................  
.................... typedef OS_SMSG_TYPE    OST_SMSG; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to message 
.................... //****************************************************************************** 
....................  
.................... #ifdef  OST_MSG 
.................... #error "OSA error #15: Can't redefine name OST MSG in 'OSAcfg.h'. Use OST_MSG instead." 
....................         /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
.................... #if !defined(OS_MSG_TYPE) 
.................... #define OS_MSG_TYPE     void * 
.................... #endif 
....................  
....................  
.................... typedef OS_MSG_TYPE     OST_MSG; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to message descriptor 
.................... //****************************************************************************** 
....................  
.................... typedef  
.................... #ifndef __OSA_AVR_CODEVISION__ 
....................         volatile  
.................... #endif 
....................                     struct _OST_MSG_CB 
.................... { 
....................     OST_UINT        status;     // State (=1 - busy / =0 - free) 
....................     OST_MSG         msg;        // Pointer to message body 
....................  
.................... } OST_MSG_CB; 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Message's queues 
.................... //****************************************************************************** 
....................  
.................... /*--- Queue's control block                         ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_UINT   cSize;      // Queue size 
....................     OST_UINT   cFilled;    // Number of filled elements 
....................     OST_UINT   cBegin;     // First element in buffer 
....................                            //  
.................... } OST_QUEUE_CONTROL; 
....................  
....................  
.................... /*--- Descriptor of queue of pointers to messages   ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_QUEUE_CONTROL Q; 
....................     OST_MSG *pMsg;              // Pointer to queue buffer 
....................  
.................... } OST_QUEUE; 
....................  
....................  
.................... /*--- Descriptor of queue of simple messages        ---*/ 
....................  
.................... typedef struct 
.................... { 
....................     OST_QUEUE_CONTROL Q; 
....................     OST_SMSG *pSMsg;            // Pointer to queue buffer 
....................  
.................... } OST_SQUEUE; 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Flags 
.................... //****************************************************************************** 
....................  
.................... #define OST_FLAG    OST_UINT8 
.................... #define OST_FLAG8   OST_UINT8 
.................... #define OST_FLAG16  OST_UINT16 
.................... #define OST_FLAG32  OST_UINT32 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  System state flags 
.................... //  
.................... //  (!!!Do not change positions of theese bits. For MCC30 bits 
.................... //  cIPL_Temp must occupy 5, 6 and 7 positions) 
.................... //****************************************************************************** 
....................  
.................... typedef struct 
.................... { 
....................     /*0*/   OST_UINT   bEventError        : 1; // Event error 
....................     /*1*/   OST_UINT   bError             : 1; // Task create error 
....................                                                // Stimer Create error 
....................     /*2*/   OST_UINT   bInCriticalSection : 1; // One of task is in critical 
....................                                                // section 
....................     /*3*/   OST_UINT   bCheckingTasks     : 1; // OS_Sched: 
....................                                                //   =1 - best task searching 
....................                                                //   =0 - best task executed 
....................     /*4*/   OST_UINT   bBestTaskFound     : 1; // OS_Sched: Best task found 
....................  
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Processor specified bits 
....................     //------------------------------------------------------------------------------ 
....................             _OS_SYSTEM_FLAGS_PROC_SPEC()       // see definition in h-files for 
....................                                                // each processor type in "port" folder 
....................  
....................             #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................             OST_UINT   bEventOK           : 1; // Goes "1" when task was run after OS_Wait 
....................                                                // See OS_Sched definition 
....................                                                //  
....................                                                // Have #15 for PIC24 and dsPIC !!!! 
....................                                                //  
....................             #endif 
....................  
....................  
.................... } OST_SYSTEM_FLAGS; 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //  Task state flags 
.................... //  
.................... //  !Do not change placement of theese bits 
.................... //****************************************************************************** 
....................  
....................  
.................... #ifndef OSA_TASK_STATE_PROC_SPEC 
.................... #define OSA_TASK_STATE_PROC_SPEC() 
.................... #endif 
....................  
.................... typedef          struct 
.................... { 
....................     /*0..2*/OST_UINT   cPriority   : 3;     // Task priority (0..7) 
....................     /*3*/   OST_UINT   bReady      : 1;     // Ready to execute 
....................     /*4*/   OST_UINT   bDelay      : 1;     // Timer active: OS_Delay (bCanContinue=0) 
....................                                             // or event waiting with timeout (bCanContinue=1) 
....................  
....................     /*5*/   OST_UINT   bCanContinue: 1;     // Can continue, while bDelay flag is set 
....................     /*6*/   OST_UINT   bEnable     : 1;     // Descriptor is busy by task 
....................     /*7*/   OST_UINT   bPaused     : 1;     // Task paused (it is still active, but can 
....................                                             // became ready only from extenal task) 
....................  
....................             OSA_TASK_STATE_PROC_SPEC()      // see definition in h-files for 
....................                                             // each processor type in "port" folder 
....................  
.................... } OST_TASK_STATE; 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
.................... #define OS_TASK_PRIORITY_MASK       0x07 
.................... #define OS_TASK_READY_MASK          0x08 
.................... #define OS_TASK_DELAY_MASK          0x10 
.................... #define OS_TASK_CANCONTINUE_MASK    0x20 
.................... #define OS_TASK_ENABLE_MASK         0x40 
.................... #define OS_TASK_PAUSED_MASK         0x80 
....................  
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Task control block (descriptor) 
.................... //****************************************************************************** 
....................  
.................... typedef struct 
.................... { 
....................     OST_TASK_STATE      State;              // Current task state 
....................     OST_CODE_POINTER    pTaskPointer;       // ROM pointer 
....................  
....................     //------------------------------------------------------------------------------ 
....................     // Processor specified bits 
....................     //------------------------------------------------------------------------------ 
....................     _OS_TCB_PROC_SPEC()                     // see definition in h-files for 
....................                                             // each processor type in "port" folder 
....................  
....................     #ifdef OS_ENABLE_TTIMERS 
....................     OS_TTIMER_TYPE     Timer;               // Timer counter for delays 
....................     #endif 
....................  
.................... } OST_TCB;   // Task Control Block 
....................  
....................  
.................... #ifndef OST_TASK_POINTER 
.................... typedef OS_TASKS_BANK OST_TCB *     OST_TASK_POINTER; 
.................... #endif 
....................  
....................  
.................... #define OS_WORST_PRIORITY       7       // Lowest priority 
.................... #define OS_BEST_PRIORITY        0       // Highest priority 
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  T I M E R S   D A T A   T Y P E S                                                           * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //****************************************************************************** 
.................... //  Dynamic timers 
.................... //****************************************************************************** 
....................  
.................... //--------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Dynamic timer's state flags             * 
....................      *                                          * 
....................      *  !Do not change placement of variables   * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef  
....................     #ifndef __OSA_AVR_CODEVISION__ 
....................             volatile  
....................     #endif 
....................                         struct 
....................     { 
....................         OST_UINT   bTimeout    : 1;    // Overflow occured 
....................         OST_UINT   bActive     : 1;    // Timer is active (was created by OS_Dtimer_Create) 
....................                                        // (For system variable _OS_DTimers.Flags allways = 1) 
....................  
....................         OST_UINT   bRun        : 1;    // = 1 - Timer is counnting 
....................                                        // = 0 - Timer is stopped 
....................  
....................         OST_UINT   bNextEnable : 1;    // = 0 - last timer in list, 
....................                                        // = 1 - there is next timer 
....................     } OST_DTIMER_FLAGS; 
....................  
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Dynamic timer's descriptor              * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct S_OST_DTIMER 
....................     { 
....................         OST_DTIMER_FLAGS        Flags;       // Timer's state flags 
....................         struct S_OST_DTIMER    *Next;        // Pointer to next timer in list 
....................         OS_DTIMER_TYPE          Timer;       // Counter 
....................                                              //  
....................     } OST_DTIMER; 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Header of list of dynamic timers        * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct 
....................     { 
....................         OST_DTIMER_FLAGS        Flags; 
....................         struct S_OST_DTIMER    *Next;          // Pointer to first timer in list 
....................  
....................     } OST_DTIMER_CB; 
....................  
.................... //--------------------------------------------------------------- 
.................... #endif  // OS_ENABLE_DTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Queue of timers 
.................... //****************************************************************************** 
....................  
.................... //--------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_QTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Fast timer's state flags                * 
....................      *                                          * 
....................      *  !Do not change placement of variables   * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef  
....................     #ifndef __OSA_AVR_CODEVISION__ 
....................             volatile  
....................     #endif 
....................                         struct 
....................     { 
....................         OST_UINT   bTimeout      : 1;  // Overflow occured 
....................         OST_UINT   bActive       : 1;  // Timer is active (was created by OS_Dtimer_Create) 
....................                                        // (For system variable _OS_DTimers.Flags allways = 1) 
....................  
....................         OST_UINT   bRun          : 1;  // = 1 - Timer is counnting 
....................                                        // = 0 - Timer is stopped 
....................  
....................         OST_UINT   bNextEnable   : 1;  // = 0 - last timer in list, 
....................                                        // = 1 - there is next timer 
....................  
....................        //------------------------------// Functions for OS_Qtimer_List: 
....................                                        // 
....................         OST_UINT   bListFunction : 1;  // = 00 - add timer into the list 
....................                                        // = 01 - delete timer from the list 
....................         OST_UINT   bListGetTime  : 1;  // = 1x - get remaining time 
....................  
....................         //-----------------------------// Internal OS_Qtimer_List bits: 
....................         OST_UINT   bAddAfterDelete:1;  // = 1 - when adding already existing timer it 
....................                                        //       has to be deleted first 
....................  
....................  
....................     } OST_QTIMER_FLAGS; 
....................  
....................     #define OS_QTIMER_LIST_FUNCTION_ADD     0 
....................     #define OS_QTIMER_LIST_FUNCTION_DELETE  1 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Fast timer's control block              * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct S_OST_QTIMER 
....................     { 
....................         OST_QTIMER_FLAGS        Flags;         // Timer's state flags 
....................         struct S_OST_QTIMER    *Next;          // Pointer to next timer in list 
....................         OS_QTIMER_TYPE          Timer;         // Counter 
....................                                                //  
....................     } OST_QTIMER; 
....................  
....................     /* 
....................      *------------------------------------------* 
....................      *                                          * 
....................      *  Header of list of fast timers           * 
....................      *                                          * 
....................      *------------------------------------------* 
....................      */ 
....................  
....................     typedef struct 
....................     { 
....................         OST_QTIMER_FLAGS        Flags; 
....................         struct S_OST_QTIMER    *Next;          // Pointer to first timer in list 
....................     } OST_QTIMER_CB; 
....................  
.................... //--------------------------------------------------------------- 
.................... #endif  // OS_ENABLE_QTIMERS 
.................... //--------------------------------------------------------------- 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Counting semaphores 
.................... //****************************************************************************** 
....................  
.................... #if !defined(OS_CSEM_SIZE) 
.................... #define OS_CSEM_SIZE    1 
.................... #endif 
....................  
.................... #if     OS_CSEM_SIZE == 1 
.................... typedef OST_UINT8   OST_CSEM; 
.................... #elif   OS_CSEM_SIZE == 2 
.................... typedef OST_UINT16  OST_CSEM; 
.................... #elif   OS_CSEM_SIZE == 4 
.................... typedef OST_UINT32  OST_CSEM; 
.................... #else 
....................     #error "OSA error #16: Incorrect OS_CSEM_SIZE value (m.b. only 1, 2 or 4)! (see OSAcfg.h)" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  OSA system variables prototypes                                                             * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... extern  volatile OS_RAM_NEAR    OST_SYSTEM_FLAGS    _OS_Flags; 
.................... extern           OS_RAM_NEAR    OST_UINT            _OS_Temp; 
....................  
.................... #ifndef __OSA12__ 
.................... extern  volatile OS_RAM_NEAR    OST_UINT            _OS_TempH; 
.................... #endif 
....................  
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
.................... extern  volatile OS_RAM_NEAR    OST_TASK_STATE      _OS_State; 
.................... #endif 
....................  
....................  
.................... //****************************************************************************** 
.................... //  Pointer to current task 
.................... //****************************************************************************** 
....................  
.................... #ifdef __OSA_CCS__ 
.................... // The CCS compiler do not allows to declare a volatile pointers 
.................... extern OST_TASK_POINTER OS_RAM_NEAR             _OS_CurTask; 
.................... #else 
.................... extern OST_TASK_POINTER OS_RAM_NEAR volatile    _OS_CurTask; 
.................... #endif 
....................  
....................  
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL 
....................  
....................     extern  OS_BANK          OST_UINT               _OS_Best_Priority; 
....................      
....................     #if defined(__OSA_CCS__) || defined(__OSA_IAR__) 
....................     // The CCS compiler do not allows to declare a volatile pointers 
....................     extern OST_TASK_POINTER OS_BANK                 _OS_BestTask; 
....................     extern OST_TASK_POINTER OS_BANK                 _OS_LastTask; 
....................     #else 
....................     extern OST_TASK_POINTER OS_BANK     volatile    _OS_BestTask; 
....................     extern OST_TASK_POINTER OS_BANK     volatile    _OS_LastTask; 
....................     #endif 
....................  
.................... #endif 
....................  
....................  
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................  
.................... /*  
....................     typedef union 
....................     {    
....................         struct  
....................         { 
....................             OST_UINT8   cPriority; 
....................             OST_UINT8   cTaskPos; 
....................         } Bytes; 
....................  
....................         OST_UINT16  Word; 
....................  
....................     } OST_TASK_QUEUE; 
.................... */ 
....................  
....................     extern  OS_BANK OST_UINT    _OS_Best_Priority; 
....................     extern  OS_BANK OST_UINT    _OS_Worst_Priority; 
....................     extern  OS_BANK OST_UINT    _OS_Best_n; 
....................     extern  OS_BANK OST_UINT    _OS_Cur_Pos; 
....................     extern  OS_BANK OST_UINT    _OS_n; 
....................     extern  OS_BANK OST_UINT8   _OS_TaskQueue[OS_TASKS];    // Queue of lesting in scheduler 
....................     extern  OS_BANK OST_UINT8   _OS_TaskLevel[OS_TASKS];    // Current priority levels 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Internal macro for work with state flags                                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
.................... */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(OS_CUR_FLAGS_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................  
....................     #define _OS_bTaskReady              _OS_State.bReady 
....................     #define _OS_bTaskCanContinue        _OS_State.bCanContinue 
....................     #define _OS_bTaskDelay              _OS_State.bDelay 
....................     #define _OS_bTaskTimeout            (!_OS_State.bDelay) 
....................     #define _OS_bTaskEnable             _OS_State.bEnable 
....................     #define _OS_cTaskPriority           _OS_State.cPriority 
....................     #define _OS_bTaskPaused             _OS_State.bPaused 
....................  
.................... #endif 
....................  
.................... #if defined(_OS_CUR_FLAGS_IN_FSR) 
....................  
....................     #define _OS_bTaskReady              ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bReady 
....................     #define _OS_bTaskCanContinue        ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bCanContinue 
....................     #define _OS_bTaskDelay              ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bDelay 
....................     #define _OS_bTaskTimeout            (!((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bDelay) 
....................     #define _OS_bTaskEnable             ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bEnable 
....................     #define _OS_cTaskPriority           ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->cPriority 
....................     #define _OS_bTaskPaused             ((OS_RAM_NEAR OST_TASK_STATE*)(&_indf))->bPaused 
....................  
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_CUR_FLAGS_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  Include definitions of services:                                                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... #include "kernel\osa_oldnames.h"            // Table of alternate names 
....................  
.................... #include "kernel\system\osa_system.h"       // System services 
.................... #include "kernel\system\osa_tasks.h"        // Tasks 
....................  
.................... #include "kernel\events\osa_bsem.h"         // Binary semaphores 
.................... #include "kernel\events\osa_csem.h"         // Counting semaphores 
.................... #include "kernel\events\osa_flag.h"         // Flags 
.................... #include "kernel\events\osa_msg.h"          // Pointer to messages 
.................... #include "kernel\events\osa_queue.h"        // Queue of pointers to messages 
.................... #include "kernel\events\osa_smsg.h"         // Simple messages 
.................... #include "kernel\events\osa_squeue.h"       // Queue of simple messages 
....................  
.................... #include "kernel\timers\osa_stimer.h"       // Static timers 
.................... #include "kernel\timers\osa_stimer_old.h"   // Old style static timers 
.................... #include "kernel\timers\osa_dtimer.h"       // Dynamic timers 
.................... #include "kernel\timers\osa_qtimer.h"       // Fast timers 
.................... #include "kernel\timers\osa_ttimer.h"       // Task timers 
.................... #include "kernel\timers\osa_timer.h"        // System timer 
....................  
....................  
....................  
.................... /* This constant is defined in service's files */ 
....................  
.................... #if defined(OS_ENABLE_INT) 
....................  
....................     extern  volatile OS_RAM_NEAR OST_UINT _OS_Temp_I; 
....................  
....................     // _OS_DI_INT() and _OS_RI_INT() are defined in port\osa_xxx.h files for each platform 
....................  
.................... #else 
....................  
....................     #define _OS_DI_INT() 
....................     #define _OS_RI_INT() 
....................  
.................... #endif 
....................  
.................... #define _OS_ATOMIC_WRITE_A(expr)        \ 
....................     OSM_BEGIN {                         \ 
....................         _OS_DI_INT();                   \ 
....................         expr;                           \ 
....................         _OS_RI_INT();                   \ 
....................     } OSM_END 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // These two macros are used in mikroC for PIC16. For all others they are  
.................... // defined as empty macros 
.................... // ----------------------------------------------------------------------------- 
.................... #ifndef _OS_SET_IRP_CUR_TASK 
.................... #define _OS_SET_IRP_CUR_TASK() 
.................... #endif 
....................  
.................... #ifndef _OS_CLR_IRP 
.................... #define _OS_CLR_IRP() 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... #ifdef __OSA_CCS__ 
.................... #include <osa.c> 
.................... #endif 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa.h 
.................... //****************************************************************************** 
....................      
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *  V A R I A B L E S   D E F I N I T I O N                                                     * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef __OSA_PIC18_MPLABC__ 
.................... #pragma udata access ACCESS 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................     volatile OS_RAM_NEAR    OST_SYSTEM_FLAGS    _OS_Flags;      // System state flags 
....................              OS_RAM_NEAR    OST_WORD            _OS_Temp;       // For internal purpose 
....................      
....................     #if defined(OS_ENABLE_INT) || defined(OS_PROTECT_MEMORY_ACCESS) 
....................     volatile OS_RAM_NEAR    OST_WORD            _OS_Temp_I; 
....................     #endif 
....................      
....................     #ifndef __OSA_PIC12_HTPICC__ 
....................     volatile OS_RAM_NEAR    OST_WORD            _OS_TempH;      // For internal purpose 
....................     #endif 
....................      
....................     #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................     volatile OS_RAM_NEAR    OST_TASK_STATE      _OS_State; 
....................     #endif 
....................      
....................     #ifdef __OSA_CCS__ 
.................... // The CCS compiler do not allows to declare a volatile pointers 
....................     OST_TASK_POINTER OS_RAM_NEAR           _OS_CurTask;    // Pointer to current task 
....................     #else 
....................     OST_TASK_POINTER OS_RAM_NEAR volatile  _OS_CurTask;    // Pointer to current task 
....................     #endif 
....................                                                                     // descriptor. 
.................... //------------------------------------------------------------------------------ 
.................... #ifdef __OSA_PIC18_MPLABC__ 
.................... #pragma udata 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL 
.................... //------------------------------------------------------------------------------ 
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
....................     #if defined(__OSA_CCS__) || defined(__OSA_IAR__) 
....................     // The CCS compiler do not allows to declare a volatile pointers 
....................     OST_TASK_POINTER    OS_BANK          _OS_BestTask;  // Pointer to ready task with the highest priority 
....................     OST_TASK_POINTER    OS_BANK          _OS_LastTask;  // Pointer to last executed task 
....................     #else 
....................     OST_TASK_POINTER    OS_BANK volatile _OS_BestTask;  // Pointer to ready task with the highest priority 
....................     OST_TASK_POINTER    OS_BANK volatile _OS_LastTask;  // Pointer to last executed task 
....................     #endif 
....................     OS_BANK OST_WORD                     _OS_Best_Priority; 
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
.................... //------------------------------------------------------------------------------ 
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
....................     OS_BANK OST_UINT    _OS_Best_Priority; 
....................     OS_BANK OST_UINT    _OS_Worst_Priority; 
....................     OS_BANK OST_UINT    _OS_Best_n; 
....................     OS_BANK OST_UINT    _OS_Cur_Pos; 
....................     OS_BANK OST_UINT    _OS_n; 
....................     OS_BANK OST_UINT8   _OS_TaskQueue[OS_TASKS];    // Queue of lesting in scheduler 
....................     OS_BANK OST_UINT8   _OS_TaskLevel[OS_TASKS];    // Current priority levels 
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *  I N C L U D E   C O M P I L E R   S P E C I F I E D   D E F I N I T I O N S                 * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... #include "port\osa_include.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_include.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Include the proc. specific file. 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        19.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(__OSA_PIC18_HTPICC__)               // HT-PICC18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_htpicc.c> 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MPLABC__)             // MPLAB C18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mplabc.c>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MPLABC_EXT__)         // MPLAB C18 for extended mode  
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mplabc_ext.c>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC24_MPLABC__)             // MPLAB C30 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic24\osa_pic24_mplabc.c>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_CCS__)                // CCS-PICC (for PIC16 only) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_ccs.c>           
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_CCS__)                // CCS-PICC (for PIC18 only) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_ccs.c>           
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_pic18_ccs.c 
....................  * 
....................  *  Compilers:      CCS 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    CCS for PIC18 specific functions definition 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        13.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... // 
.................... //  _OS_INIT_PROC_SPEC. 
.................... // 
.................... //****************************************************************************** 
.................... // 
.................... //  Specific macro for CCS18 compiler: 
.................... // 
.................... //  The problem is that system functions that operate with stack can be 
.................... //  called through 'goto' operator in case when there is only one call of 
.................... //  function. To avoid it we call all these functions once to be sure that 
.................... //  in case of they will be used in program, compilser will call them by 'call', 
.................... //  not 'goto'. 
.................... // 
.................... //****************************************************************************** 
....................  
....................  
.................... #define _OS_INIT_PROC_SPEC()                      \ 
....................     _OS_Temp = 0;                               \ 
....................     if (_OS_Temp & 1)                           \ 
....................     {                                           \ 
....................         _OS_ReturnSave();                       \ 
....................         _OS_ReturnNoSave();                     \ 
....................         _OS_EnterWaitMode();                    \ 
....................         _OS_EnterWaitModeTO();                  \ 
....................         _OS_CheckEvent(0);                      \ 
....................         _OS_JumpToTask();                       \ 
....................     } 
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                           K E R N E L   F U N C T I O N S                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... #separate void _OS_ClrReadySetClrCanContinue (void); 
....................  
....................  
....................  
.................... #separate 
.................... void _OS_JumpToTask (void) 
.................... { 
....................     _OS_SET_FSR_CUR_TASK(); 
*
293C:  MOVF   2B,W
293E:  MOVWF  FE9
2940:  MOVFF  2C,FEA
....................     (OS_RAM_NEAR char)_OS_State = _postinc; 
2944:  MOVFF  FEE,2A
....................     _OS_SET_PC(); 
2948:  MOVFF  FEE,FE8
294C:  MOVFF  FEE,FFA
2950:  MOVWF  FF9
.................... } 
2952:  RETURN 0
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_ReturnSave (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Return to sheduler with saving current task return point 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #separate void _OS_ReturnSave (void) 
.................... { 
....................     _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET - 1); 
*
2894:  MOVF   2B,W
2896:  MOVWF  xCA
2898:  MOVFF  2C,CB
289C:  MOVLW  02
289E:  ADDWF  xCA,F
28A0:  MOVLW  00
28A2:  ADDWFC xCB,F
28A4:  MOVLW  01
28A6:  ADDWF  xCA,F
28A8:  MOVLW  00
28AA:  ADDWFC xCB,F
28AC:  MOVLW  01
28AE:  SUBWF  xCA,W
28B0:  MOVWF  FE9
28B2:  MOVLW  00
28B4:  SUBWFB xCB,W
28B6:  MOVWF  FEA
....................     _OS_SAVE_PC(); 
28B8:  MOVFF  FFE,FED
28BC:  MOVFF  FFD,FED
....................     _OS_bTaskReady = 1; 
28C0:  BSF    2A.3
....................     _OS_POP(); 
28C2:  POP   
.................... } 
28C4:  RETURN 0
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_ReturnSave (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Return to sheduler without saving current task return point 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #separate void _OS_ReturnNoSave (void) 
.................... { 
....................     _OS_POP(); 
28C6:  POP   
.................... } 
28C8:  GOTO   296A (RETURN)
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void __OS_EnterWaitMode (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Clear bReady flag and return to the sheduler with seaving 
....................  *                  task return point 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #separate void _OS_EnterWaitMode (void) 
.................... { 
....................     _OS_Temp = 0; 
*
290A:  CLRF   28
....................     _OS_ClrReadySetClrCanContinue(); 
290C:  RCALL  28CC
.................... } 
290E:  RETURN 0
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void __OS_EnterWaitModeTO (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Clear bReady flag, set bCanContinue flag and return to the 
....................  *                  sheduler with seaving task return point 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #separate void _OS_EnterWaitModeTO (void) 
.................... { 
....................     _OS_Temp = 0xFF; 
2910:  SETF   28
....................     _OS_ClrReadySetClrCanContinue(); 
2912:  RCALL  28CC
.................... } 
2914:  GOTO   296E (RETURN)
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_ClrReadySetClrCanContinue (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Addition function. Called only by GOTO from: 
....................  *                      _OS_EnterWaitMode() 
....................  *                      _OS_EnterWaitModeTO() 
....................  *                  Stack has pointer of task who called theese services. 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... #separate void _OS_ClrReadySetClrCanContinue (void) 
.................... { 
....................     _OS_POP(); 
*
28CC:  POP   
....................  
....................     _OS_Flags.bEventError = 0; 
28CE:  BCF    27.0
....................  
....................     _OS_SET_FSR_CUR_TASK_W(OS_CODE_POINTER_SIZE + _OS_TASK_POINTER_OFFSET - 1); 
28D0:  MOVFF  2B,CA
28D4:  MOVFF  2C,CB
28D8:  MOVLW  02
28DA:  ADDWF  xCA,F
28DC:  MOVLW  00
28DE:  ADDWFC xCB,F
28E0:  MOVLW  01
28E2:  ADDWF  xCA,F
28E4:  MOVLW  00
28E6:  ADDWFC xCB,F
28E8:  MOVLW  01
28EA:  SUBWF  xCA,W
28EC:  MOVWF  FE9
28EE:  MOVLW  00
28F0:  SUBWFB xCB,W
28F2:  MOVWF  FEA
....................     _OS_SAVE_PC(); 
28F4:  MOVFF  FFE,FED
28F8:  MOVFF  FFD,FED
....................  
....................     _OS_bTaskReady = 0; 
28FC:  BCF    2A.3
....................  
....................     #if defined(OS_ENABLE_TTIMERS) 
....................  
....................         if (!_OS_bTaskDelay) _OS_bTaskCanContinue = 0; 
28FE:  BTFSS  2A.4
2900:  BCF    2A.5
....................         if (_OS_Temp & 0x01) _OS_bTaskCanContinue = 1; 
2902:  BTFSC  28.0
2904:  BSF    2A.5
....................  
....................     #endif 
....................  
....................     _OS_POP(); 
2906:  POP   
.................... } 
2908:  RETURN 0
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                            S Y S T E M   F U N C T I O N S                                   * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  char OS_DI (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Disable interrupt with GIE saving 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      char - bit 7 = previous GIEH value, 
....................  *                         bit 6 = previous GIEL value 
....................  *                         bits 0..5 = 0 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------- 
.................... #define OS_DI_DEFINED 
.................... //------------------------------------------------------------------------------- 
....................  
.................... char OS_DI (void) 
.................... { 
....................     char temp; 
....................     temp = _intcon & 0xC0; 
....................     _gie = 0; 
....................     if (_ipen) _giel = 0; 
....................     return temp; 
.................... } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_DI_INT (void) 
....................     { 
....................         _OS_Temp_I = _intcon & 0xC0; 
....................         _gie = 0; 
....................         if (_ipen) _giel = 0; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  char OS_RI (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Restore saved by OS_DI() GIEx states 
....................  * 
....................  *  parameters:     char - bit 7 = previos GIE value, bits 0..6 = 0 
....................  * 
....................  *  on return:      none 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------- 
.................... #define OS_RI_DEFINED 
.................... //------------------------------------------------------------------------------- 
....................  
.................... void OS_RI (char temp) 
.................... { 
....................     if (temp & 0x80) _gie = 1; 
....................     if (_ipen) 
....................     { 
....................         if (temp & 0x40) _giel = 1; 
....................     } 
.................... } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_RI_INT (void) 
....................     { 
....................         if (_OS_Temp_I & 0x80) _gie = 1; 
....................         if (_ipen) 
....................         { 
....................             if (_OS_Temp_I & 0x40) _giel = 1; 
....................         } 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                   D E L A Y S   I N   T A S K                                * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void _OS_InitDelay (OS_TTIMER_TYPE Delay) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel) 
....................  * 
....................  *                  Init task timer delay.Set timer variable in task descriptor, 
....................  *                  sets bit bDelay and clears bit bCanContinue. 
....................  * 
....................  *                  _OS_CurTask must point to descriptor. 
....................  * 
....................  * 
....................  *  parameters:     Delay   - time of delay in system ticks 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  note:           This function overloads "osa.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_InitDelay_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
.................... void _OS_InitDelay (OS_TTIMER_TYPE Delay) 
.................... { 
....................  
....................     _OS_bTaskCanContinue = 0; 
*
2BBA:  BCF    2A.5
....................     _OS_bTaskDelay = 0;         // Clear bDelay to prevent timer changing in interrupt 
2BBC:  BCF    2A.4
....................     _OS_SET_FSR_CUR_TASK(); 
2BBE:  MOVFF  2B,FE9
2BC2:  MOVFF  2C,FEA
....................     _indf = (OS_RAM_NEAR char)_OS_State; 
2BC6:  MOVFF  2A,FEF
....................  
....................     if (Delay) 
2BCA:  MOVF   xCA,W
2BCC:  IORWF  xCB,W
2BCE:  BZ    2C0C
....................     { 
....................  
....................         Delay ^= -1; 
2BD0:  MOVF   xCA,W
2BD2:  XORLW  FF
2BD4:  MOVWF  00
2BD6:  MOVF   xCB,W
2BD8:  XORLW  FF
2BDA:  MOVFF  00,CA
2BDE:  MOVWF  xCB
....................         Delay ++; 
2BE0:  INCF   xCA,F
2BE2:  BTFSC  FD8.2
2BE4:  INCF   xCB,F
....................  
....................         _OS_CurTask->Timer = Delay; 
2BE6:  MOVLW  03
2BE8:  ADDWF  2B,W
2BEA:  MOVWF  FE9
2BEC:  MOVLW  00
2BEE:  ADDWFC 2C,W
2BF0:  MOVWF  FEA
2BF2:  MOVFF  CB,FEC
2BF6:  MOVF   FED,F
2BF8:  MOVFF  CA,FEF
....................  
....................         _OS_bTaskDelay = 1; 
2BFC:  BSF    2A.4
....................         _OS_bTaskReady = 1; 
2BFE:  BSF    2A.3
....................         _OS_SET_FSR_CUR_TASK(); 
2C00:  MOVFF  2B,FE9
2C04:  MOVFF  2C,FEA
....................         _indf = (OS_RAM_NEAR char)_OS_State; 
2C08:  MOVFF  2A,FEF
....................  
....................     } 
.................... } 
2C0C:  RETURN 0
....................  
.................... //______________________________________________________________________________ 
.................... //****************************************************************************** 
....................  
.................... #endif  // #ifdef OS_TIMER 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_CheckEvent (char bEvent) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  waiting services) 
....................  * 
....................  *                  Check condition of bEvent. Accordint to bEvent value and 
....................  *                  current state of bReady, bDelay and bCanContinue flags, 
....................  *                  task becames ready to execute or still remains in waiting 
....................  *                  mode. 
....................  * 
....................  *  parameters:     bEvent - zero, or non-zero condition 
....................  * 
....................  *  on return:      1 - when condition is true, or timeout occured 
....................  *                  0 - condition is false and no timeout 
....................  * 
....................  *  note:           This function overloads "osa.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_CheckEvent_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
.................... #separate void _OS_CheckEvent (OST_UINT bEvent) 
.................... { 
....................     //------------------------------------------------------------------------------ 
....................     #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED 
....................     //------------------------------------------------------------------------------ 
....................  
....................         _OS_Flags.bTimeout = 0; 
*
2918:  BCF    27.5
....................         _OS_SET_FSR_CUR_TASK(); 
291A:  MOVFF  2B,FE9
291E:  MOVFF  2C,FEA
....................  
....................         if (bEvent) 
2922:  MOVF   xCB,F
2924:  BZ    292C
....................         { 
....................             #ifdef OS_ENABLE_TTIMERS 
....................  
....................                 _OS_bTaskDelay = 0; // Clear bDelay in temporary variable _OS_State 
2926:  BCF    2A.4
....................                 _indf &= ~0x10;     // Clear bDelay in task descriptor 
2928:  BCF    FEF.4
....................  
....................             #endif 
....................             return; 
292A:  BRA    293A
....................  
....................         } 
....................  
....................         #ifdef OS_ENABLE_TTIMERS 
....................  
....................             if (_OS_bTaskTimeout && _OS_bTaskCanContinue) 
292C:  BTFSC  2A.4
292E:  BRA    2938
2930:  BTFSS  2A.5
2932:  BRA    2938
....................             { 
....................                 _OS_Flags.bTimeout = 1; 
2934:  BSF    27.5
....................                 return; 
2936:  BRA    293A
....................             } 
....................  
....................         #endif 
....................  
....................         _OS_POP(); 
2938:  POP   
....................  
....................     //------------------------------------------------------------------------------ 
....................     #else 
....................     //------------------------------------------------------------------------------ 
....................  
....................         _OS_Flags.bTimeout = 0; 
....................         _OS_SET_FSR_CUR_TASK(); 
....................  
....................         if (bEvent) 
....................         { 
....................             if (_OS_bTaskReady) 
....................             { 
....................                 #ifdef OS_ENABLE_TTIMERS 
....................  
....................                     _OS_bTaskDelay = 0; // Clear bDelay in temporary variable _OS_State 
....................                     _indf &= ~0x10;     // Clear bDelay in task descriptor 
....................  
....................                 #endif 
....................  
....................                 #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................                 _OS_Flags.bEventOK = 1; 
....................                 #endif 
....................  
....................                 return; 
....................             } 
....................  
....................             _OS_bTaskReady = 1; 
....................  
....................         } else { 
....................             _OS_bTaskReady = 0; 
....................         } 
....................  
....................         #ifdef OS_ENABLE_TTIMERS 
....................  
....................             if (_OS_bTaskTimeout && _OS_bTaskCanContinue) 
....................             { 
....................                 _OS_bTaskReady = 1; 
....................                 _OS_Flags.bTimeout = 1; 
....................  
....................                 #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................                 _OS_Flags.bEventOK = 1; 
....................                 #endif 
....................  
....................                 return; 
....................             } 
....................  
....................         #endif 
....................  
....................         _OS_POP(); 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #endif 
....................     //------------------------------------------------------------------------------ 
....................  
.................... } 
293A:  RETURN 0
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                     W O R K   W I T H   D Y N A M I C   T I M E R S                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //----------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //----------------------------------------------------------------- 
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_Dtimer_Create (OST_DTIMER *dtimer) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  service OS_Dtimer_Create) 
....................  * 
....................  *                  Add dynamic timer into list of active dynamic timers. This 
....................  *                  timer will be added at first position in list. 
....................  * 
....................  * 
....................  *  parameters:     dtimer - pointer to dynamic timer. 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  note:           This function overloads "osa.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_Dtimer_Create_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
.................... void _OS_Dtimer_Create (OST_DTIMER *dtimer) 
.................... { 
....................     _OS_Temp = OS_DI(); 
....................  
....................     _fsr = (OS_FSR_TYPE) dtimer; 
....................     _postinc = (OS_BANK char)_OS_DTimers.Flags; 
....................     // Here: bActive is set, 
....................     //       bTimeout is cleared, 
....................     //       bRun is cleared 
....................     //       bNextEnable is copied 
....................  
....................     _postinc = _OS_DTimers.Next & 0xFF; 
....................     _postinc = _OS_DTimers.Next >> 8; 
....................  
....................     _postinc = 0; 
....................  
....................     #if  OS_DTIMER_SIZE >= 2 
....................     _postinc = 0; 
....................     #endif 
....................     #if  OS_DTIMER_SIZE == 4 
....................     _postinc = 0; 
....................     _postinc = 0; 
....................     #endif 
....................  
....................     _OS_DTimers.Next = (OST_DTIMER*)dtimer; 
....................     _OS_DTimers.Flags.bNextEnable = 1; 
....................  
....................     OS_RI(_OS_Temp); 
.................... } 
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_Dtimer_Delete (OST_DTIMER *dtimer) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  service OS_Dtimer_Delete) 
....................  * 
....................  *                  Delete dynamic timer from list of active timers. It is 
....................  *                  recommended to delete all unused dynamic timers to avoid 
....................  *                  speed down. 
....................  * 
....................  *  parameters:     dtimer - pointer to deleting dynamic timer 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  note:           This function overloads "osa.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #define _OS_Dtimer_Delete_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
.................... void _OS_Dtimer_Delete (OST_DTIMER *dtimer) 
.................... { 
....................     char ptcb0, ptcb1; 
....................  
....................     char flags; 
....................  
....................     _fsr = (OS_FSR_TYPE)dtimer; 
....................  
....................     _OS_IndfTimerActive = 0; 
....................  
....................     flags = _postinc; 
....................     ptcb0 = _postinc; 
....................     ptcb1 = _postinc; 
....................  
....................     _fsr = (OS_FSR_TYPE)&_OS_DTimers; 
.................... REPEAT: 
....................     if (_OS_PostincTimerNextEnable) 
....................     { 
....................         if (_indf == ((char)dtimer)) 
....................         { 
....................             if (_preinc == ((int16)dtimer)>>8){ 
....................                 _OS_Temp = OS_DI(); 
....................                 _postdec = ptcb1; 
....................                 _postdec = ptcb0; 
....................  
....................                 if (!(flags & 0x8)) _OS_IndfTimerNextEnable = 0;   // Check for bNextEnable 
....................                 // If we check in other way (for example: !((OST_DTIMER_FLAGS*)&flags)->bNextEnable) 
....................                 // then compiler can use FSR0 (for some compilers: MCC18 e.g.),  as a result 
....................                 // current pointer to dtimer will be lost 
....................                 OS_RI(_OS_Temp); 
....................                 return; 
....................             } 
....................             _fsr--; 
....................         } 
....................         _OS_Temp = _postinc; 
....................         _indf = _postinc; 
....................         _fsrl = _OS_Temp; 
....................  
....................         goto REPEAT; 
....................     } 
....................  
.................... } 
....................  
....................  
....................  
....................  
.................... #endif  //  OS_ENABLE_DTIMERS 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_pic18_ccs.c 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC12_HTPICC__)             // HT_PICC for 12-bit PICs 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic12\osa_pic12_htpicc.c>          
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_HTPICC__)             // HT_PICC 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_htpicc.c>          
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16E_HTPICC_PRO__)        // HT_PICC_PRO for pic16f1xxx 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16e_htpicc_pro.c>      
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC16_MIKROC__)             // mikroC for PIC16 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic16\osa_pic16_mikroc.c>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_PIC18_MIKROC__)             // mikroC for PIC18 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\pic18\osa_pic18_mikroc.c>        
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_WINAVR__)               // WinAVR for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_winavr.c>         
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_IAR__)                  // IAR for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_iar.c>         
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_AVR_CODEVISION__)           // CodeVision for Atmel AVR 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\avr\osa_avr_codevision.c> 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_IAR__)                 // IAR for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_iar.c>       
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_COSMIC__)              // Cosmic for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_cosmic.c>       
....................  
.................... //------------------------------------------------------------------------------ 
.................... #elif defined(__OSA_STM8_RAISONANCE__)          // Raisonance for ST STM8 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #include <port\stm8\osa_stm8_raisonance.c> 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else 
.................... //------------------------------------------------------------------------------ 
....................  
....................     #error "OSA error #1: Unknown compiler!" 
....................             /* See manual section "Appendix/Error codes" for more information*/ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_include.c 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  INCLUDE INTERNAL SERVICE FUNCTIONS 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #include "kernel\timers\osa_dtimer.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_dtimer.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for work with dynamic timers 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        10.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                     W O R K   W I T H   D Y N A M I C   T I M E R S                          * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //----------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_DTIMERS 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Variables forDynamic Timers 
.................... //****************************************************************************** 
....................  
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
....................     OS_BANK OST_DTIMER_CB           _OS_DTimers;    // Pointer to list of 
....................  
....................  
....................     #ifndef _OS_DtimersWork_DEFINED 
....................     OST_DTIMER                    * _OS_DtimerWork; // Temp var for work with list of 
....................                                                     // dynamic timers in ISR 
....................     #endif 
....................  
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************* 
....................  * 
....................  *  void _OS_Dtimer_Create (OST_DTIMER *dtimer) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  service OS_Dtimer_Create) 
....................  * 
....................  *                  Add dynamic timer into list of active dynamic timers. This 
....................  *                  timer will be added at first position in list. 
....................  * 
....................  * 
....................  *  parameters:     dtimer - pointer to dynamic timer. 
....................  *                  (for PICC16 can be allocated only in OS_RAM_BANK0 and OS_RAM_BANK1) 
....................  * 
....................  *  on return:      none 
....................  * 
....................  * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c" 
....................  *                  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic18_htpicc.c" 
....................  *                  "osa_pic16_ccs.c" 
....................  *                  "osa_pic18_ccs.c" 
....................  *                  "osa_pic18_mplabc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "osa_stm8_iar.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //----------------------------------------------------------------- 
.................... #if !defined(_OS_Dtimer_Create_DEFINED) 
.................... //----------------------------------------------------------------- 
....................  
.................... //----------------------------------------------------------------- 
.................... #if defined(__OSA18__) 
.................... //----------------------------------------------------------------- 
....................  
....................     void _OS_Dtimer_Create (OST_DTIMER *dtimer) 
....................     { 
....................         _OS_Temp = OS_DI(); 
....................  
....................         _fsr = (OS_FSR_TYPE) dtimer; 
....................         _postinc = *((OS_BANK char*)&_OS_DTimers.Flags); 
....................         // Here: bActive is set, 
....................         //       bTimeout is cleared, 
....................         //       bRun is cleared 
....................         //       bNextEnable is copied 
....................  
....................         _postinc = *((OS_BANK char*)&_OS_DTimers.Next + 0); 
....................         _postinc = *((OS_BANK char*)&_OS_DTimers.Next + 1); 
....................         _postinc = 0; 
....................         #if  OS_DTIMER_SIZE >= 2 
....................         _postinc = 0; 
....................         #endif 
....................         #if  OS_DTIMER_SIZE == 4 
....................         _postinc = 0; 
....................         _postinc = 0; 
....................         #endif 
....................  
....................         _OS_DTimers.Next = (OST_DTIMER*)dtimer; 
....................         _OS_DTimers.Flags.bNextEnable = 1; 
....................  
....................         OS_RI(_OS_Temp); 
....................     } 
....................  
.................... //----------------------------------------------------------------- 
.................... #else   // __OSA18__ 
.................... //----------------------------------------------------------------- 
....................  
....................     void _OS_Dtimer_Create (OST_DTIMER *dtimer) 
....................     { 
....................         _OS_Temp = OS_DI(); 
....................  
....................         dtimer->Next = _OS_DTimers.Next; 
....................         dtimer->Flags = _OS_DTimers.Flags; 
....................         dtimer->Timer = 0; 
....................  
....................         _OS_DTimers.Next = (OST_DTIMER*)dtimer; 
....................         OS_DTIMER_ATOMIC_WRITE_A(_OS_DTimers.Flags.bNextEnable = 1); 
....................  
....................         OS_RI(_OS_Temp); 
....................     } 
....................  
.................... //----------------------------------------------------------------- 
.................... #endif  // __OSA18__ 
.................... //----------------------------------------------------------------- 
....................  
....................  
.................... //----------------------------------------------------------------- 
.................... #endif  // !defined(_OS_Dtimer_Create_DEFINED) 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  void _OS_Dtimer_Delete (OST_DTIMER *dtimer) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  service OS_Dtimer_Delete) 
....................  * 
....................  *                  Delete dynamic timer from list of active timers. It is 
....................  *                  recommended to delete all unused dynamic timers to avoid 
....................  *                  speed down. 
....................  * 
....................  *  parameters:     dtimer - pointer to deleting dynamic timer 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c" 
....................  *                  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic18_htpicc.c" 
....................  *                  "osa_pic18_mplabc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //----------------------------------------------------------------- 
.................... #if !defined(_OS_Dtimer_Delete_DEFINED) 
.................... //----------------------------------------------------------------- 
....................  
.................... //----------------------------------------------------------------- 
.................... #if defined(__OSA18__) 
.................... //----------------------------------------------------------------- 
....................  
....................     void _OS_Dtimer_Delete (OST_DTIMER *dtimer) 
....................     { 
....................         OST_DTIMER *ptcb; 
....................         char flags; 
....................  
....................         _fsr = (OS_FSR_TYPE)dtimer; 
....................         _OS_IndfTimerActive = 0; 
....................         flags = _postinc; 
....................         *((char*)&ptcb + 0) = _postinc; 
....................         *((char*)&ptcb + 1) = _postinc; 
....................         _fsr = (OS_FSR_TYPE)&_OS_DTimers; 
....................     REPEAT: 
....................         if (_OS_PostincTimerNextEnable) 
....................         { 
....................             if (_indf == *((char*)&dtimer + 0)) 
....................             { 
....................                 if (_preinc == *((char*)&dtimer + 1)) 
....................                 { 
....................                     _OS_Temp = OS_DI(); 
....................                     _postdec = *((char*)&ptcb + 1); 
....................                     _postdec = *((char*)&ptcb + 0); 
....................  
....................                     if (!(flags & 0x8)) _OS_IndfTimerNextEnable = 0;   // Check for bNextEnable 
....................                     // If we check in other way (for example: !((OST_DTIMER_FLAGS*)&flags)->bNextEnable) 
....................                     // then compiler can use FSR0 (for some compilers: MCC18 e.g.),  as a result 
....................                     // current pointer to dtimer will be lost 
....................                     OS_RI(_OS_Temp); 
....................                     return; 
....................                 } 
....................                 _fsr--; 
....................             } 
....................             _OS_Temp = _postinc; 
....................             _indf = _postinc; 
....................             *(char*)&_fsr = _OS_Temp; 
....................  
....................             goto REPEAT; 
....................         } 
....................  
....................     } 
....................  
.................... //----------------------------------------------------------------- 
.................... #else   // __OSA18__ 
.................... //----------------------------------------------------------------- 
....................  
....................     void _OS_Dtimer_Delete (OST_DTIMER *dtimer) 
....................     { 
....................         OST_DTIMER *ptcb; 
....................  
....................         // Search current timer in list 
....................  
....................         ptcb = (OST_DTIMER*)&_OS_DTimers; 
....................  
....................         while (ptcb->Flags.bNextEnable) 
....................         { 
....................             if (ptcb->Next == dtimer)               // Current timer found 
....................             { 
....................                 ptcb->Next = dtimer->Next; 
....................  
....................                 if (!dtimer->Flags.bNextEnable) 
....................                     OS_DTIMER_ATOMIC_WRITE_A(ptcb->Flags.bNextEnable = 0;); 
....................  
....................                 OS_DTIMER_ATOMIC_WRITE_A(dtimer->Flags.bActive = 0;); 
....................  
....................                 return; 
....................  
....................             } 
....................             ptcb = (OST_DTIMER*)ptcb->Next; 
....................         } 
....................     } 
.................... //----------------------------------------------------------------- 
.................... #endif  // __OSA18__ 
.................... //----------------------------------------------------------------- 
....................  
.................... //----------------------------------------------------------------- 
.................... #endif  // !defined(_OS_Dtimer_Delete_DEFINED) 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... //----------------------------------------------------------------- 
.................... #endif  //  OS_ENABLE_DTIMERS 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
.................... #include "kernel\timers\osa_qtimer.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_qtimers.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:     
....................  * 
....................  *  History:        10.09.2010 -    File created 
....................  *  
....................  *                  25.10.2010  -   Bug fixed: OS_Qtimer_Break did not deleted timer from the list 
....................  *                              -   Bug fixed: interrupt became disables after calling OS_Qtimer_Run for timer already 
....................  *                                  presented in queue 
....................  * 
....................  *                  30.10.2010  -   Another bug in qtimers fixed 
....................  *  
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... //****************************************************************************** 
.................... //   
.................... //****************************************************************************** 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifndef __OSA_PIC12_HTPICC__ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_QTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
....................     OS_BANK OST_QTIMER_CB           _OS_Qtimers;    // Pointer to list of fast timers 
....................  
....................     #ifndef _OS_QtimersWork_DEFINED 
....................     OST_QTIMER  * OS_BANK         _OS_QtimerWork;   // Temp var for work with list of 
....................                                                     // fast timers in ISR 
....................     #endif 
....................  
.................... #if (OS_BANK_OS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  _OS_Qtimer_List 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth service 
....................  *                  OS) 
....................  * 
....................  *                  This function works with timer's list. It adds, deletes, 
....................  *                  counts timers according to value of ftimer->Flags. 
....................  *  
....................  *  parameters:     OS_QTIMER_TYPE time   - new time for added timer (when 
....................  *                                      _OS_Qtimers.Flags.bListFunction = 
....................  *                                      FUNCTION_ADD) 
....................  *                  OST_QTIMER *ftimer - pointer to timer to work on. 
....................  * 
....................  *  on return:      OS_QTIMER_TYPE: 
....................  *                  1.  When bListGetTime == "1", this function returns remaining 
....................                         time for current timer (flag bListFunction does not matter) 
....................                     2.  When bListFunction == OS_QTIMER_LIST_FUNCTION_ADD, this 
....................                         function adds new timer into list (before adding it checks 
....................                         for timer is already in list; if so, then timer deleted first 
....................                         and function executes twice (see "goto RESTART")) 
....................                     3.  When bListFunction == OS_QTIMER_LIST_FUNCTION_DELETE, this 
....................                         function deletes current timer 
....................   
....................  *  Overloaded in:  osa_pic16_htpicc.c 
....................  *  
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //****************************************************************************** 
.................... #if !defined(_OS_Qtimer_List_DEFINED) 
.................... //****************************************************************************** 
....................  
.................... OS_QTIMER_TYPE _OS_Qtimer_List (OS_QTIMER_TYPE time, OST_QTIMER *ftimer) 
.................... { 
....................     OST_QTIMER          *ftcb; 
....................     OST_QTIMER_FLAGS    flags; 
....................     OS_QTIMER_TYPE      temp, remain; 
....................     OST_UINT            itemp; 
....................     #ifdef __OSA_PIC18_MIKROC__ 
....................     OST_QTIMER          *ftcb_temp; // Due to compiler bug (id=4711) can't copy pointed value 
....................                                     // (*Note:4711*) (version mikroC PRO 3.20) 
....................     #endif 
....................  
.................... RESTART: 
....................     remain = 0;                                 // Count remaining time 
....................  
....................     #ifdef __OSA_STM8_IAR__ 
....................     *(unsigned char*)&flags = *(unsigned char*)ftimer; 
....................     #else 
....................     flags = ftimer->Flags; 
....................     #endif 
....................  
.................... // *101030*    if (time == 0 && _OS_Qtimers.Flags.bListFunction == OS_QTIMER_LIST_FUNCTION_ADD)    /*101025*/ 
.................... // *101030*    {                                    
.................... // *101030*        ftimer->Flags.bTimeout = 1;      
.................... // *101030*        ftimer->Flags.bActive  = 0;      
.................... // *101030*        goto EXIT; 
.................... // *101030*    }                                    
....................  
....................  
....................  
....................     if (_OS_Qtimers.Flags.bListGetTime)  
....................     {     
....................         //-------------------------------------------- 
....................         // Clear ADD function if GET function present 
....................         //-------------------------------------------- 
....................         _OS_Qtimers.Flags.bListFunction = !OS_QTIMER_LIST_FUNCTION_ADD; 
....................     } 
....................     else  
....................     { 
....................         //--------------------------------------- 
....................         // Skip deleting if timer is not in list 
....................         //--------------------------------------- 
....................         if (_OS_Qtimers.Flags.bListFunction == OS_QTIMER_LIST_FUNCTION_DELETE && !flags.bActive) goto EXIT; 
....................     } 
....................  
....................     _OS_Qtimers.Flags.bAddAfterDelete = 0; 
....................  
....................     if (_OS_Qtimers.Flags.bListFunction == OS_QTIMER_LIST_FUNCTION_ADD) 
....................     { 
....................         if (flags.bActive)              // If timer is already in list, it should be deleted first 
....................         { 
....................             OS_QTIMER_ATOMIC_WRITE_A(_OS_Qtimers.Flags.bAddAfterDelete = 1;);  // Set flag to execute ADD after deleting 
....................             _OS_Qtimers.Flags.bListFunction = OS_QTIMER_LIST_FUNCTION_DELETE; 
....................         } 
....................         else 
....................         { 
....................             //--------------------------------------- 
....................             // Prepare timer for adding 
....................             //--------------------------------------- 
....................              
....................             if (time == 0)                  // *101030* 
....................             {                               // *101030* 
....................                 ftimer->Flags.bTimeout = 1; // *101030* 
....................                 ftimer->Flags.bActive  = 0; // *101030* 
....................                 goto EXIT;                  // *101030* 
....................             }                               // *101030* 
....................  
....................             // *101030* OS_QTIMER_ATOMIC_WRITE_A(ftimer->Flags.bNextEnable = 0;); 
....................             ftimer->Flags.bNextEnable = 0;  // *101030* 
....................             time ^= (OS_QTIMER_TYPE)-1; // time = -time 
....................             time++; 
....................         } 
....................     } 
....................  
....................     #if defined(__OSA_PIC24_MPLABC__) 
....................     ftcb = (OST_QTIMER*)(void*)&_OS_Qtimers; 
....................     #else 
....................     ftcb = (OST_QTIMER*)&_OS_Qtimers;           // Start search from header 
....................     #endif 
....................  
....................     itemp = OS_DI(); 
....................  
....................     if (_OS_Qtimers.Flags.bNextEnable) 
....................     {     
....................         do 
....................         { 
....................             #ifdef __OSA_PIC18_MIKROC__         // (*Note:4711*) 
....................             ftcb_temp = ftcb->Next;             // (*Note:4711*) 
....................             #endif                              // (*Note:4711*) 
....................  
....................             if (_OS_Qtimers.Flags.bListFunction == OS_QTIMER_LIST_FUNCTION_DELETE && !_OS_Qtimers.Flags.bListGetTime) 
....................             { 
....................                 if (ftcb->Next == ftimer)               // ********* Deleting *********** 
....................                 { 
....................                     ftcb->Next = ftimer->Next; 
....................                     OS_QTIMER_ATOMIC_WRITE_A( 
....................                         ftcb->Flags.bNextEnable = flags.bNextEnable; 
....................                         ftimer->Flags.bActive   = 0; 
....................                     ); 
....................  
....................                     if (flags.bNextEnable) ftcb->Next->Timer += ftimer->Timer; 
....................  
....................                     if (_OS_Qtimers.Flags.bAddAfterDelete) 
....................                     { 
....................                         //----------------------------------------------------------- 
....................                         // It was deleting before adding.  
....................                         // Set ADD flag and restart searching 
....................                         //----------------------------------------------------------- 
....................  
....................                         _OS_Qtimers.Flags.bListFunction = OS_QTIMER_LIST_FUNCTION_ADD; 
....................                         OS_RI(itemp);   /*101025*/ 
....................                         goto RESTART; 
....................                     } 
....................                     goto EXIT_RI; 
....................                 } 
....................             } 
....................             else                                        // ********* Adding or Reading *********** 
....................             { 
....................                 #ifdef __OSA_PIC18_MIKROC__     // (*Note:4711*) 
....................                 temp = ftcb_temp->Timer;        // (*Note:4711*) 
....................                 #else                           // (*Note:4711*) 
....................                 temp = ftcb->Next->Timer;       // Copy time value into temp variable 
....................                 #endif                          // (*Note:4711*) 
....................  
....................                 if (_OS_Qtimers.Flags.bListGetTime) 
....................                 { 
....................                     if (ftcb == ftimer) goto EXIT_RI; 
....................                     remain -= temp; 
....................                 }  
....................                 else 
....................                 { 
....................                     if (temp && temp <= time) 
....................                     { 
....................                         OS_QTIMER_ATOMIC_WRITE_A(ftimer->Flags.bNextEnable = 1); 
....................                         break; 
....................                     }  
....................                 } 
....................                 time -= temp; 
....................             } 
....................  
....................             OS_RI(itemp); 
....................             ftcb = ftcb->Next; 
....................             OS_DI(); 
....................  
....................         } while (ftcb->Flags.bNextEnable); 
....................     } 
....................  
....................     //************************************** 
....................     //               Adding 
....................     //************************************** 
....................     if (_OS_Qtimers.Flags.bListFunction == OS_QTIMER_LIST_FUNCTION_ADD) 
....................     { 
....................         OS_QTIMER_ATOMIC_WRITE_A( 
....................             ftimer->Flags.bTimeout = 0; 
....................             ftimer->Flags.bActive  = 1; 
....................         ); 
....................         ftimer->Next = ftcb->Next; 
....................         ftimer->Timer = time; 
....................      
....................         if (ftcb->Flags.bTimeout) 
....................         { 
....................             #if defined(__OSA_PIC24_MPLABC__) 
....................             ftcb = (OST_QTIMER*)(void*)&_OS_Qtimers;    //  
....................             #else 
....................             ftcb = (OST_QTIMER*)&_OS_Qtimers;           // Start search from header 
....................             #endif 
....................         } 
....................         ftcb->Next = ftimer; 
....................         OS_QTIMER_ATOMIC_WRITE_A(ftcb->Flags.bNextEnable = 1); 
....................      
....................         if (ftimer->Flags.bNextEnable) 
....................         { 
....................             ftimer = ftimer->Next; 
....................             ftimer->Timer -= time; 
....................         } 
....................     } 
....................  
.................... EXIT_RI: 
....................     OS_RI(itemp); 
.................... EXIT: 
....................     _OS_Qtimers.Flags.bListFunction = OS_QTIMER_LIST_FUNCTION_ADD; 
....................     _OS_Qtimers.Flags.bListGetTime  = 0; 
....................     return remain; 
.................... } 
....................  
.................... //****************************************************************************** 
.................... #endif      // _OS_Qtimer_List_DEFINED 
.................... //****************************************************************************** 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_ENABLE_QTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      //  __OSA_PIC12_HTPICC__ 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... #include "kernel\timers\osa_stimer.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for work with static timers 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        02.10.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                     W O R K   W I T H   S T A T I C   T I M E R S                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
.................... //----------------------------------------------------------------- 
.................... #if     OS_STIMERS > 0 
....................  
....................  
.................... #if (OS_BANK_STIMERS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
....................     volatile OS_STIMERS_BANK     OS_STIMER_TYPE     _OS_Stimers[OS_STIMERS]      ;  
....................      
....................     #ifdef OS_STIMERS_ENABLE_ALLOCATION     
....................     OS_STIMERS_BANK     OST_WORD   _OS_StimersFree[(OS_STIMERS + _OST_INT_SIZE-1) / _OST_INT_SIZE]; 
....................     #endif 
....................  
.................... #if (OS_BANK_STIMERS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef  OS_STIMERS_ENABLE_ALLOCATION 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  _OS_Stimer_GetFree 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth service OS) 
....................  *                  Searches free static timer and returns it's ID 
....................  * 
....................  * 
....................  *  parameters:     OST_UINT bCreate - =0 - do not created timer, just check for 
....................  *                                          aviability 
....................  *                                     =1 - create timer and mark it asm used 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  Overloaded in:  osa_pic18_htpicc.c 
....................  *                  osa_pic16_htpicc.c 
....................  *                  osa_pic12_htpicc.c 
....................  *                  osa_pic18_mplabc.c 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //----------------------------------------------------------------- 
.................... #ifndef _OS_Stimer_GetFree_DEFINED 
.................... //----------------------------------------------------------------- 
....................  
....................     OST_UINT8   _OS_Stimer_GetFree (OST_UINT bCreate) 
....................     { 
....................         OST_UINT n, i; 
....................         OST_UINT temp, mask; 
....................  
....................         _OS_Flags.bError = 0; 
....................  
....................         for (n = 0; n <= OS_STIMERS >> 3; n++) 
....................         { 
....................             temp = _OS_StimersFree[n]; 
....................             if (temp)           // There is a free timer 
....................             { 
....................                 if (!(bCreate & 1)) return 0; 
....................  
....................                 i = n << _OST_INT_SHIFT; 
....................                 mask = 1; 
....................                 while (!(temp & mask)) 
....................                 { 
....................                     mask <<= 1; 
....................                     i++; 
....................                 } 
....................                 _OS_StimersFree[n] &= ~mask; 
....................                 return i; 
....................             } 
....................         } 
....................  
....................         _OS_Flags.bError = 1; 
....................         return 0xFF; 
....................     } 
....................  
....................  
....................  
....................  
....................     void    _OS_Stimer_Free (OST_UINT8 ID) 
....................     { 
....................         _OS_StimersFree[ID >> _OST_INT_SHIFT] |= (1 << (ID & _OST_INT_MASK)); 
....................     } 
....................     /**/ 
....................  
.................... //============================================================================== 
.................... #endif  // Compiler type 
.................... //============================================================================== 
....................  
.................... //----------------------------------------------------------------- 
.................... #endif  //  OS_STIMERS_ENABLE_ALLOCATION 
.................... #endif  //  OS_ENABLE_STIMERS 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
....................  
.................... #include "kernel\timers\osa_ttimer.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_ttimer.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for Task Timers 
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void _OS_InitDelay (OS_TTIMER_TYPE Delay) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel) 
....................  * 
....................  *                  Init task timer delay.Set timer variable in task descriptor, 
....................  *                  sets bit bDelay and clears bit bCanContinue. 
....................  * 
....................  *                  _OS_CurTask must point to descriptor. 
....................  * 
....................  * 
....................  *  parameters:     Delay   - time of delay in system ticks 
....................  * 
....................  *  on return:      none 
....................  * 
....................  * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c" 
....................  *                  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic16_ccs.c" 
....................  *                  "osa_pic16_mikroc.c" 
....................  *                  "osa_pic18_htpicc.c" 
....................  *                  "osa_pic18_mplabc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "osa_stm8_cosmic.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_InitDelay_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_InitDelay (OS_TTIMER_TYPE Delay) 
....................     { 
....................  
....................         _OS_TASK_ATOMIC_WRITE_A( 
....................             _OS_bTaskCanContinue = 0; 
....................             _OS_CurTask->State.bDelay = 0; 
....................         ); 
....................  
....................         if (Delay) 
....................         { 
....................             Delay ^= (OS_TTIMER_TYPE)-1; 
....................             Delay ++; 
....................             _OS_CurTask->Timer = Delay; 
....................             _OS_TASK_ATOMIC_WRITE_A( 
....................                 _OS_CurTask->State.bReady = 1; 
....................                 _OS_CurTask->State.bDelay = 1; 
....................             ); 
....................             #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................                 _OS_bTaskDelay = 1; 
....................                 _OS_bTaskReady = 1; 
....................             #endif 
....................         } 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_InitDelay_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif      // OS_ENABLE_TTIMERS 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #include "kernel\events\osa_squeue.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  *                  http://picosa.narod.ru 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_squeue.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for queues of simple messages 
....................  * 
....................  *  History:        14.03.2010 -    File created 
....................  *  
....................  *                  20.04.2010 -    2. Type of variable temp in _OS_XXX_Send changed OST_UINT -> __osa_int16 
....................  *  
....................  *                  31.05.2010 -    2. Buf fixed for MCC18: queues with buffer size greater than 128 elements 
....................  *                                     worked incorrectly (see _OS_Queue_Send) 
....................  *  
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *     M E S S A G E   Q U E U E S                                                              * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_SQUEUE) && !defined(OS_QUEUE_SQUEUE_IDENTICAL) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  void _OS_Squeue_Send (OST_SQUEUE *pSQueue, OST_SMSG SMsg)                   * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service _OS_SendSQueue)                                     * 
....................  *                                                                              * 
....................  *                  Add message into queue of simple messages. Delete first     * 
....................  *                  message if there is no free room to add new message.        * 
....................  *                  Service OS_SQueue_Send before adding new message checks for * 
....................  *                  free room. Thus messages will not deleted accidentally.     * 
....................  *                                                                              * 
....................  *                                                                              * 
....................  *  parameters:     pSQueue      - pointer to queue descriptor                  * 
....................  *                  SMsg        - simple message to be added                    * 
....................  *                                                                              * 
....................  *  on return:      OS_IsEventError() return 1, if first message was pushed out * 
....................  *                                                                              * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c"                                         * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Squeue_Send_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Squeue_Send (OST_SQUEUE * pSQueue, OST_SMSG SMsg) 
....................     { 
....................         OST_QUEUE_CONTROL   q;          // Temp variable to increase speed 
....................         OST_UINT16 temp;               
....................  
....................         q = pSQueue->Q; 
....................         _OS_Flags.bEventError = 0;                   // First we clear error flag 
....................  
....................  
....................         //------------------------------------------------------ 
....................         // If there is no free room in queue, then replace 
....................         // first message in queue by new SMsg 
....................  
....................         if (q.cSize == q.cFilled) 
....................         { 
....................             pSQueue->pSMsg[q.cBegin] = SMsg; 
....................             q.cBegin++;                             // Update pointer 
....................             if (q.cBegin == q.cSize) q.cBegin = 0; 
....................  
....................             _OS_Flags.bEventError = 1;               // Set error flag 
....................  
....................             goto EXIT;                              // Skip adding 
....................         } 
....................  
....................         //------------------------------------------------------ 
....................         // There is a free room in queue. 
....................         // Add new message at end of queue. 
....................  
....................         temp = (OST_UINT16)q.cBegin + q.cFilled;   
....................         if (temp >= q.cSize) temp -= q.cSize; 
....................         pSQueue->pSMsg[temp] = SMsg; 
....................         q.cFilled++;                                // Update fillness 
....................  
....................     EXIT: 
....................         pSQueue->Q = q; 
....................  
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Squeue_Send_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  void _OS_Squeue_Send_I (OST_SQUEUE *pSQueue, OST_SMSG SMsg)                 * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    Copy of _OS_SQueue_Send to be called from interrupt         * 
....................  *                                                                              * 
....................  *  parameters:     pSQueue      - pointer to queue descriptor                  * 
....................  *                  SMsg        - simple message to be added                    * 
....................  *                                                                              * 
....................  *  on return:      OS_IsEventError() return 1, if first message was pushed out * 
....................  *                                                                              * 
....................  *  Overloaded in:  -                                                           * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Squeue_Send_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Squeue_Send_I (OST_SQUEUE *pSQueue, OST_SMSG SMsg) 
....................     { 
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT16 temp;               
....................  
....................         q = pSQueue->Q; 
....................         _OS_Flags.bEventError = 0; 
....................  
....................         //------------------------------------------------------ 
....................         // If there is no free room in queue, then replace 
....................         // first message in queue by new SMsg 
....................  
....................         if (q.cSize == q.cFilled) 
....................         { 
....................             pSQueue->pSMsg[q.cBegin] = SMsg; 
....................             q.cBegin++; 
....................             if (q.cBegin == q.cSize) q.cBegin = 0; 
....................  
....................             _OS_Flags.bEventError = 1; 
....................             goto EXIT; 
....................         } 
....................  
....................         //------------------------------------------------------ 
....................         // There is a free room in queue. 
....................         // Add new message at end of queue. 
....................  
....................         temp = (OST_UINT16)q.cBegin + q.cFilled;   
....................         if (temp >= q.cSize) temp -= q.cSize; 
....................         pSQueue->pSMsg[temp] = SMsg; 
....................         q.cFilled++; 
....................  
....................     EXIT: 
....................         pSQueue->Q = q; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // (OS_ENABLE_INT_QUEUE) && !defined(_OS_Squeue_Send_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  OST_SMSG _OS_Squeue_Get (OST_SQUEUE *pSQueue)                               * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service OS_AcceptSQueue)                                    * 
....................  *                                                                              * 
....................  *                  Get first simple message from queue. Before calling this    * 
....................  *                  function be sure that queue is not empty (OS_AcceptSQueue   * 
....................  *                  does it automatically). After execution this function first * 
....................  *                  message will be deleted from queue.                         * 
....................  *                                                                              * 
....................  *  parameters:     pSQueue      - pointer to queue descriptor                  * 
....................  *                                                                              * 
....................  *  on return:      first message from queue                                    * 
....................  *                                                                              * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c"                                         * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Squeue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     OST_SMSG _OS_Squeue_Get (OST_SQUEUE *pSQueue) 
....................     { 
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT       temp; 
....................         OST_SMSG            smsg_temp; 
....................  
....................         q = pSQueue->Q; 
....................         temp = q.cBegin; 
....................         q.cBegin++; 
....................  
....................         if (q.cBegin >= q.cSize)    q.cBegin = 0; 
....................  
....................         q.cFilled--; 
....................         pSQueue->Q = q; 
....................  
....................         smsg_temp = pSQueue->pSMsg[temp]; 
....................  
....................         return  smsg_temp; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Queue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  OST_SMSG _OS_Squeue_Get_I (OST_SQUEUE *pSQueue)                             * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service OS_Squeue_Accept_I)                                 * 
....................  *                                                                              * 
....................  *                  Get first simple message from queue. Before calling this    * 
....................  *                  function be sure that queue is not empty (OS_AcceptSQueue   * 
....................  *                  does it automatically). After execution this function first * 
....................  *                  message will be deleted from queue.                         * 
....................  *                                                                              * 
....................  *  parameters:     pSQueue      - pointer to queue descriptor                  * 
....................  *                                                                              * 
....................  *  on return:      first message from queue                                    * 
....................  *                                                                              * 
....................  *  Overloaded in:  -                                                           * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Squeue_Get_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     OST_SMSG _OS_Squeue_Get_I (OST_SQUEUE *pSQueue) 
....................     { 
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT temp; 
....................  
....................         q = pSQueue->Q; 
....................         temp = q.cBegin; 
....................         q.cBegin++; 
....................  
....................         if (q.cBegin >= q.cSize)    q.cBegin = 0; 
....................  
....................         q.cFilled--; 
....................         pSQueue->Q = q; 
....................  
....................         return  pSQueue->pSMsg[temp]; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Queue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // defined(OS_ENABLE_SQUEUE) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... #include "kernel\events\osa_queue.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_queue.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for queues 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        15.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_QUEUE) 
.................... //------------------------------------------------------------------------------ 
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  void _OS_Queue_Send (OST_QUEUE *pQueue, OST_MSG Msg)                        * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service _OS_Queue_Send)                                     * 
....................  *                                                                              * 
....................  *                  Adds message into queue of pointers to messages. Deletes    * 
....................  *                  first message if there is no free room to add new message.  * 
....................  *                  Service OS_Queue_Send before adding new message checks for  * 
....................  *                  free room. Thus messages will not deleted accidentally.     * 
....................  *                                                                              * 
....................  *                                                                              * 
....................  *  parameters:     pQueue      - pointer to queue descriptor                   * 
....................  *                  Msg        - pointer to  message to be added                * 
....................  *                                                                              * 
....................  *  on return:      OS_IsEventError() return 1, if first message was pushed out * 
....................  *                                                                              * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c"                                         * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Queue_Send_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Queue_Send (OST_QUEUE *pQueue, OST_MSG Msg) 
....................     { 
....................  
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT16 temp;               
....................  
....................         q = pQueue->Q; 
....................         _OS_Flags.bEventError = 0; 
....................  
....................         //------------------------------------------------------ 
....................         // If there is no free room in queue, then replace 
....................         // first message in queue by new SMsg 
....................  
....................         if (q.cSize == q.cFilled) 
....................         { 
....................             pQueue->pMsg[q.cBegin] = Msg; 
....................             q.cBegin++; 
....................             if (q.cBegin == q.cSize) q.cBegin = 0; 
....................  
....................             _OS_Flags.bEventError = 1; 
....................             goto EXIT; 
....................         } 
....................  
....................  
....................         //------------------------------------------------------ 
....................         // There is a free room in queue. 
....................         // Add new message at end of queue. 
....................  
....................         temp = (OST_UINT16)q.cBegin + q.cFilled;   
....................         if (temp >= q.cSize) temp -= q.cSize; 
....................         pQueue->pMsg[temp] = Msg; 
....................         q.cFilled++; 
....................  
....................     EXIT: 
....................  
....................         pQueue->Q = q; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Queue_Send_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  void _OS_Queue_Send_I (OST_QUEUE *pQueue, OST_MSG Msg)                      * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    Copy of _OS_Queue_Send to be called from interrupt          * 
....................  *                                                                              * 
....................  *  parameters:     pQueue      - pointer to queue descriptor                   * 
....................  *                  Msg        - pointer to message to be added                 * 
....................  *                                                                              * 
....................  *  on return:      OS_IsEventError() return 1, if first message was pushed out * 
....................  *                                                                              * 
....................  *  Overloaded in:  -                                                           * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Queue_Send_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Queue_Send_I (OST_QUEUE *pQueue, OST_MSG Msg) 
....................     { 
....................  
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT16 temp;               
....................  
....................         q = pQueue->Q; 
....................         _OS_Flags.bEventError = 0; 
....................  
....................         //------------------------------------------------------ 
....................         // If there is no free room in queue, then replace 
....................         // first message in queue by new SMsg 
....................  
....................         if (q.cSize == q.cFilled) 
....................         { 
....................             pQueue->pMsg[q.cBegin] = Msg; 
....................             q.cBegin++; 
....................             if (q.cBegin == q.cSize) q.cBegin = 0; 
....................  
....................             _OS_Flags.bEventError = 1; 
....................             goto EXIT; 
....................         } 
....................  
....................         //------------------------------------------------------ 
....................         // There is a free room in queue. 
....................         // Add new message at end of queue. 
....................  
....................         temp = (OST_UINT16)q.cBegin + q.cFilled;   
....................         if (temp >= q.cSize) temp -= q.cSize; 
....................         pQueue->pMsg[temp] = Msg; 
....................         q.cFilled++; 
....................  
....................     EXIT: 
....................  
....................         pQueue->Q = q; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // (OS_ENABLE_INT_QUEUE) && !defined(_OS_Queue_Send_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  OST_MSG _OS_Queue_Get (OST_QUEUE *pQueue)                                    * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service OS_AcceptQueue)                                     * 
....................  *                                                                              * 
....................  *                  Get first pointer to message from queue. Before calling this* 
....................  *                  function be sure that queue is not empty (OS_AcceptQueue does* 
....................  *                  it automatically). After execution this function first      * 
....................  *                  message will be deleted from queue.                         * 
....................  *                                                                              * 
....................  *  parameters:     pQueue      - pointer to queue descriptor                   * 
....................  *                                                                              * 
....................  *  on return:      first message from queue                                    * 
....................  *                                                                              * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c"                                         * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Queue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     OST_MSG _OS_Queue_Get (OST_QUEUE *pQueue) 
....................     { 
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT          temp; 
....................         OST_MSG             msg_temp; 
....................  
....................  
....................         q = pQueue->Q; 
....................         temp = q.cBegin; 
....................         q.cBegin++; 
....................  
....................         if (q.cBegin >= q.cSize)    q.cBegin = 0; 
....................  
....................         q.cFilled--; 
....................         pQueue->Q = q; 
....................  
....................         msg_temp = pQueue->pMsg[temp]; 
....................  
....................         return  msg_temp; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Queue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  OST_MSG _OS_Queue_Get (OST_QUEUE *pQueue)                                    * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  description:    (Internal function called by system kernel througth         * 
....................  *                  service OS_Queue_Accept_I)                                   * 
....................  *                                                                              * 
....................  *                  Get first pointer to message from queue. Before calling this* 
....................  *                  function be sure that queue is not empty (OS_AcceptQueue does* 
....................  *                  it automatically). After execution this function first      * 
....................  *                  message will be deleted from queue.                         * 
....................  *                                                                              * 
....................  *  parameters:     pQueue      - pointer to queue descriptor                   * 
....................  *                                                                              * 
....................  *  on return:      first message from queue                                    * 
....................  *                                                                              * 
....................  *  Overloaded in:  -                                                            * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Queue_Get_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     OST_MSG _OS_Queue_Get_I (OST_QUEUE *pQueue) 
....................     { 
....................         OST_QUEUE_CONTROL   q; 
....................         OST_UINT temp; 
....................  
....................         q = pQueue->Q; 
....................         temp = q.cBegin; 
....................         q.cBegin++; 
....................  
....................         if (q.cBegin >= q.cSize)    q.cBegin = 0; 
....................  
....................         q.cFilled--; 
....................         pQueue->Q = q; 
....................  
....................         return  pQueue->pMsg[temp]; 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // defined(OS_ENABLE_INT_QUEUE) && !defined(_OS_Queue_Get_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_QUEUE 
.................... //------------------------------------------------------------------------------ 
.................... //****************************************************************************** 
.................... //  END OF FILE osa_queue.c 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_csem.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC (Microchip) and 8-bit AVR (Atmel) 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  *                  http://picosa.narod.ru 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_csem.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions for csems 
....................  * 
....................  *  History:        14.03.2010 -    File created 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *                            C O U N T I N G    S E M A P H O R E S                            * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_CSEM 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  *                                                                              * 
....................  *  void _OS_Csem_Signal (OST_CSEM *pCSem)                                      * 
....................  *                                                                              * 
....................  *------------------------------------------------------------------------------* 
....................  *                                                                              * 
....................  *  Increase counting semaphore. Set EventError if csem is FF...                * 
....................  *                                                                              * 
....................  *                                                                              * 
....................  *  parameters:     pCSem - pointer to counting semaphore                       * 
....................  *                                                                              * 
....................  *  on return:      OS_IsEventError()                                           * 
....................  *                                                                              * 
....................  *  Overloaded in:  "osa_pic16_htpicc.c"                                         * 
....................  *                  "osa_pic18_htpicc.c"                                         * 
....................  *                                                                              * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Csem_Signal_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Csem_Signal (OST_CSEM *pCSem) 
....................     { 
....................         _OS_Flags.bEventError = 0; 
....................  
....................         (*pCSem)++; 
....................         if (!*pCSem) 
....................         { 
....................             (*pCSem) = (OST_CSEM) -1; 
....................             _OS_Flags.bEventError = 1; 
....................         } 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Csem_Signal_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if defined(OS_ENABLE_INT_CSEM) && !defined(_OS_Csem_Signal_I_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Csem_Signal_I (OST_CSEM *pCSem)    
....................     { 
....................         _OS_Flags.bEventError = 0; 
....................  
....................         (*pCSem)++; 
....................         if (!*pCSem) 
....................         { 
....................             (*pCSem) = (OST_CSEM) -1; 
....................             _OS_Flags.bEventError = 1; 
....................         } 
....................     } 
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_ENABLE_INT_CSEM && !_OS_Csem_Signal_I_DEFINED 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // OS_CSEM_ENABLE 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_csem.c 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\events\osa_bsem.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_bsem.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Definition the array for binary semaphores 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
.................... #if OS_BSEMS > 0 
....................  
....................     #if (OS_BANK_BSEM == 0) && defined(__OSA_PIC18_MPLABC__) 
....................     #pragma udata access os_bsems 
....................     #endif 
....................  
....................     volatile OS_BSEM_BANK    OST_WORD   _OS_Bsems[(OS_BSEMS + _OST_INT_SIZE-1) / _OST_INT_SIZE] ; 
....................  
....................     #if (OS_BANK_BSEM == 0) && defined(__OSA_PIC18_MPLABC__) 
....................     #pragma udata 
....................     #endif 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_bsem.c 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #include "kernel\system\osa_system.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_system.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    System functions 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                                                                              * 
....................  *                         F U N C T I O N   D E F I N I T I O N S                              * 
....................  *                                                                                              * 
....................  *                                                                                              * 
....................  ************************************************************************************************/ 
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void OS_Init (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel) 
....................  * 
....................  *                  Initialize all system variables: 
....................  *                  - Clear all binary semaphores 
....................  *                  - Free all task descriptors 
....................  *                  - Clear all timeouts for old style static timers 
....................  *                  - Set _OS_LastTask and _OS_CurTask variables at last task 
....................  *                    descriptor 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      _OSCurTask points to last task descriptor. 
....................  * 
....................  *  Overloaded in:  - 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... void OS_Init (void) 
.................... { 
....................     #ifdef __OSA_PIC24_MPLABC__ 
....................     _OS_Flags = (OST_SYSTEM_FLAGS){0}; 
....................     #else 
....................     *(OS_RAM_NEAR OST_WORD*)&_OS_Flags = 0; 
*
2954:  CLRF   xCB
2956:  MOVLW  27
2958:  MOVWF  FE9
295A:  MOVFF  CB,FEA
295E:  CLRF   FEF
....................     #endif 
....................  
....................     _OS_INIT_PROC_SPEC();     /* Specific controller type's init operations   */ 
2960:  CLRF   28
2962:  BTFSS  28.0
2964:  BRA    2974
2966:  RCALL  2894
2968:  BRA    28C6
296A:  RCALL  290A
296C:  BRA    2910
296E:  CLRF   xCB
2970:  RCALL  2918
2972:  RCALL  293C
....................  
....................  
....................  
....................     #if OS_PRIORITY_LEVEL == OS_PRIORITY_NORMAL 
....................  
....................         _OS_LastTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS - 1); 
....................  
....................     #endif 
....................  
....................  
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Zero all old style static timers    * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     #if OS_TIMERS > 11*8 || ((OS_TIMERS > 0) && defined(__OSA_PIC24_MPLABC__)) 
....................  
....................         _OS_Temp = sizeof(OS_Timeouts) / sizeof(OST_WORD); 
....................         do 
....................         { 
....................             OS_Timeouts[_OS_Temp-1] = 0; 
....................         } while (--_OS_Temp); 
....................  
....................     #else 
....................         #if OS_TIMERS > 0 
....................             OS_Timeouts[0] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 1*8 
....................             OS_Timeouts[1] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 2*8 
....................             OS_Timeouts[2] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 3*8 
....................             OS_Timeouts[3] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 4*8 
....................             OS_Timeouts[4] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 5*8 
....................             OS_Timeouts[5] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 6*8 
....................             OS_Timeouts[6] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 7*8 
....................             OS_Timeouts[7] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 8*8 
....................             OS_Timeouts[8] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 9*8 
....................             OS_Timeouts[9] = 0; 
....................         #endif 
....................  
....................         #if OS_TIMERS > 10*8 
....................             OS_Timeouts[10] = 0; 
....................         #endif 
....................  
....................     #endif 
....................  
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Clear list of dynamic timers        * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     #if defined(OS_ENABLE_DTIMERS) 
....................         *((OS_BANK OST_WORD*)&_OS_DTimers.Flags) = 0; 
....................         _OS_DTimers.Flags.bNextEnable = 0; 
....................         _OS_DTimers.Flags.bActive = 1; 
....................     #endif 
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Clear list of fast timers           * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................  
....................     #if defined(OS_ENABLE_QTIMERS) 
....................         *((OS_BANK OST_WORD*)&_OS_Qtimers.Flags) = 0; 
....................         // Default: 
....................         //  bNextEnable     = 0 
....................         //  bListFunction   = 0 (FUNCTION_ADD) 
....................         //  bListGetTime    = 0 
....................         _OS_Qtimers.Flags.bActive = 1; 
....................     #endif 
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Make all static timers free         * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     #if defined (OS_ENABLE_STIMERS) 
....................     #if defined (OS_STIMERS_ENABLE_ALLOCATION) 
....................  
....................     #if OS_STIMERS > 11*8 || ((OS_STIMERS > 0) && defined(__OSA_PIC24_MPLABC__)) 
....................  
....................         _OS_Temp = sizeof(_OS_StimersFree) / sizeof(OST_WORD); 
....................         do 
....................         { 
....................             _OS_StimersFree[_OS_Temp-1] = (OST_WORD)-1; 
....................         } while (--_OS_Temp); 
....................  
....................     #else 
....................         #if OS_STIMERS > 1*8 
....................             _OS_StimersFree[0] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 2*8 
....................             _OS_StimersFree[1] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 3*8 
....................             _OS_StimersFree[2] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 4*8 
....................             _OS_StimersFree[3] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 5*8 
....................             _OS_StimersFree[4] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 6*8 
....................             _OS_StimersFree[5] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 7*8 
....................             _OS_StimersFree[6] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 8*8 
....................             _OS_StimersFree[7] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 9*8 
....................             _OS_StimersFree[8] = (OST_WORD)-1; 
....................         #endif 
....................  
....................         #if OS_STIMERS > 10*8 
....................             _OS_StimersFree[ 9] = (OST_WORD)-1; 
....................         #endif 
....................  
....................     #endif 
....................  
....................         #if (OS_STIMERS & _OST_INT_MASK) != 0 
....................         _OS_StimersFree[OS_STIMERS >> _OST_INT_SHIFT] = (1 << (OS_STIMERS & _OST_INT_MASK)) - 1; 
....................         #endif 
....................  
....................     #endif 
....................     #endif 
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Zero all binary semaphores          * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     #if OS_BSEMS > 11*8 || ((OS_BSEMS > 0) && defined(__OSA_PIC24_MPLABC__)) 
....................  
....................         _OS_Temp = sizeof(_OS_Bsems) / sizeof(OST_WORD); 
....................         do 
....................         { 
....................             _OS_Bsems[_OS_Temp-1] = 0; 
....................         } while (--_OS_Temp); 
....................  
....................     #else 
....................         #if OS_BSEMS > 0 
....................             _OS_Bsems[0] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 1*8 
....................             _OS_Bsems[1] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 2*8 
....................             _OS_Bsems[2] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 3*8 
....................             _OS_Bsems[3] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 4*8 
....................             _OS_Bsems[4] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 5*8 
....................             _OS_Bsems[5] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 6*8 
....................             _OS_Bsems[6] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 7*8 
....................             _OS_Bsems[7] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 8*8 
....................             _OS_Bsems[8] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 9*8 
....................             _OS_Bsems[9] = 0; 
....................         #endif 
....................  
....................         #if OS_BSEMS > 10*8 
....................             _OS_Bsems[10] = 0; 
....................         #endif 
....................     #endif 
....................  
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Zero all task descriptors           * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     #if OS_TASKS > 10 
....................         _OS_SET_IRP_CUR_TASK(); 
....................         _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks; 
....................         _OS_Temp = OS_TASKS; 
....................         do { 
....................             _OS_CurTask->State.bEnable = 0; 
....................             _OS_CurTask ++; 
....................         } while (--_OS_Temp); 
....................         _OS_CLR_IRP(); 
....................     #else 
....................  
....................         #if OS_PRIORITY_LEVEL == OS_PRIORITY_DISABLED 
....................             _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks + (OS_TASKS-1); 
2974:  CLRF   xCB
2976:  MOVLW  2D
2978:  MOVWF  xCA
297A:  MOVLW  1E
297C:  ADDWF  xCA,W
297E:  MOVWF  01
2980:  MOVLW  00
2982:  ADDWFC xCB,W
2984:  MOVFF  01,2B
2988:  MOVWF  2C
....................         #endif 
....................  
....................         _OS_Tasks[0].State.bEnable = 0; 
298A:  BCF    2D.6
....................  
....................         #if OS_TASKS > 1 
....................            _OS_Tasks[1].State.bEnable = 0; 
298C:  BCF    32.6
....................         #endif 
....................  
....................         #if OS_TASKS > 2 
....................            _OS_Tasks[2].State.bEnable = 0; 
298E:  BCF    37.6
....................         #endif 
....................  
....................         #if OS_TASKS > 3 
....................            _OS_Tasks[3].State.bEnable = 0; 
2990:  BCF    3C.6
....................         #endif 
....................  
....................         #if OS_TASKS > 4 
....................            _OS_Tasks[4].State.bEnable = 0; 
2992:  BCF    41.6
....................         #endif 
....................  
....................         #if OS_TASKS > 5 
....................            _OS_Tasks[5].State.bEnable = 0; 
2994:  BCF    46.6
....................         #endif 
....................  
....................         #if OS_TASKS > 6 
....................            _OS_Tasks[6].State.bEnable = 0; 
2996:  BCF    4B.6
....................         #endif 
....................  
....................         #if OS_TASKS > 7 
....................            _OS_Tasks[7].State.bEnable = 0; 
....................         #endif 
....................  
....................         #if OS_TASKS > 8 
....................            _OS_Tasks[8].State.bEnable = 0; 
....................         #endif 
....................  
....................         #if OS_TASKS > 9 
....................            _OS_Tasks[9].State.bEnable = 0; 
....................         #endif 
....................  
....................     #endif 
....................  
....................  
....................     /*--------------------------------------* 
....................      *                                      * 
....................      *  Zero task queue for extended        * 
....................      *  priority mode                       * 
....................      *                                      * 
....................      *--------------------------------------*/ 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #if (OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED) 
....................     //------------------------------------------------------------------------------ 
....................  
....................  
....................     _OS_SET_IRP_CUR_TASK(); 
....................     _OS_CurTask = (OST_TASK_POINTER) _OS_Tasks; 
....................     _OS_Temp = OS_TASKS; 
....................     do 
....................     { 
....................         _OS_TaskQueue[_OS_Temp-1] = _OS_Temp-1; 
....................         _OS_TaskLevel[_OS_Temp-1] = 0; 
....................     } while (--_OS_Temp); 
....................     _OS_CLR_IRP(); 
....................  
....................     //------------------------------------------------------------------------------ 
....................     #endif 
....................     //------------------------------------------------------------------------------ 
....................  
....................  
.................... } 
2998:  GOTO   373C (RETURN)
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *                         C R I T I C A L   S E C T I O N S                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef OS_ENABLE_CRITICAL_SECTION 
.................... //------------------------------------------------------------------------------ 
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void OS_EnterCriticalSection (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *   description:   Enter critical section. 
....................  *                  This function disables interrupts (with saving current 
....................  *                  state) and sets system flag bInCriticalSection 
....................  * 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  *  Overloaded in:  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic16_mikroc.c" 
....................  *                  "osa_pic16_ccs.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "osa_stm8_cosmic.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(OS_EnterCriticalSection_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef      __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void OS_EnterCriticalSection (void) 
....................     { 
....................         OST_UINT temp; 
....................  
....................         temp = OS_DI(); 
....................         _OS_Flags.bInCriticalSection = 1; 
....................  
....................         _OS_Flags.bGIE_CTemp = 0; 
....................         if (temp & 0x80) _OS_Flags.bGIE_CTemp = 1; 
....................  
....................         _OS_Flags.bGIEL_CTemp = 0; 
....................         if (temp & 0x40) _OS_Flags.bGIEL_CTemp = 1; 
....................     } 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   //  __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void OS_EnterCriticalSection (void) 
....................     { 
....................         _OS_Flags.bGIE_CTemp = 0; 
....................         if (OS_DI() & 0x80) _OS_Flags.bGIE_CTemp = 1; 
....................         _OS_Flags.bInCriticalSection = 1; 
....................  
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  //  __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void OS_LeaveCriticalSection (void) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    Leave critical section. 
....................  *                  This function restore interrupt state from OS_Flag temp bits 
....................  *                  and clears system flag bInCriticalSection 
....................  * 
....................  *  parameters:     none 
....................  * 
....................  *  on return:      none 
....................  * 
....................  * 
....................  *  Overloaded in:  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic16_ccs.c" 
....................  *                  "osa_pic16_mikroc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "osa_stm8_cosmic.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(OS_LeaveCriticalSection_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #ifdef      __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void OS_LeaveCriticalSection (void) 
....................     { 
....................         char temp; 
....................         _OS_Flags.bInCriticalSection = 0; 
....................         temp = 0; 
....................         if (_OS_Flags.bGIE_CTemp)  temp |= 0x80; 
....................         if (_OS_Flags.bGIEL_CTemp) temp |= 0x40; 
....................         OS_RI(temp); 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #else   //  __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void OS_LeaveCriticalSection (void) 
....................     { 
....................         _OS_Flags.bInCriticalSection = 0; 
....................         if (_OS_Flags.bGIE_CTemp) OS_RI(0x80); 
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  //  __OSA18__ 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  //  OS_ENABLE_CRITICAL_SECTION 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ************************************************************************************************ 
....................  *                                                                                              * 
....................  *                                   S Y S T E M   T I M E R                                    * 
....................  *                                                                                              * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
.................... //----------------------------------------------------------------- 
.................... #ifdef OS_ENABLE_OS_TIMER 
.................... #ifndef OS_USE_INLINE_TIMER 
.................... //----------------------------------------------------------------- 
.................... void OS_Timer (void) 
.................... { 
....................     __OS_TimerInline(); 
*
238E:  BTFSS  2D.4
2390:  BRA    23A0
2392:  INCF   30,F
2394:  BTFSC  FD8.2
2396:  INCF   31,F
2398:  MOVF   30,W
239A:  IORWF  31,W
239C:  BNZ   23A0
239E:  BCF    2D.4
23A0:  BTFSS  32.4
23A2:  BRA    23B2
23A4:  INCF   35,F
23A6:  BTFSC  FD8.2
23A8:  INCF   36,F
23AA:  MOVF   35,W
23AC:  IORWF  36,W
23AE:  BNZ   23B2
23B0:  BCF    32.4
23B2:  BTFSS  37.4
23B4:  BRA    23C4
23B6:  INCF   3A,F
23B8:  BTFSC  FD8.2
23BA:  INCF   3B,F
23BC:  MOVF   3A,W
23BE:  IORWF  3B,W
23C0:  BNZ   23C4
23C2:  BCF    37.4
23C4:  BTFSS  3C.4
23C6:  BRA    23D6
23C8:  INCF   3F,F
23CA:  BTFSC  FD8.2
23CC:  INCF   40,F
23CE:  MOVF   3F,W
23D0:  IORWF  40,W
23D2:  BNZ   23D6
23D4:  BCF    3C.4
23D6:  BTFSS  41.4
23D8:  BRA    23E8
23DA:  INCF   44,F
23DC:  BTFSC  FD8.2
23DE:  INCF   45,F
23E0:  MOVF   44,W
23E2:  IORWF  45,W
23E4:  BNZ   23E8
23E6:  BCF    41.4
23E8:  BTFSS  46.4
23EA:  BRA    23FA
23EC:  INCF   49,F
23EE:  BTFSC  FD8.2
23F0:  INCF   4A,F
23F2:  MOVF   49,W
23F4:  IORWF  4A,W
23F6:  BNZ   23FA
23F8:  BCF    46.4
23FA:  BTFSS  4B.4
23FC:  BRA    240C
23FE:  INCF   4E,F
2400:  BTFSC  FD8.2
2402:  INCF   4F,F
2404:  MOVF   4E,W
2406:  IORWF  4F,W
2408:  BNZ   240C
240A:  BCF    4B.4
.................... } 
240C:  GOTO   2412 (RETURN)
.................... //----------------------------------------------------------------- 
.................... #endif  // OS_ENABLE_OS_TIMER 
.................... #endif  // OS_USE_INLINE_TIMER 
.................... //----------------------------------------------------------------- 
....................  
....................  
....................  
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *  OST_BOOL _OS_CheckEvent (char bEvent) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *  description:    (Internal function called by system kernel througth 
....................  *                  waiting services) 
....................  * 
....................  *                  Check condition of bEvent. Accordint to bEvent value and 
....................  *                  current state of bReady, bDelay and bCanContinue flags, 
....................  *                  task becames ready to execute or still remains in waiting 
....................  *                  mode. 
....................  * 
....................  *  parameters:     bEvent - zero, or non-zero condition 
....................  * 
....................  *  on return:      1 - when condition is true, or timeout occured 
....................  *                  0 - condition is false and no timeout 
....................  * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c" 
....................  *                  "osa_pic16_htpicc.c" 
....................  *                  "osa_pic18_htpicc.c" 
....................  *                  "osa_pic16_mikroc.c" 
....................  *                  "osa_pic18_mikroc.c" 
....................  *                  "osa_pic18_mplabc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "osa_pic16_ccs.c" 
....................  *                  "osa_pic18_ccs.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_CheckEvent_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     OST_BOOL _OS_CheckEvent (char bEvent) 
....................     { 
....................         _OS_Flags.bTimeout = 0; 
....................  
....................         if (bEvent) 
....................         { 
....................             if (_OS_CurTask->State.bReady) 
....................             { 
....................                 #ifdef OS_ENABLE_TTIMERS 
....................                     _OS_TASK_ATOMIC_WRITE_A(_OS_CurTask->State.bDelay = 0); 
....................                 #endif 
....................  
....................                 #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................                 _OS_Flags.bEventOK = 1; 
....................                 #endif 
....................  
....................                 return 1; 
....................             } 
....................  
....................             _OS_bTaskReady = 1; 
....................  
....................         } else { 
....................             _OS_bTaskReady = 0; 
....................         } 
....................  
....................         #ifdef OS_ENABLE_TTIMERS 
....................  
....................             if (!_OS_CurTask->State.bDelay && _OS_CurTask->State.bCanContinue) 
....................             { 
....................                 _OS_bTaskReady = 1; 
....................                 _OS_Flags.bTimeout = 1; 
....................  
....................                 #if OS_PRIORITY_LEVEL == OS_PRIORITY_EXTENDED 
....................                 _OS_Flags.bEventOK = 1; 
....................                 #endif 
....................  
....................                 return 1; 
....................  
....................             } 
....................  
....................         #endif 
....................  
....................         return 0; 
....................  
....................     } 
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_CheckEvent_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_system.c 
.................... //****************************************************************************** 
....................  
....................  
.................... #include "kernel\system\osa_tasks.c" 
.................... /* 
....................  ************************************************************************************************ 
....................  * 
....................  *  OSA cooperative RTOS for microcontrollers PIC, AVR and STM8 
....................  * 
....................  *  OSA is distributed under BSD license (see license.txt) 
....................  * 
....................  *  URL:            http://wiki.pic24.ru/doku.php/en/osa/ref/intro 
....................  * 
....................  *---------------------------------------------------------------------------------------------- 
....................  * 
....................  *  File:           osa_tasks.c 
....................  * 
....................  *  Programmer:     Timofeev Victor 
....................  *                  osa@pic24.ru, testerplus@mail.ru 
....................  * 
....................  *  Description:    Functions and variables for Tasks. 
....................  *                  This file directly included in osa.c 
....................  * 
....................  *  History:        12.09.2010 -    File updated 
....................  * 
....................  ************************************************************************************************ 
....................  */ 
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  Task descriptors 
.................... //****************************************************************************** 
....................  
.................... #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata access os_bsems 
.................... #endif 
....................  
.................... OS_TASKS_BANK  OST_TCB  _OS_Tasks[OS_TASKS] OS_ALLOCATION_TASKS; 
....................  
.................... #if (OS_BANK_TASKS == 0) && defined(__OSA_PIC18_MPLABC__) 
.................... #pragma udata 
.................... #endif 
....................  
....................  
....................  
.................... /* 
....................  ******************************************************************************** 
....................  * 
....................  *   void             _OS_Task_Create(OST_WORD    priority, 
....................  *                                    OST_CODE_POINTER TaskAddr) 
....................  * 
....................  *------------------------------------------------------------------------------ 
....................  * 
....................  *   description:   (Internal function called by system kernel from service 
....................  *                  OS_Task_Create) 
....................  *                  Create task in free descriptor. 
....................  *  parameters:     priority - value from 0 (highest) to 7 (lowest) 
....................  *                  TaskAddr - pointer to C-function that contains task 
....................  * 
....................  *  on return:      check OS_IsError 
....................  *                  OST_TASK_POINTER - pointer to task descriptor 
....................  *                  _OS_Temp - task position in _OS_Tasks array  
....................  * 
....................  *  Overloaded in:  "osa_pic12_htpicc.c" 
....................  *                  "osa_pic16_mikroc.c" 
....................  *                  "osa_pic24_mplabc.c" 
....................  *                  "port\osa_ccc16.c" 
....................  * 
....................  ******************************************************************************** 
....................  */ 
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #if !defined(_OS_Task_Create_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................     void _OS_Task_Create(OST_WORD priority, OST_CODE_POINTER TaskAddr) 
....................     { 
....................         OST_TASK_POINTER Task; 
....................  
....................         _OS_Flags.bError = 0; 
*
3686:  BCF    27.1
....................  
....................  
....................         /*--------------------------------------* 
....................          *                                      * 
....................          *  Start search from first task in     * 
....................          *  OS_TASKS descriptors.               * 
....................          *                                      * 
....................          *--------------------------------------*/ 
....................         Task = (OST_TASK_POINTER)_OS_Tasks; 
3688:  CLRF   xD2
368A:  MOVLW  2D
368C:  MOVFF  D2,D0
3690:  MOVWF  xCF
....................         _OS_Temp = 0;    
3692:  CLRF   28
....................  
....................         do { 
....................  
....................             if (!Task->State.bEnable)               // Is descriptor free? 
3694:  MOVFF  CF,FE9
3698:  MOVFF  D0,FEA
369C:  BTFSC  FEF.6
369E:  BRA    370A
....................             {                                       // Yes 
....................                 ((OST_TASK_STATE*)&priority)->bEnable = 1; 
36A0:  CLRF   xD2
36A2:  MOVLW  CC
36A4:  MOVWF  FE9
36A6:  MOVFF  D2,FEA
36AA:  BSF    FEF.6
....................                 ((OST_TASK_STATE*)&priority)->bReady = 1; 
36AC:  CLRF   xD2
36AE:  MOVLW  CC
36B0:  MOVWF  FE9
36B2:  MOVFF  D2,FEA
36B6:  BSF    FEF.3
....................  
....................                 Task->pTaskPointer = TaskAddr; 
36B8:  MOVLW  01
36BA:  ADDWF  xCF,W
36BC:  MOVWF  FE9
36BE:  MOVLW  00
36C0:  ADDWFC xD0,W
36C2:  MOVWF  FEA
36C4:  MOVFF  CE,FEC
36C8:  MOVF   FED,F
36CA:  MOVFF  CD,FEF
....................  
....................                 #ifdef OS_ENABLE_TTIMERS 
....................                     Task->Timer = 0; 
36CE:  MOVLW  03
36D0:  ADDWF  xCF,W
36D2:  MOVWF  FE9
36D4:  MOVLW  00
36D6:  ADDWFC xD0,W
36D8:  MOVWF  FEA
36DA:  CLRF   FEC
36DC:  MOVF   FED,F
36DE:  CLRF   FEF
....................                 #endif 
....................  
....................                 #ifdef _OS_TASK_CREATE_PROC_SPEC 
....................                 _OS_TASK_CREATE_PROC_SPEC(); 
....................                 #endif 
....................  
....................                 *((OS_TASKS_BANK char*)&Task->State) = priority; 
36E0:  MOVFF  CF,FE9
36E4:  MOVFF  D0,FEA
36E8:  MOVFF  CC,FEF
....................  
....................                 #if defined(_OS_CUR_FLAGS_IN_OS_STATE) 
....................                 if (Task == _OS_CurTask) *((OS_RAM_NEAR char*)&_OS_State) = priority; 
36EC:  MOVF   2B,W
36EE:  SUBWF  xCF,W
36F0:  BNZ   3706
36F2:  MOVF   2C,W
36F4:  SUBWF  xD0,W
36F6:  BNZ   3706
36F8:  CLRF   xD2
36FA:  MOVLW  2A
36FC:  MOVWF  FE9
36FE:  MOVFF  D2,FEA
3702:  MOVFF  CC,FEF
....................                 #endif 
....................  
....................                 #if defined(__OSA_AVR_WINAVR__) || defined(__OSA_AVR_IAR__) 
....................                 Task->nY_Temp = 0x8000; 
....................                 #endif 
....................  
....................                 #if defined(__OSA_AVR_WINAVR__) 
....................                 Task->c_NumOfTemp = 0;   
....................                 #endif 
....................  
....................                 #if defined(__OSA_STM8__) 
....................                 Task->nSP_Temp = 0; 
....................                 #endif 
....................  
....................                 _OS_Flags.bError = 0; 
3706:  BCF    27.1
....................  
....................                 return ; 
3708:  BRA    371C
....................  
....................             } 
....................  
....................             Task ++; 
370A:  MOVLW  05
370C:  ADDWF  xCF,F
370E:  BTFSC  FD8.0
3710:  INCF   xD0,F
....................  
....................         } while (++_OS_Temp < OS_TASKS);     
3712:  INCF   28,F
3714:  MOVF   28,W
3716:  SUBLW  06
3718:  BC    3694
....................  
....................         // There is no free descriptor. Task was not created. 
....................         _OS_Flags.bError = 1; 
371A:  BSF    27.1
....................  
....................         return ; 
....................     } 
371C:  RETURN 0
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif  // !defined(_OS_Task_Create_DEFINED) 
.................... //------------------------------------------------------------------------------ 
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa_tasks.c 
.................... //****************************************************************************** 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa.c 
.................... //****************************************************************************** 
....................  
....................  
....................  
.................... #endif 
....................  
....................  
....................  
.................... //------------------------------------------------------------------------------ 
.................... #endif 
.................... //------------------------------------------------------------------------------ 
....................  
.................... //****************************************************************************** 
.................... //  END OF FILE osa.h 
.................... //****************************************************************************** 
....................      
....................  
....................  
.................... //--- config: Directivas I/O ------------------------------------------------- 
.................... #use standard_io(A) 
.................... #use standard_io(B) 
.................... #use standard_io(C) 
.................... #use standard_io(D) 
....................  
.................... //--- def: variables Tarea USB ----------------------------------------------- 
.................... unsigned int8  RecibirByte[20];   //vector [0;19]=20 vectores x 1Byte                 
.................... unsigned int8  EnviarByte[3];     //vector [0;2]=3 vectores x 1Byte 
....................  
.................... //--- def: variables Tareas mPaP --------------------------------------------- 
.................... unsigned int16 numPulsosX,numPulsosY,numPulsosZ,numPulsosE;    
.................... unsigned int16 periodoPulsosX,periodoPulsosY; 
.................... unsigned int8 periodoPulsosZ,periodoPulsosE; 
.................... unsigned int8 dirMotorX,dirMotorY,dirMotorZ,dirMotorE;     
.................... #define dirX    PIN_D0 
.................... #define dirY    PIN_D1 
.................... #define dirZ    PIN_D2 
.................... #define dirE    PIN_D3 
.................... #define clockX  PIN_D4  
.................... #define clockY  PIN_D5 
.................... #define clockZ  PIN_D6 
.................... #define clockE  PIN_D7 
....................  
.................... //--- def: variables para funciones; ADC PIC, Gla, GlcPID -------------------- 
.................... unsigned int8 GlaoGlc; 
.................... unsigned int16 valorR,valorY,valorYusb,control; 
.................... float Kp,Kd,Ki,Kpz,Kiz,Kdz,T;    //Constantes PID   
.................... float r,y,u,e,e1,p,i,i1,d,d1;    //Variables PID 
.................... unsigned int16 max,min;          //Variables anti-windup  
....................  
.................... //--- def: Funciones Genericas ----------------------------------------------- 
.................... void Inicio (void); 
.................... void ADC(void); 
....................  
.................... //--- def: Tareas OSA -------------------------------------------------------- 
.................... void USB(void); 
.................... void Gla(void); 
.................... void Glc_PIDdiscreto(void); 
.................... void MotorX(void); 
.................... void MotorY(void); 
.................... void MotorZ(void); 
.................... void MotorE(void); 
....................  
.................... //**************************************************************************** 
.................... //**** main 
.................... //**************************************************************************** 
.................... void main(void){ 
371E:  CLRF   FF8
3720:  BCF    FD0.7
3722:  BSF    07.7
3724:  CLRF   FEA
3726:  CLRF   FE9
3728:  MOVF   FC1,W
372A:  ANDLW  C0
372C:  IORLW  0F
372E:  MOVWF  FC1
3730:  MOVLW  07
3732:  MOVWF  FB4
....................     
....................    Inicio(); 
3734:  GOTO   271E
....................     
....................    OS_Init();              // Init OS 
3738:  GOTO   2954
....................    OS_Task_Define(USB);    // Define tasks. 
373C:  BTFSC  FF9.0
373E:  GOTO   2C0E
....................    OS_Task_Define(Gla);  
3742:  BTFSC  FF9.0
3744:  GOTO   2DF8
....................    OS_Task_Define(Glc_PIDdiscreto);          
3748:  BTFSC  FF9.0
374A:  BRA    3190
....................    OS_Task_Define(MotorX); 
374C:  BTFSC  FF9.0
374E:  BRA    34CC
....................    OS_Task_Define(MotorY); 
3750:  BTFSC  FF9.0
3752:  BRA    353C
....................    OS_Task_Define(MotorZ);         
3754:  BTFSC  FF9.0
3756:  BRA    35AC
....................    OS_Task_Define(MotorE); 
3758:  BTFSC  FF9.0
375A:  BRA    361A
....................     
....................    // Create tasks. // if 0 = no priorities  
....................    OS_Task_Create(0, USB);     
375C:  MOVLW  2C
375E:  MOVWF  03
3760:  MOVLW  0E
3762:  MOVWF  xCA
3764:  MOVFF  03,CB
3768:  CLRF   xCC
376A:  MOVFF  03,CE
376E:  MOVWF  xCD
3770:  RCALL  3686
....................    OS_Task_Create(0, Gla); 
3772:  MOVLW  2D
3774:  MOVWF  03
3776:  MOVLW  F8
3778:  MOVWF  xCA
377A:  MOVFF  03,CB
377E:  CLRF   xCC
3780:  MOVFF  03,CE
3784:  MOVWF  xCD
3786:  RCALL  3686
....................    OS_Task_Create(0, Glc_PIDdiscreto);       
3788:  MOVLW  31
378A:  MOVWF  03
378C:  MOVLW  90
378E:  MOVWF  xCA
3790:  MOVFF  03,CB
3794:  CLRF   xCC
3796:  MOVFF  03,CE
379A:  MOVWF  xCD
379C:  RCALL  3686
....................    OS_Task_Create(0, MotorX);   
379E:  MOVLW  34
37A0:  MOVWF  03
37A2:  MOVLW  CC
37A4:  MOVWF  xCA
37A6:  MOVFF  03,CB
37AA:  CLRF   xCC
37AC:  MOVFF  03,CE
37B0:  MOVWF  xCD
37B2:  RCALL  3686
....................    OS_Task_Create(0, MotorY); 
37B4:  MOVLW  35
37B6:  MOVWF  03
37B8:  MOVLW  3C
37BA:  MOVWF  xCA
37BC:  MOVFF  03,CB
37C0:  CLRF   xCC
37C2:  MOVFF  03,CE
37C6:  MOVWF  xCD
37C8:  RCALL  3686
....................    OS_Task_Create(0, MotorZ);   
37CA:  MOVLW  35
37CC:  MOVWF  03
37CE:  MOVLW  AC
37D0:  MOVWF  xCA
37D2:  MOVFF  03,CB
37D6:  CLRF   xCC
37D8:  MOVFF  03,CE
37DC:  MOVWF  xCD
37DE:  RCALL  3686
....................    OS_Task_Create(0, MotorE); 
37E0:  MOVLW  36
37E2:  MOVWF  03
37E4:  MOVLW  1A
37E6:  MOVWF  xCA
37E8:  MOVFF  03,CB
37EC:  CLRF   xCC
37EE:  MOVFF  03,CE
37F2:  MOVWF  xCD
37F4:  RCALL  3686
....................     
....................    // Create tasks, Task priority. Allowed values from 0(highest) to 7(lowest) 
....................    /*OS_Task_Create(0, USB);     
....................    OS_Task_Create(7, Gla); 
....................    OS_Task_Create(1, Glc_PIDdiscreto);       
....................    OS_Task_Create(2, MotorX);   
....................    OS_Task_Create(2, MotorY); 
....................    OS_Task_Create(2, MotorZ);   
....................    OS_Task_Create(2, MotorE); 
....................     
....................    OS_Bsem_Set(BS_GLAGLC_FREE);*/ 
....................     
....................    OS_EI();                // Enable interrupts 
37F6:  BSF    FF2.7
37F8:  BTFSS  FD0.7
37FA:  BRA    37FE
37FC:  BSF    FF2.6
....................    OS_Run();               // Running scheduler 
37FE:  CLRF   28
3800:  CLRF   xCB
3802:  MOVLW  2D
3804:  MOVWF  xCA
3806:  MOVLW  1E
3808:  ADDWF  xCA,W
380A:  MOVWF  01
380C:  MOVLW  00
380E:  ADDWFC xCB,W
3810:  MOVWF  03
3812:  MOVF   03,W
3814:  SUBWF  2C,W
3816:  BNC   382E
3818:  BNZ   3820
381A:  MOVF   01,W
381C:  SUBWF  2B,W
381E:  BNC   382E
3820:  CLRF   xCB
3822:  MOVLW  2D
3824:  MOVWF  xCA
3826:  MOVFF  CB,2C
382A:  MOVWF  2B
382C:  BRA    3836
382E:  MOVLW  05
3830:  ADDWF  2B,F
3832:  BTFSC  FD8.0
3834:  INCF   2C,F
3836:  MOVFF  2B,FE9
383A:  MOVFF  2C,FEA
383E:  MOVFF  FEF,2A
3842:  BTFSS  2A.6
3844:  BRA    3848
3846:  BTFSC  2A.7
3848:  BRA    3870
384A:  BTFSS  2A.4
384C:  BRA    3852
384E:  BTFSS  2A.5
3850:  BRA    3870
3852:  CALL   293C
3856:  MOVFF  2B,01
385A:  MOVFF  2C,03
385E:  MOVFF  2B,FE9
3862:  MOVFF  2C,FEA
3866:  MOVLW  D7
3868:  ANDWF  FEF,F
386A:  MOVF   2A,W
386C:  ANDLW  28
386E:  IORWF  FEF,F
3870:  BRA    37FE
.................... } 
....................  
.................... //**** Funciones genericas *************************************************** 
.................... void Inicio(void){  
....................    //--- ini: mPaP ----------------------------------------------------------- 
3872:  SLEEP 
....................    numPulsosX=numPulsosY=numPulsosZ=numPulsosE=0; 
*
271E:  CLRF   x6E
2720:  CLRF   x6D
2722:  MOVFF  6E,6C
2726:  MOVFF  6D,6B
272A:  MOVFF  6C,6A
272E:  MOVFF  6B,69
2732:  MOVFF  6A,68
2736:  MOVFF  69,67
....................    periodoPulsosX=periodoPulsosY=periodoPulsosZ=periodoPulsosE=0; 
273A:  CLRF   x74
273C:  MOVFF  74,73
2740:  CLRF   x72
2742:  MOVFF  73,71
2746:  MOVFF  72,70
274A:  MOVFF  71,6F
....................    //--- ini: PID ------------------------------------------------------------ 
....................    min=0.0; max=1023 ; //valor Anti-windup     
274E:  CLRF   xC9
2750:  CLRF   xC8
2752:  MOVLW  03
2754:  MOVWF  xC7
2756:  SETF   xC6
....................    i1=0;e1=0;d1=0;    
2758:  CLRF   xBD
275A:  CLRF   xBC
275C:  CLRF   xBB
275E:  CLRF   xBA
2760:  CLRF   xB1
2762:  CLRF   xB0
2764:  CLRF   xAF
2766:  CLRF   xAE
2768:  CLRF   xC5
276A:  CLRF   xC4
276C:  CLRF   xC3
276E:  CLRF   xC2
....................    Kd=8; Kp=8; Ki=0.02915; 
2770:  CLRF   x89
2772:  CLRF   x88
2774:  CLRF   x87
2776:  MOVLW  82
2778:  MOVWF  x86
277A:  CLRF   x85
277C:  CLRF   x84
277E:  CLRF   x83
2780:  MOVWF  x82
2782:  MOVLW  FB
2784:  MOVWF  x8D
2786:  MOVLW  CB
2788:  MOVWF  x8C
278A:  MOVLW  6E
278C:  MOVWF  x8B
278E:  MOVLW  79
2790:  MOVWF  x8A
....................    T=5;       //Tiempo de muestreo  tr/6 < T < tr/20 
2792:  CLRF   x9D
2794:  CLRF   x9C
2796:  MOVLW  20
2798:  MOVWF  x9B
279A:  MOVLW  81
279C:  MOVWF  x9A
....................    Kpz=Kp; Kiz=Ki*T/2; Kdz=Kd/T; 
279E:  MOVFF  85,91
27A2:  MOVFF  84,90
27A6:  MOVFF  83,8F
27AA:  MOVFF  82,8E
27AE:  MOVFF  8D,CD
27B2:  MOVFF  8C,CC
27B6:  MOVFF  8B,CB
27BA:  MOVFF  8A,CA
27BE:  MOVFF  9D,D1
27C2:  MOVFF  9C,D0
27C6:  MOVFF  9B,CF
27CA:  MOVFF  9A,CE
27CE:  RCALL  2420
27D0:  MOVFF  00,CA
27D4:  MOVFF  01,CB
27D8:  MOVFF  02,CC
27DC:  MOVFF  03,CD
27E0:  MOVFF  03,D1
27E4:  MOVFF  02,D0
27E8:  MOVFF  01,CF
27EC:  MOVFF  00,CE
27F0:  CLRF   xD5
27F2:  CLRF   xD4
27F4:  CLRF   xD3
27F6:  MOVLW  80
27F8:  MOVWF  xD2
27FA:  RCALL  2512
27FC:  MOVFF  03,95
2800:  MOVFF  02,94
2804:  MOVFF  01,93
2808:  MOVFF  00,92
280C:  MOVFF  89,D1
2810:  MOVFF  88,D0
2814:  MOVFF  87,CF
2818:  MOVFF  86,CE
281C:  MOVFF  9D,D5
2820:  MOVFF  9C,D4
2824:  MOVFF  9B,D3
2828:  MOVFF  9A,D2
282C:  RCALL  2512
282E:  MOVFF  03,99
2832:  MOVFF  02,98
2836:  MOVFF  01,97
283A:  MOVFF  00,96
....................     
....................    //--- ini: CCP --------------------------------------------------------- 
....................    //--- Pre=16 PR2=249 Pos=1, PWMF=3kHz,PWMT=300us con Fosc(clock)=48MHz 
....................    setup_timer_2(T2_DIV_BY_16,249,1);  
283E:  MOVLW  00
2840:  IORLW  06
2842:  MOVWF  FCA
2844:  MOVLW  F9
2846:  MOVWF  FCB
....................    setup_ccp1(ccp_pwm);               //Configurar modulo CCP1 en modo PWM 
2848:  BCF    F94.2
284A:  BCF    F8B.2
284C:  MOVLW  0C
284E:  MOVWF  FBD
2850:  CLRF   FB7
2852:  CLRF   FB6
....................    set_pwm1_duty(0);   
2854:  CLRF   FBE
....................     
....................    //--- ini: ADC ---------------------------------------------------------   
....................    setup_adc_ports(AN0|VSS_VDD );      
2856:  MOVF   FC1,W
2858:  ANDLW  C0
285A:  IORLW  0E
285C:  MOVWF  FC1
....................    setup_adc(ADC_CLOCK_INTERNAL);  
285E:  MOVF   FC0,W
2860:  ANDLW  C0
2862:  IORLW  07
2864:  MOVWF  FC0
2866:  BSF    FC0.7
2868:  BSF    FC2.0
....................    //setup_adc(ADC_CLOCK_DIV_8); //respetar el Tad>1.6us  
....................                                  //Tad=8/Fosc=8/20Mhz=400ns 
....................    set_adc_channel(0);           //Seleccionar Canal(0)=AN0=A0 para ADC 
286A:  MOVLW  00
286C:  MOVWF  01
286E:  MOVF   FC2,W
2870:  ANDLW  C3
2872:  IORWF  01,W
2874:  MOVWF  FC2
....................     
....................    //--- ini: TIMER0 for OS_Timer() ---------------------------------------                                   
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_1);  //config Timer0, Pre=1=RTCC_DIV_1 
2876:  MOVLW  88
2878:  MOVWF  FD5
....................    //set_timer0(0xF63B);   //carga del Timer0, clock=20MHz, Fout=1kHz=0xF63B 
....................    set_timer0(0xE88F);     //carga del Timer0, clock=48MHz, Fout=1kHz=0xE88F 
287A:  MOVLW  E8
287C:  MOVWF  FD7
287E:  MOVLW  8F
2880:  MOVWF  FD6
....................     
....................    //--- ini: Interrupts -------------------------------------------------- 
....................    //enable_interrupts(GLOBAL); 
....................    enable_interrupts(INT_TIMER0);            //habilita interrupcion Timer0 
2882:  BSF    FF2.5
....................    //enable_interrupts(INT_TIMER2); 
....................     
....................    //--- ini: USB ------------------------------------------------------------ 
....................    usb_init();                   //inicializamos el USB 
2884:  BRA    26DA
....................    usb_task();                   //habilita periferico usb e interrupciones 
2886:  RCALL  26B8
....................    usb_wait_for_enumeration();   //esperamos hasta que el PicUSB  
2888:  BRA    26E8
....................                                  //sea configurado por el host 
....................    delay_ms(50);    
288A:  MOVLW  32
288C:  MOVWF  xCA
288E:  BRA    26F4
.................... } 
2890:  GOTO   3738 (RETURN)
....................  
.................... void ADC(void){ 
....................    valorYusb=read_adc(); 
*
2AFA:  BSF    FC2.1
2AFC:  BTFSC  FC2.1
2AFE:  BRA    2AFC
2B00:  MOVFF  FC3,7E
2B04:  MOVFF  FC4,7F
....................    //delay_us(1); //Tacq minimo de carga  
....................                   //del capacitor(sample&hold)=8/Fosc=8/20MHz=400ns=0.4us 
....................                    
....................    //-- El ADC es de 10 bits y puedo enviar solo 8, asi que separo 
....................    //-- la variable en 2 bytes "EnviarByte[0] y EnviarByte[1]",  
....................    //-- luego se arma en C# (ver notas) 
....................    EnviarByte[0]=valorYusb >> 8;   //desplazamiento de 8bits a la derecha 
2B08:  MOVFF  7F,64
....................    EnviarByte[1]=valorYusb & 0xFF; //a & b = AND binario 
2B0C:  MOVFF  7E,65
.................... } 
2B10:  GOTO   2D2C (RETURN)
....................  
.................... //**** Tareas OSA *********************************************************** 
.................... #INT_TIMER0 
.................... void timer0_isr(void){   
....................    OS_Timer(); 
*
2410:  BRA    238E
....................    set_timer0(0xE88F);    //se recarga el Timer0    
2412:  MOVLW  E8
2414:  MOVWF  FD7
2416:  MOVLW  8F
2418:  MOVWF  FD6
.................... }    
....................  
241A:  BCF    FF2.2
241C:  GOTO   186C
.................... void USB(void){ 
....................    for(;;){ 
....................       if(usb_enumerated()){   //True si el USB ha sido enumerado.       
*
2C0E:  BRA    299C
2C10:  MOVF   01,F
2C12:  BTFSC  FD8.2
2C14:  BRA    2D74
....................          if(usb_kbhit(1)){    //(endpoint=1 EP1)= TRUE si el EP1 tiene datos  
2C16:  MOVLW  01
2C18:  MOVWF  xCA
2C1A:  BRA    29A4
2C1C:  MOVF   01,F
2C1E:  BTFSC  FD8.2
2C20:  BRA    2D2A
....................                               //en su buffer de recepcion. 
....................              
....................             //-- (endpoint,ptr,max)=Reads up to max bytes from 
....................             //-- the specified endpoint buffer and saves it to the pointer ptr 
....................             //-- Returns the number of bytes saved to ptr 
....................             usb_get_packet(1,RecibirByte,20); 
2C22:  MOVLW  01
2C24:  MOVWF  xCA
2C26:  CLRF   xCC
2C28:  MOVLW  50
2C2A:  MOVWF  xCB
2C2C:  CLRF   xCE
2C2E:  MOVLW  14
2C30:  MOVWF  xCD
2C32:  BRA    2A9A
....................                                               
....................             //-- revisa en orden logico el contenido de  
....................             //-- RecibirByte[0],[1],[2],[3],[4].... 
....................             //-- *2, OSA usa el doble de pulsos 
....................             numPulsosX     = (RecibirByte[0]*256+RecibirByte[1])*2;   
2C34:  CLRF   xCB
2C36:  MOVFF  50,CA
2C3A:  MOVLW  01
2C3C:  MOVWF  xCD
2C3E:  CLRF   xCC
2C40:  RCALL  2ADC
2C42:  MOVFF  02,CB
2C46:  MOVFF  01,CA
2C4A:  MOVF   51,W
2C4C:  ADDWF  xCA,F
2C4E:  MOVLW  00
2C50:  ADDWFC xCB,F
2C52:  BCF    FD8.0
2C54:  RLCF   xCA,W
2C56:  MOVWF  x67
2C58:  RLCF   xCB,W
2C5A:  MOVWF  x68
....................             numPulsosY     = (RecibirByte[2]*256+RecibirByte[3])*2; 
2C5C:  CLRF   xCB
2C5E:  MOVFF  52,CA
2C62:  MOVLW  01
2C64:  MOVWF  xCD
2C66:  CLRF   xCC
2C68:  RCALL  2ADC
2C6A:  MOVFF  02,CB
2C6E:  MOVFF  01,CA
2C72:  MOVF   53,W
2C74:  ADDWF  xCA,F
2C76:  MOVLW  00
2C78:  ADDWFC xCB,F
2C7A:  BCF    FD8.0
2C7C:  RLCF   xCA,W
2C7E:  MOVWF  x69
2C80:  RLCF   xCB,W
2C82:  MOVWF  x6A
....................             numPulsosZ     = (RecibirByte[4]*256+RecibirByte[5])*2; 
2C84:  CLRF   xCB
2C86:  MOVFF  54,CA
2C8A:  MOVLW  01
2C8C:  MOVWF  xCD
2C8E:  CLRF   xCC
2C90:  RCALL  2ADC
2C92:  MOVFF  02,CB
2C96:  MOVFF  01,CA
2C9A:  MOVF   55,W
2C9C:  ADDWF  xCA,F
2C9E:  MOVLW  00
2CA0:  ADDWFC xCB,F
2CA2:  BCF    FD8.0
2CA4:  RLCF   xCA,W
2CA6:  MOVWF  x6B
2CA8:  RLCF   xCB,W
2CAA:  MOVWF  x6C
....................             numPulsosE     = (RecibirByte[6]*256+RecibirByte[7])*2; 
2CAC:  CLRF   xCB
2CAE:  MOVFF  56,CA
2CB2:  MOVLW  01
2CB4:  MOVWF  xCD
2CB6:  CLRF   xCC
2CB8:  RCALL  2ADC
2CBA:  MOVFF  02,CB
2CBE:  MOVFF  01,CA
2CC2:  MOVF   57,W
2CC4:  ADDWF  xCA,F
2CC6:  MOVLW  00
2CC8:  ADDWFC xCB,F
2CCA:  BCF    FD8.0
2CCC:  RLCF   xCA,W
2CCE:  MOVWF  x6D
2CD0:  RLCF   xCB,W
2CD2:  MOVWF  x6E
....................             periodoPulsosX = (RecibirByte[8]*256+RecibirByte[9]); 
2CD4:  CLRF   xCB
2CD6:  MOVFF  58,CA
2CDA:  MOVLW  01
2CDC:  MOVWF  xCD
2CDE:  CLRF   xCC
2CE0:  RCALL  2ADC
2CE2:  MOVF   59,W
2CE4:  ADDWF  01,W
2CE6:  MOVWF  x6F
2CE8:  MOVLW  00
2CEA:  ADDWFC 02,W
2CEC:  MOVWF  x70
....................             periodoPulsosY = (RecibirByte[10]*256+RecibirByte[11]); 
2CEE:  CLRF   xCB
2CF0:  MOVFF  5A,CA
2CF4:  MOVLW  01
2CF6:  MOVWF  xCD
2CF8:  CLRF   xCC
2CFA:  RCALL  2ADC
2CFC:  MOVF   5B,W
2CFE:  ADDWF  01,W
2D00:  MOVWF  x71
2D02:  MOVLW  00
2D04:  ADDWFC 02,W
2D06:  MOVWF  x72
....................             periodoPulsosZ = RecibirByte[12]; 
2D08:  MOVFF  5C,73
....................             periodoPulsosE = RecibirByte[13]; 
2D0C:  MOVFF  5D,74
....................             dirMotorX      = RecibirByte[14]; 
2D10:  MOVFF  5E,75
....................             dirMotorY      = RecibirByte[15]; 
2D14:  MOVFF  5F,76
....................             dirMotorZ      = RecibirByte[16]; 
2D18:  MOVFF  60,77
....................             dirMotorE      = RecibirByte[17]; 
2D1C:  MOVFF  61,78
....................             GlaoGlc        = RecibirByte[18]; 
2D20:  MOVFF  62,79
....................             valorR         = RecibirByte[19];   
2D24:  CLRF   x7B
2D26:  MOVFF  63,7A
....................          }          
....................          //-- reviso en orden logico EnviarByte[0],[1] y envio por usb                
....................          ADC();    //esta funcion contiene los valores de EnviarByte[0;1] 
2D2A:  BRA    2AFA
....................          if( (numPulsosX || numPulsosY || numPulsosZ || numPulsosE) != 0) {EnviarByte[2]=1; output_high(PIN_B6);} 
2D2C:  MOVF   x67,W
2D2E:  IORWF  x68,W
2D30:  BNZ   2D48
2D32:  MOVF   x69,W
2D34:  IORWF  x6A,W
2D36:  BNZ   2D48
2D38:  MOVF   x6B,W
2D3A:  IORWF  x6C,W
2D3C:  BNZ   2D48
2D3E:  MOVF   x6D,W
2D40:  IORWF  x6E,W
2D42:  BNZ   2D48
2D44:  MOVLW  00
2D46:  BRA    2D4A
2D48:  MOVLW  01
2D4A:  XORLW  00
2D4C:  BZ    2D58
2D4E:  MOVLW  01
2D50:  MOVWF  x66
2D52:  BCF    F93.6
2D54:  BSF    F8A.6
....................          else {EnviarByte[2]=0; output_low(PIN_B6);} 
2D56:  BRA    2D5E
2D58:  CLRF   x66
2D5A:  BCF    F93.6
2D5C:  BCF    F8A.6
....................           
....................          //-- (endpoint,data,len,tgl)=Places the packet of data 
....................          //-- into the specified endpoint buffer. 
....................          //-- Returns TRUE if success, FALSE if the buffer  
....................          //-- is still full with the last packet. 
....................          usb_put_packet(1,EnviarByte,3,USB_DTS_TOGGLE);                                                                      
2D5E:  MOVLW  01
2D60:  MOVWF  xCA
2D62:  CLRF   xCC
2D64:  MOVLW  64
2D66:  MOVWF  xCB
2D68:  CLRF   xCE
2D6A:  MOVLW  03
2D6C:  MOVWF  xCD
2D6E:  MOVLW  02
2D70:  MOVWF  xCF
2D72:  BRA    2B14
....................       }       
....................       OS_Delay(10);  
2D74:  CLRF   xCB
2D76:  MOVLW  0A
2D78:  MOVWF  xCA
2D7A:  RCALL  2BBA
2D7C:  RCALL  2894
2D7E:  NOP   
....................       OS_Yield(); 
2D80:  RCALL  2894
2D82:  NOP   
....................    } 
2D84:  BRA    2C0E
.................... } 
2D86:  GOTO   3742 (RETURN)
....................  
.................... void Gla(void){ 
....................    for(;;){       
....................       OS_Wait(GlaoGlc==3); 
*
2DF8:  RCALL  290A
2DFA:  NOP   
2DFC:  MOVF   x79,W
2DFE:  SUBLW  03
2E00:  BZ    2E06
2E02:  MOVLW  00
2E04:  BRA    2E08
2E06:  MOVLW  01
2E08:  XORLW  00
2E0A:  BNZ   2E10
2E0C:  MOVLW  00
2E0E:  BRA    2E12
2E10:  MOVLW  01
2E12:  MOVWF  xCA
2E14:  MOVWF  xCB
2E16:  RCALL  2918
....................       //OS_Bsem_Wait(BS_GLAGLC_FREE);  
....................       output_toggle(PIN_B7); 
2E18:  BCF    F93.7
2E1A:  BTG    F8A.7
....................        
....................       //-- 1023/255=4.012, necesita adaptarse al mismo rango  
....................       //-- porque el valorR que llega desde el GUI tiene max=255 
....................       r=(float)(valorR*4.012);    
2E1C:  MOVFF  7B,CB
2E20:  MOVFF  7A,CA
2E24:  RCALL  2D8A
2E26:  MOVFF  03,CD
2E2A:  MOVFF  02,CC
2E2E:  MOVFF  01,CB
2E32:  MOVFF  00,CA
2E36:  MOVLW  4E
2E38:  MOVWF  xD1
2E3A:  MOVLW  62
2E3C:  MOVWF  xD0
2E3E:  CLRF   xCF
2E40:  MOVLW  81
2E42:  MOVWF  xCE
2E44:  CALL   2420
2E48:  MOVFF  03,A1
2E4C:  MOVFF  02,A0
2E50:  MOVFF  01,9F
2E54:  MOVFF  00,9E
....................       control=(unsigned int16)r; 
2E58:  MOVFF  A1,CD
2E5C:  MOVFF  A0,CC
2E60:  MOVFF  9F,CB
2E64:  MOVFF  9E,CA
2E68:  RCALL  2DC0
2E6A:  MOVFF  02,81
2E6E:  MOVFF  01,80
....................       set_pwm1_duty(control); 
2E72:  MOVFF  81,02
2E76:  MOVFF  80,01
2E7A:  RRCF   02,F
2E7C:  RRCF   01,F
2E7E:  RRCF   02,F
2E80:  RRCF   01,F
2E82:  RRCF   02,F
2E84:  MOVFF  01,FBE
2E88:  RRCF   02,F
2E8A:  RRCF   02,W
2E8C:  ANDLW  30
2E8E:  MOVWF  00
2E90:  MOVF   FBD,W
2E92:  ANDLW  CF
2E94:  IORWF  00,W
2E96:  MOVWF  FBD
....................        
....................       OS_Delay(1000); 
2E98:  MOVLW  03
2E9A:  MOVWF  xCB
2E9C:  MOVLW  E8
2E9E:  MOVWF  xCA
2EA0:  RCALL  2BBA
2EA2:  RCALL  2894
2EA4:  NOP   
....................       //OS_Bsem_Set(BS_GLAGLC_FREE);  
....................       OS_Yield();             
2EA6:  RCALL  2894
2EA8:  NOP   
....................    } 
2EAA:  BRA    2DF8
.................... } 
2EAC:  GOTO   3748 (RETURN)
....................  
.................... void Glc_PIDdiscreto(void){ 
....................    for(;;){   
....................       OS_Wait(GlaoGlc==2); //2 
*
3190:  CALL   290A
3194:  NOP   
3196:  MOVF   x79,W
3198:  SUBLW  02
319A:  BZ    31A0
319C:  MOVLW  00
319E:  BRA    31A2
31A0:  MOVLW  01
31A2:  XORLW  00
31A4:  BNZ   31AA
31A6:  MOVLW  00
31A8:  BRA    31AC
31AA:  MOVLW  01
31AC:  MOVWF  xCA
31AE:  MOVWF  xCB
31B0:  CALL   2918
....................       //OS_Bsem_Wait(BS_GLAGLC_FREE);  
....................       output_toggle(PIN_B7); 
31B4:  BCF    F93.7
31B6:  BTG    F8A.7
....................      
....................       valorY=read_adc(ADC_READ_ONLY); 
31B8:  BTFSC  FC2.1
31BA:  BRA    31B8
31BC:  MOVFF  FC3,7C
31C0:  MOVFF  FC4,7D
....................       //-- debido al ADC 10bits, la conversion se realiza con 10bits,  
....................       //-- entonces valorY tiene rango de 0 a 1023 
....................       y=(float)valorY; 
31C4:  MOVFF  7D,CB
31C8:  MOVFF  7C,CA
31CC:  RCALL  2D8A
31CE:  MOVFF  03,A5
31D2:  MOVFF  02,A4
31D6:  MOVFF  01,A3
31DA:  MOVFF  00,A2
....................       //-- 1023/255=4.012, necesita adaptarse al mismo rango  
....................       //-- porque el valorR que llega desde el GUI tiene max=255 
....................       r=(float)(valorR*4.012); 
31DE:  MOVFF  7B,CB
31E2:  MOVFF  7A,CA
31E6:  RCALL  2D8A
31E8:  MOVFF  03,CD
31EC:  MOVFF  02,CC
31F0:  MOVFF  01,CB
31F4:  MOVFF  00,CA
31F8:  MOVLW  4E
31FA:  MOVWF  xD1
31FC:  MOVLW  62
31FE:  MOVWF  xD0
3200:  CLRF   xCF
3202:  MOVLW  81
3204:  MOVWF  xCE
3206:  CALL   2420
320A:  MOVFF  03,A1
320E:  MOVFF  02,A0
3212:  MOVFF  01,9F
3216:  MOVFF  00,9E
....................       //---------------------------------------------------------------------- 
....................       //-- Calculo PID por metodo tustin para termino integral  
....................       //-- y metodo de diferencias hacia atras para termino derivativo 
....................       //-- Sea e(kT)=e; e(kT-T)=e1 
....................       e=r-y;                
321A:  BSF    FD8.1
321C:  MOVFF  A1,D1
3220:  MOVFF  A0,D0
3224:  MOVFF  9F,CF
3228:  MOVFF  9E,CE
322C:  MOVFF  A5,D5
3230:  MOVFF  A4,D4
3234:  MOVFF  A3,D3
3238:  MOVFF  A2,D2
323C:  RCALL  2EB0
323E:  MOVFF  03,AD
3242:  MOVFF  02,AC
3246:  MOVFF  01,AB
324A:  MOVFF  00,AA
....................       //Sea p(kT)=p; i(kT)=i; i(kT-T)=i1; d(kT)=d 
....................       p=Kpz*e;         
324E:  MOVFF  91,CD
3252:  MOVFF  90,CC
3256:  MOVFF  8F,CB
325A:  MOVFF  8E,CA
325E:  MOVFF  AD,D1
3262:  MOVFF  AC,D0
3266:  MOVFF  AB,CF
326A:  MOVFF  AA,CE
326E:  CALL   2420
3272:  MOVFF  03,B5
3276:  MOVFF  02,B4
327A:  MOVFF  01,B3
327E:  MOVFF  00,B2
....................       //i=i1+Kiz*e;    //diferencia hacia atras 
....................       i=i1+Kiz*(e+e1);  //tustin 
3282:  BCF    FD8.1
3284:  MOVFF  AD,D1
3288:  MOVFF  AC,D0
328C:  MOVFF  AB,CF
3290:  MOVFF  AA,CE
3294:  MOVFF  B1,D5
3298:  MOVFF  B0,D4
329C:  MOVFF  AF,D3
32A0:  MOVFF  AE,D2
32A4:  RCALL  2EB0
32A6:  MOVFF  95,CD
32AA:  MOVFF  94,CC
32AE:  MOVFF  93,CB
32B2:  MOVFF  92,CA
32B6:  MOVFF  03,D1
32BA:  MOVFF  02,D0
32BE:  MOVFF  01,CF
32C2:  MOVFF  00,CE
32C6:  CALL   2420
32CA:  BCF    FD8.1
32CC:  MOVFF  BD,D1
32D0:  MOVFF  BC,D0
32D4:  MOVFF  BB,CF
32D8:  MOVFF  BA,CE
32DC:  MOVFF  03,D5
32E0:  MOVFF  02,D4
32E4:  MOVFF  01,D3
32E8:  MOVFF  00,D2
32EC:  RCALL  2EB0
32EE:  MOVFF  03,B9
32F2:  MOVFF  02,B8
32F6:  MOVFF  01,B7
32FA:  MOVFF  00,B6
....................       d=Kdz*(e-e1);  //diferencia hacia atras 
32FE:  BSF    FD8.1
3300:  MOVFF  AD,D1
3304:  MOVFF  AC,D0
3308:  MOVFF  AB,CF
330C:  MOVFF  AA,CE
3310:  MOVFF  B1,D5
3314:  MOVFF  B0,D4
3318:  MOVFF  AF,D3
331C:  MOVFF  AE,D2
3320:  RCALL  2EB0
3322:  MOVFF  99,CD
3326:  MOVFF  98,CC
332A:  MOVFF  97,CB
332E:  MOVFF  96,CA
3332:  MOVFF  03,D1
3336:  MOVFF  02,D0
333A:  MOVFF  01,CF
333E:  MOVFF  00,CE
3342:  CALL   2420
3346:  MOVFF  03,C1
334A:  MOVFF  02,C0
334E:  MOVFF  01,BF
3352:  MOVFF  00,BE
....................        
....................       //Sea u(kT)=u 
....................       u=p+i+d;    
3356:  BCF    FD8.1
3358:  MOVFF  B5,D1
335C:  MOVFF  B4,D0
3360:  MOVFF  B3,CF
3364:  MOVFF  B2,CE
3368:  MOVFF  B9,D5
336C:  MOVFF  B8,D4
3370:  MOVFF  B7,D3
3374:  MOVFF  B6,D2
3378:  RCALL  2EB0
337A:  MOVFF  00,CA
337E:  MOVFF  01,CB
3382:  MOVFF  02,CC
3386:  MOVFF  03,CD
338A:  BCF    FD8.1
338C:  MOVFF  03,D1
3390:  MOVFF  02,D0
3394:  MOVFF  01,CF
3398:  MOVFF  00,CE
339C:  MOVFF  C1,D5
33A0:  MOVFF  C0,D4
33A4:  MOVFF  BF,D3
33A8:  MOVFF  BE,D2
33AC:  RCALL  2EB0
33AE:  MOVFF  03,A9
33B2:  MOVFF  02,A8
33B6:  MOVFF  01,A7
33BA:  MOVFF  00,A6
....................         
....................       //-- Anti-windup solo al termino integral para evitar que se infle 
....................       //-- y se haga muy grande si la accion de control se satura, por tanto 
....................       //-- es necesario impedir que cambie i 
....................       //if((u>max) | (u<min)) {i=i-Ki*T*e;}      //diferencia hacia atras 
....................       //if((u>max) | (u<min)) i=i-Kiz*(e+e1);     //tustin 
....................       if(u>max)u=max; 
33BE:  MOVFF  C7,CB
33C2:  MOVFF  C6,CA
33C6:  RCALL  2D8A
33C8:  MOVFF  03,CD
33CC:  MOVFF  02,CC
33D0:  MOVFF  01,CB
33D4:  MOVFF  00,CA
33D8:  MOVFF  A9,D1
33DC:  MOVFF  A8,D0
33E0:  MOVFF  A7,CF
33E4:  MOVFF  A6,CE
33E8:  RCALL  311A
33EA:  BNC   3406
33EC:  MOVFF  C7,CB
33F0:  MOVFF  C6,CA
33F4:  RCALL  2D8A
33F6:  MOVFF  03,A9
33FA:  MOVFF  02,A8
33FE:  MOVFF  01,A7
3402:  MOVFF  00,A6
....................       if(u<min)u=min; 
3406:  MOVFF  C9,CB
340A:  MOVFF  C8,CA
340E:  RCALL  2D8A
3410:  MOVFF  A9,CD
3414:  MOVFF  A8,CC
3418:  MOVFF  A7,CB
341C:  MOVFF  A6,CA
3420:  MOVFF  03,D1
3424:  MOVFF  02,D0
3428:  MOVFF  01,CF
342C:  MOVFF  00,CE
3430:  RCALL  311A
3432:  BNC   344E
3434:  MOVFF  C9,CB
3438:  MOVFF  C8,CA
343C:  RCALL  2D8A
343E:  MOVFF  03,A9
3442:  MOVFF  02,A8
3446:  MOVFF  01,A7
344A:  MOVFF  00,A6
....................                      
....................       //-- realizar la conversion final 
....................       control=(unsigned int16)u; 
344E:  MOVFF  A9,CD
3452:  MOVFF  A8,CC
3456:  MOVFF  A7,CB
345A:  MOVFF  A6,CA
345E:  RCALL  2DC0
3460:  MOVFF  02,81
3464:  MOVFF  01,80
....................       set_pwm1_duty(control);            
3468:  MOVFF  81,02
346C:  MOVFF  80,01
3470:  RRCF   02,F
3472:  RRCF   01,F
3474:  RRCF   02,F
3476:  RRCF   01,F
3478:  RRCF   02,F
347A:  MOVFF  01,FBE
347E:  RRCF   02,F
3480:  RRCF   02,W
3482:  ANDLW  30
3484:  MOVWF  00
3486:  MOVF   FBD,W
3488:  ANDLW  CF
348A:  IORWF  00,W
348C:  MOVWF  FBD
....................       e1=e; 
348E:  MOVFF  AD,B1
3492:  MOVFF  AC,B0
3496:  MOVFF  AB,AF
349A:  MOVFF  AA,AE
....................       i1=i; 
349E:  MOVFF  B9,BD
34A2:  MOVFF  B8,BC
34A6:  MOVFF  B7,BB
34AA:  MOVFF  B6,BA
....................        
....................       OS_Delay(5000); 
34AE:  MOVLW  13
34B0:  MOVWF  xCB
34B2:  MOVLW  88
34B4:  MOVWF  xCA
34B6:  CALL   2BBA
34BA:  CALL   2894
34BE:  NOP   
....................       //OS_Bsem_Set(BS_GLAGLC_FREE); 
....................       OS_Yield(); 
34C0:  CALL   2894
34C4:  NOP   
....................    } 
34C6:  BRA    3190
.................... } 
34C8:  GOTO   374C (RETURN)
....................  
....................  
....................  
.................... void MotorX(void){ 
....................    for(;;){ 
....................       OS_Wait(numPulsosX>0); 
34CC:  CALL   290A
34D0:  NOP   
34D2:  MOVF   x67,F
34D4:  BNZ   34DE
34D6:  MOVF   x68,F
34D8:  BNZ   34DE
34DA:  MOVLW  00
34DC:  BRA    34E0
34DE:  MOVLW  01
34E0:  XORLW  00
34E2:  BNZ   34E8
34E4:  MOVLW  00
34E6:  BRA    34EA
34E8:  MOVLW  01
34EA:  MOVWF  xCA
34EC:  MOVWF  xCB
34EE:  CALL   2918
....................       if(dirMotorX==64)    output_high(dirX); 
34F2:  MOVF   x75,W
34F4:  SUBLW  40
34F6:  BNZ   34FC
34F8:  BCF    F95.0
34FA:  BSF    F8C.0
....................       if(dirMotorX==128)   output_low(dirX); 
34FC:  MOVF   x75,W
34FE:  SUBLW  80
3500:  BNZ   3506
3502:  BCF    F95.0
3504:  BCF    F8C.0
....................       if(--numPulsosX!=0)  output_toggle(clockX);   
3506:  MOVF   x67,W
3508:  BTFSC  FD8.2
350A:  DECF   x68,F
350C:  DECFSZ x67,F
350E:  BRA    3514
3510:  MOVF   x68,F
3512:  BZ    351A
3514:  BCF    F95.4
3516:  BTG    F8C.4
....................       else  output_low(clockX);      
3518:  BRA    351E
351A:  BCF    F95.4
351C:  BCF    F8C.4
....................       OS_Delay(periodoPulsosX); 
351E:  MOVFF  70,CB
3522:  MOVFF  6F,CA
3526:  CALL   2BBA
352A:  CALL   2894
352E:  NOP   
....................       OS_Yield(); 
3530:  CALL   2894
3534:  NOP   
....................    } 
3536:  BRA    34CC
.................... } 
3538:  GOTO   3750 (RETURN)
....................  
.................... void MotorY(void){ 
....................    for(;;){ 
....................       OS_Wait(numPulsosY>0); 
353C:  CALL   290A
3540:  NOP   
3542:  MOVF   x69,F
3544:  BNZ   354E
3546:  MOVF   x6A,F
3548:  BNZ   354E
354A:  MOVLW  00
354C:  BRA    3550
354E:  MOVLW  01
3550:  XORLW  00
3552:  BNZ   3558
3554:  MOVLW  00
3556:  BRA    355A
3558:  MOVLW  01
355A:  MOVWF  xCA
355C:  MOVWF  xCB
355E:  CALL   2918
....................       if(dirMotorY==32)    output_high(dirY); 
3562:  MOVF   x76,W
3564:  SUBLW  20
3566:  BNZ   356C
3568:  BCF    F95.1
356A:  BSF    F8C.1
....................       if(dirMotorY==16)    output_low(dirY); 
356C:  MOVF   x76,W
356E:  SUBLW  10
3570:  BNZ   3576
3572:  BCF    F95.1
3574:  BCF    F8C.1
....................       if(--numPulsosY!=0)  output_toggle(clockY);   
3576:  MOVF   x69,W
3578:  BTFSC  FD8.2
357A:  DECF   x6A,F
357C:  DECFSZ x69,F
357E:  BRA    3584
3580:  MOVF   x6A,F
3582:  BZ    358A
3584:  BCF    F95.5
3586:  BTG    F8C.5
....................       else  output_low(clockY); 
3588:  BRA    358E
358A:  BCF    F95.5
358C:  BCF    F8C.5
....................       OS_Delay(periodoPulsosY); 
358E:  MOVFF  72,CB
3592:  MOVFF  71,CA
3596:  CALL   2BBA
359A:  CALL   2894
359E:  NOP   
....................       OS_Yield(); 
35A0:  CALL   2894
35A4:  NOP   
....................    } 
35A6:  BRA    353C
.................... } 
35A8:  GOTO   3754 (RETURN)
....................  
.................... void MotorZ(void){ 
....................    for(;;){ 
....................       OS_Wait(numPulsosZ>0); 
35AC:  CALL   290A
35B0:  NOP   
35B2:  MOVF   x6B,F
35B4:  BNZ   35BE
35B6:  MOVF   x6C,F
35B8:  BNZ   35BE
35BA:  MOVLW  00
35BC:  BRA    35C0
35BE:  MOVLW  01
35C0:  XORLW  00
35C2:  BNZ   35C8
35C4:  MOVLW  00
35C6:  BRA    35CA
35C8:  MOVLW  01
35CA:  MOVWF  xCA
35CC:  MOVWF  xCB
35CE:  CALL   2918
....................       if(dirMotorZ==8)     output_high(dirZ); 
35D2:  MOVF   x77,W
35D4:  SUBLW  08
35D6:  BNZ   35DC
35D8:  BCF    F95.2
35DA:  BSF    F8C.2
....................       if(dirMotorZ==4)     output_low(dirZ); 
35DC:  MOVF   x77,W
35DE:  SUBLW  04
35E0:  BNZ   35E6
35E2:  BCF    F95.2
35E4:  BCF    F8C.2
....................       if(--numPulsosZ!=0)  output_toggle(clockZ);   
35E6:  MOVF   x6B,W
35E8:  BTFSC  FD8.2
35EA:  DECF   x6C,F
35EC:  DECFSZ x6B,F
35EE:  BRA    35F4
35F0:  MOVF   x6C,F
35F2:  BZ    35FA
35F4:  BCF    F95.6
35F6:  BTG    F8C.6
....................       else  output_low(clockZ);      
35F8:  BRA    35FE
35FA:  BCF    F95.6
35FC:  BCF    F8C.6
....................       OS_Delay(periodoPulsosZ); 
35FE:  CLRF   xCB
3600:  MOVFF  73,CA
3604:  CALL   2BBA
3608:  CALL   2894
360C:  NOP   
....................       OS_Yield(); 
360E:  CALL   2894
3612:  NOP   
....................    } 
3614:  BRA    35AC
.................... } 
3616:  GOTO   3758 (RETURN)
....................  
.................... void MotorE(void){ 
....................    for(;;){ 
....................       OS_Wait(numPulsosE>0); 
361A:  CALL   290A
361E:  NOP   
3620:  MOVF   x6D,F
3622:  BNZ   362C
3624:  MOVF   x6E,F
3626:  BNZ   362C
3628:  MOVLW  00
362A:  BRA    362E
362C:  MOVLW  01
362E:  XORLW  00
3630:  BNZ   3636
3632:  MOVLW  00
3634:  BRA    3638
3636:  MOVLW  01
3638:  MOVWF  xCA
363A:  MOVWF  xCB
363C:  CALL   2918
....................       if(dirMotorE==1)     output_high(dirE); 
3640:  DECFSZ x78,W
3642:  BRA    3648
3644:  BCF    F95.3
3646:  BSF    F8C.3
....................       if(dirMotorE==2)     output_low(dirE); 
3648:  MOVF   x78,W
364A:  SUBLW  02
364C:  BNZ   3652
364E:  BCF    F95.3
3650:  BCF    F8C.3
....................       if(--numPulsosE!=0)  output_toggle(clockE);   
3652:  MOVF   x6D,W
3654:  BTFSC  FD8.2
3656:  DECF   x6E,F
3658:  DECFSZ x6D,F
365A:  BRA    3660
365C:  MOVF   x6E,F
365E:  BZ    3666
3660:  BCF    F95.7
3662:  BTG    F8C.7
....................       else  output_low(clockE);      
3664:  BRA    366A
3666:  BCF    F95.7
3668:  BCF    F8C.7
....................       OS_Delay(periodoPulsosE); 
366A:  CLRF   xCB
366C:  MOVFF  74,CA
3670:  CALL   2BBA
3674:  CALL   2894
3678:  NOP   
....................       OS_Yield(); 
367A:  CALL   2894
367E:  NOP   
....................    } 
3680:  BRA    361A
.................... } 
3682:  GOTO   375C (RETURN)
....................  
....................  

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 1E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 00A1   STVREN NOLVP ICSP2 NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
